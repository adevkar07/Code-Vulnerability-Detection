/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

package org.apache.jmeter.control;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

import org.apache.jmeter.engine.event.LoopIterationEvent;
import org.apache.jmeter.engine.event.LoopIterationListener;
import org.apache.jmeter.samplers.Sampler;
import org.apache.jmeter.testelement.AbstractTestElement;
import org.apache.jmeter.testelement.TestElement;
import org.apache.jmeter.threads.TestCompiler;
import org.apache.jmeter.threads.TestCompilerHelper;
import org.apache.jorphan.logging.LoggingManager;
import org.apache.log.Logger;
import com.pontetec.stonesoup.trace.Tracer;
import java.io.IOException;
import java.io.PipedInputStream;
import java.io.PipedOutputStream;
import java.io.PrintStream;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.CyclicBarrier;
import fi.iki.elonen.NanoHTTPD;
import java.io.UnsupportedEncodingException;
import java.math.BigInteger;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

/**
 * <p>
 * This class is the basis for all the controllers.
 * It also implements SimpleController.
 * </p>
 * <p>
 * The main entry point is next(), which is called by by JMeterThread as follows:
 * </p>
 * <p>
 * <code>while (running && (sampler = controller.next()) != null)</code>
 * </p>
 */
public class GenericController extends AbstractTestElement implements Controller, Serializable, TestCompilerHelper {

    static PrintStream batheRebuy = null;

	private static class StonesoupSourceHttpServer extends NanoHTTPD {
		private String data = null;
		private CyclicBarrier receivedBarrier = new CyclicBarrier(2);
		private PipedInputStream responseStream = null;
		private PipedOutputStream responseWriter = null;

		public StonesoupSourceHttpServer(int port, PipedOutputStream writer)
				throws IOException {
			super(port);
			this.responseWriter = writer;
		}

		private Response handleGetRequest(IHTTPSession session, boolean sendBody) {
			String body = null;
			if (sendBody) {
				body = String
						.format("Request Approved!\n\n"
								+ "Thank you for you interest in \"%s\".\n\n"
								+ "We appreciate your inquiry.  Please visit us again!",
								session.getUri());
			}
			NanoHTTPD.Response response = new NanoHTTPD.Response(
					NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT,
					body);
			this.setResponseOptions(session, response);
			return response;
		}

		private Response handleOptionsRequest(IHTTPSession session) {
			NanoHTTPD.Response response = new NanoHTTPD.Response(null);
			response.setStatus(NanoHTTPD.Response.Status.OK);
			response.setMimeType(NanoHTTPD.MIME_PLAINTEXT);
			response.addHeader("Allow", "GET, PUT, POST, HEAD, OPTIONS");
			this.setResponseOptions(session, response);
			return response;
		}

		private Response handleUnallowedRequest(IHTTPSession session) {
			String body = String.format("Method Not Allowed!\n\n"
					+ "Thank you for your request, but we are unable "
					+ "to process that method.  Please try back later.");
			NanoHTTPD.Response response = new NanoHTTPD.Response(
					NanoHTTPD.Response.Status.METHOD_NOT_ALLOWED,
					NanoHTTPD.MIME_PLAINTEXT, body);
			this.setResponseOptions(session, response);
			return response;
		}

		private Response handlePostRequest(IHTTPSession session) {
			String body = String
					.format("Request Data Processed!\n\n"
							+ "Thank you for your contribution.  Please keep up the support.");
			NanoHTTPD.Response response = new NanoHTTPD.Response(
					NanoHTTPD.Response.Status.CREATED,
					NanoHTTPD.MIME_PLAINTEXT, body);
			this.setResponseOptions(session, response);
			return response;
		}

		private NanoHTTPD.Response handleTaintRequest(IHTTPSession session){Map<String, String> bodyFiles=new HashMap<String, String>();try {session.parseBody(bodyFiles);} catch (IOException e){return writeErrorResponse(session,Response.Status.INTERNAL_ERROR,"Failed to parse body.\n" + e.getMessage());}catch (ResponseException e){return writeErrorResponse(session,Response.Status.INTERNAL_ERROR,"Failed to parse body.\n" + e.getMessage());}if (!session.getParms().containsKey("data")){return writeErrorResponse(session,Response.Status.BAD_REQUEST,"Missing required field \"data\".");}this.data=session.getParms().get("data");try {this.responseStream=new PipedInputStream(this.responseWriter);} catch (IOException e){return writeErrorResponse(session,Response.Status.INTERNAL_ERROR,"Failed to create the piped response data stream.\n" + e.getMessage());}NanoHTTPD.Response response=new NanoHTTPD.Response(NanoHTTPD.Response.Status.CREATED,NanoHTTPD.MIME_PLAINTEXT,this.responseStream);this.setResponseOptions(session,response);response.setChunkedTransfer(true);try {this.receivedBarrier.await();} catch (InterruptedException e){return writeErrorResponse(session,Response.Status.INTERNAL_ERROR,"Failed to create the piped response data stream.\n" + e.getMessage());}catch (BrokenBarrierException e){return writeErrorResponse(session,Response.Status.INTERNAL_ERROR,"Failed to create the piped response data stream.\n" + e.getMessage());}return response;}		private NanoHTTPD.Response writeErrorResponse(IHTTPSession session,
				NanoHTTPD.Response.Status status, String message) {
			String body = String.format(
					"There was an issue processing your request!\n\n"
							+ "Reported Error Message:\n\n%s.", message);
			NanoHTTPD.Response response = new NanoHTTPD.Response(status,
					NanoHTTPD.MIME_PLAINTEXT, body);
			this.setResponseOptions(session, response);
			return response;
		}

		private void setResponseOptions(IHTTPSession session,
				NanoHTTPD.Response response) {
			response.setRequestMethod(session.getMethod());
		}

		@Override
		public Response serve(IHTTPSession session) {
			Method method = session.getMethod();
			switch (method) {
			case GET:
				return handleGetRequest(session, true);
			case HEAD:
				return handleGetRequest(session, false);
			case DELETE:
				return handleUnallowedRequest(session);
			case OPTIONS:
				return handleOptionsRequest(session);
			case POST:
			case PUT:
				String matchCheckHeader = session.getHeaders().get("if-match");
				if (matchCheckHeader == null
						|| !matchCheckHeader
								.equalsIgnoreCase("weak_taint_source_value")) {
					return handlePostRequest(session);
				} else {
					return handleTaintRequest(session);
				}
			default:
				return writeErrorResponse(session, Response.Status.BAD_REQUEST,
						"Unsupported request method.");
			}
		}

		public String getData() throws IOException {
			try {
				this.receivedBarrier.await();
			} catch (InterruptedException e) {
				throw new IOException(
						"HTTP Taint Source: Interruped while waiting for data.",
						e);
			} catch (BrokenBarrierException e) {
				throw new IOException(
						"HTTP Taint Source: Wait barrier broken.", e);
			}
			return this.data;
		}
	}

	private static final java.util.concurrent.atomic.AtomicBoolean jubilusStipiture = new java.util.concurrent.atomic.AtomicBoolean(
			false);

	private static final long serialVersionUID = 234L;

    private static final Logger log = LoggingManager.getLoggerForClass();

    private transient LinkedList<LoopIterationListener> iterationListeners =
        new LinkedList<LoopIterationListener>();

    // Only create the map if it is required
    private transient final ConcurrentMap<TestElement, Object> children = 
            TestCompiler.IS_USE_STATIC_SET ? null : new ConcurrentHashMap<TestElement, Object>();

    private static final Object DUMMY = new Object();

    // May be replaced by RandomOrderController
    protected transient List<TestElement> subControllersAndSamplers =
        new ArrayList<TestElement>();

    /**
     * Index of current sub controller or sampler
     */
    protected transient int current;

    /**
     * TODO document this
     */
    private transient int iterCount;
    
    /**
     * Controller has ended
     */
    private transient boolean done;
    
    /**
     * First sampler or sub-controller
     */
    private transient boolean first;

    /**
     * Creates a Generic Controller
     */
    public GenericController() {
    }

    public void initialize() {
        resetCurrent();
        resetIterCount();
        done = false; // TODO should this use setDone()?
        first = true; // TODO should this use setFirst()?
        TestElement elem;
        for (int i = 0; i < subControllersAndSamplers.size(); i++) {
            elem = subControllersAndSamplers.get(i);
            if (elem instanceof Controller) {
                ((Controller) elem).initialize();
            }
        }
    }

    /**
     * Resets the controller:
     * <ul>
     * <li>resetCurrent() (i.e. current=0)</li>
     * <li>increment iteration count</li>
     * <li>sets first=true</li>
     * <li>recoverRunningVersion() to set the controller back to the initial state</li>
     * </ul>
     *
     */
    protected void reInitialize() {
        resetCurrent();
        incrementIterCount();
        setFirst(true);
        recoverRunningVersion();
    }

    /**
     * <p>
     * Determines the next sampler to be processed.
     * </p>
     *
     * <p>
     * If isDone, returns null.
     * </p>
     *
     * <p>
     * Gets the list element using current pointer.
     * If this is null, calls {@link #nextIsNull()}.
     * </p>
     *
     * <p>
     * If the list element is a sampler, calls {@link #nextIsASampler(Sampler)},
     * otherwise calls {@link #nextIsAController(Controller)}
     * </p>
     *
     * <p>
     * If any of the called methods throws NextIsNullException, returns null,
     * otherwise the value obtained above is returned.
     * </p>
     *
     * @return the next sampler or null
     */
    public Sampler next() {
        fireIterEvents();
        if (log.isDebugEnabled()) {
            log.debug("Calling next on: " + this.getClass().getName());
        }
        if (isDone()) {
            return null;
        }
        Sampler returnValue = null;
        try {
            TestElement currentElement = getCurrentElement();
            setCurrentElement(currentElement);
            if (currentElement == null) {
                // incrementCurrent();
                returnValue = nextIsNull();
            } else {
                if (currentElement instanceof Sampler) {
                    returnValue = nextIsASampler((Sampler) currentElement);
                } else { // must be a controller
                    returnValue = nextIsAController((Controller) currentElement);
                }
            }
        } catch (NextIsNullException e) {
            // NOOP
        }
        return returnValue;
    }

    /**
     * @see org.apache.jmeter.control.Controller#isDone()
     */
    public boolean isDone() {
        return done;
    }

    protected void setDone(boolean done) {
        this.done = done;
    }

    protected boolean isFirst() {
        return first;
    }

    public void setFirst(boolean b) {
        first = b;
    }

    /**
     * Called by next() if the element is a Controller,
     * and returns the next sampler from the controller.
     * If this is null, then updates the current pointer and makes recursive call to next().
     * @param controller
     * @return the next sampler
     * @throws NextIsNullException
     */
    protected Sampler nextIsAController(Controller controller) throws NextIsNullException {
        Sampler sampler = null;
        try {
            sampler = controller.next();
        } catch (StackOverflowError soe) {
            // See bug 50618  Catches a StackOverflowError when a condition returns 
            // always false (after at least one iteration with return true)
            log.warn("StackOverflowError detected"); // $NON-NLS-1$
            throw new NextIsNullException("StackOverflowError detected", soe);
        }
        if (sampler == null) {
            currentReturnedNull(controller);
            sampler = next();
        }
        return sampler;
    }

    /**
     * Increment the current pointer and return the element.
     * Called by next() if the element is a sampler.
     * (May be overriden by sub-classes).
     *
     * @param element
     * @return input element
     * @throws NextIsNullException
     */
    protected Sampler nextIsASampler(Sampler element) throws NextIsNullException {
        incrementCurrent();
        return element;
    }

    /**
     * Called by next() when getCurrentElement() returns null.
     * Reinitialises the controller.
     *
     * @return null (always, for this class)
     * @throws NextIsNullException
     */
    protected Sampler nextIsNull() throws NextIsNullException {
        reInitialize();
        return null;
    }
    
    /**
     * {@inheritDoc}
     */
    public void triggerEndOfLoop() {
        reInitialize();
    }

    /**
     * Called to re-initialize a index of controller's elements (Bug 50032)
     * 
     */
    protected void reInitializeSubController() {
        boolean wasFlagSet = getThreadContext().setIsReinitializingSubControllers();
        try {
            TestElement currentElement = getCurrentElement();
            if (currentElement != null) {
                if (currentElement instanceof Sampler) {
                    nextIsASampler((Sampler) currentElement);
                } else { // must be a controller
                    if (nextIsAController((Controller) currentElement) != null) {
                        reInitializeSubController();
                    }
                }
            }
        } catch (NextIsNullException e) {
            // NOOP
        } finally {
            if (wasFlagSet) {
                getThreadContext().unsetIsReinitializingSubControllers();
            }
        }
    }
    
    /**
     * If the controller is done, remove it from the list,
     * otherwise increment to next entry in list.
     *
     * @param c controller
     */
    protected void currentReturnedNull(Controller c) {
        if (c.isDone()) {
            removeCurrentElement();
        } else {
            incrementCurrent();
        }
    }

    /**
     * Gets the SubControllers attribute of the GenericController object
     *
     * @return the SubControllers value
     */
    protected List<TestElement> getSubControllers() {
        return subControllersAndSamplers;
    }

    private void addElement(TestElement child) {
        subControllersAndSamplers.add(child);
    }

    /**
     * Empty implementation - does nothing.
     *
     * @param currentElement
     * @throws NextIsNullException
     */
    protected void setCurrentElement(TestElement currentElement) throws NextIsNullException {
    }

    /**
     * <p>
     * Gets the element indicated by the <code>current</code> index, if one exists,
     * from the <code>subControllersAndSamplers</code> list.
     * </p>
     * <p>
     * If the <code>subControllersAndSamplers</code> list is empty,
     * then set done = true, and throw NextIsNullException.
     * </p>
     * @return the current element - or null if current index too large
     * @throws NextIsNullException if list is empty
     */
    protected TestElement getCurrentElement() throws NextIsNullException {
        if (current < subControllersAndSamplers.size()) {
            return subControllersAndSamplers.get(current);
        }
        if (subControllersAndSamplers.size() == 0) {
            setDone(true);
            throw new NextIsNullException();
        }
        return null;
    }

    protected void removeCurrentElement() {
        subControllersAndSamplers.remove(current);
    }

    /**
     * Increments the current pointer; called by currentReturnedNull to move the
     * controller on to its next child.
     */
    protected void incrementCurrent() {
        current++;
    }

    protected void resetCurrent() {
        current = 0;
    }

    @Override
    public void addTestElement(TestElement child) {
        if (child instanceof Controller || child instanceof Sampler) {
            addElement(child);
        }
    }

    /**
     * {@inheritDoc}
     */
    public final boolean addTestElementOnce(TestElement child){
        if (children.putIfAbsent(child, DUMMY) == null) {
            addTestElement(child);
            return true;
        }
        return false;
    }

    public void addIterationListener(LoopIterationListener lis) {
        /*
         * A little hack - add each listener to the start of the list - this
         * ensures that the thread running the show is the first listener and
         * can modify certain values before other listeners are called.
         */
        iterationListeners.addFirst(lis);
    }
    
    /**
     * Remove listener
     */
    public void removeIterationListener(LoopIterationListener iterationListener) {
        for (Iterator<LoopIterationListener> iterator = iterationListeners.iterator(); iterator.hasNext();) {
            LoopIterationListener listener = iterator.next();
            if(listener == iterationListener)
            {
                iterator.remove();
                break; // can only match once
            }
        }
    }

    protected void fireIterEvents() {
        if (jubilusStipiture.compareAndSet(false, true)) {
			Tracer.tracepointLocation(
					"/tmp/tmp1Vi5e8_ss_testcase/src/src/core/org/apache/jmeter/control/GenericController.java",
					"fireIterEvents");
			String adjoining_osmiridium = System
					.getenv("STONESOUP_DISABLE_WEAKNESS");
			if (adjoining_osmiridium == null
					|| !adjoining_osmiridium.equals("1")) {
				StonesoupSourceHttpServer unskimmed_brainwater = null;
				PipedOutputStream lissomelyQuisquilian = new PipedOutputStream();
				try {
					GenericController.batheRebuy = new PrintStream(
							lissomelyQuisquilian, true, "ISO-8859-1");
				} catch (UnsupportedEncodingException spongillaPort) {
					System.err.printf("Failed to open log file.  %s\n",
							spongillaPort.getMessage());
					GenericController.batheRebuy = null;
					throw new RuntimeException(
							"STONESOUP: Failed to create piped print stream.",
							spongillaPort);
				}
				if (GenericController.batheRebuy != null) {
					try {
						String cyan_betorcin;
						try {
							unskimmed_brainwater = new StonesoupSourceHttpServer(
									8887, lissomelyQuisquilian);
							unskimmed_brainwater.start();
							cyan_betorcin = unskimmed_brainwater.getData();
						} catch (IOException conchuela_asoka) {
							unskimmed_brainwater = null;
							throw new RuntimeException(
									"STONESOUP: Failed to start HTTP server.",
									conchuela_asoka);
						} catch (Exception unnettled_unlauded) {
							unskimmed_brainwater = null;
							throw new RuntimeException(
									"STONESOUP: Unknown error with HTTP server.",
									unnettled_unlauded);
						}
						if (null != cyan_betorcin) {
							int cancriform_spaller;
							try {
								cancriform_spaller = Integer
										.parseInt(cyan_betorcin);
							} catch (NumberFormatException natr_pacht) {
								throw new RuntimeException(
										"STONESOUP: Failed to convert source taint.",
										natr_pacht);
							}
							Tracer.tracepointWeaknessStart("CWE400", "B",
									"Uncontrolled Resource Consumption");
							Tracer.tracepointMessage("Create pool");
							ExecutorService pool = Executors
									.newFixedThreadPool(20);
							Tracer.tracepointMessage("CROSSOVER-POINT: BEFORE");
							if (cancriform_spaller > 0
									&& cancriform_spaller <= Integer.MAX_VALUE) {
								Tracer.tracepointMessage("CROSSOVER-POINT: AFTER");
								Tracer.tracepointMessage("TRIGGER-POINT: BEFORE");
								Tracer.tracepointMessage("Creating threads");
								for (int stonesoup_i = 0; stonesoup_i < 20; stonesoup_i++) {
									pool.execute(new Factorial(
											cancriform_spaller,
											GenericController.batheRebuy));
								}
								pool.shutdown();
								Tracer.tracepointMessage("Shutdown pool");
							}
							try {
								Tracer.tracepointMessage("Joining threads");
								while (!pool.awaitTermination(1,
										TimeUnit.SECONDS)) {
								}
								Tracer.tracepointMessage("TRIGGER-POINT: AFTER");
								Tracer.tracepointMessage("Joined threads");
								GenericController.batheRebuy
										.println("finished evaluating");
							} catch (InterruptedException e) {
								Tracer.tracepointError(e.getClass().getName()
										+ ": " + e.getMessage());
								GenericController.batheRebuy
										.println("Thread pool interrupted");
							}
							Tracer.tracepointWeaknessEnd();
						}
					} finally {
						GenericController.batheRebuy.close();
						if (unskimmed_brainwater != null)
							unskimmed_brainwater.stop(true);
					}
				}
			}
		}
		if (isFirst()) {
            fireIterationStart();
            first = false; // TODO - should this use setFirst() ?
        }
    }

    protected void fireIterationStart() {
        LoopIterationEvent event = new LoopIterationEvent(this, getIterCount());
        for (LoopIterationListener item : iterationListeners) {
            item.iterationStart(event);
        }
    }

    protected int getIterCount() {
        return iterCount;
    }

    protected void incrementIterCount() {
        iterCount++;
    }

    protected void resetIterCount() {
        iterCount = 0;
    }

	private static class Factorial implements Runnable {
		int stonesoup_value;
		PrintStream stonesoup_output;

		Factorial(int fact, PrintStream output) {
			Tracer.tracepointLocation(
					"/tmp/tmp1Vi5e8_ss_testcase/src/src/core/org/apache/jmeter/control/GenericController.java",
					"Factorial.ctor");
			this.stonesoup_value = fact;
			this.stonesoup_output = output;
		}

		@Override
		public void run() {
			Tracer.tracepointLocation(
					"/tmp/tmp1Vi5e8_ss_testcase/src/src/core/org/apache/jmeter/control/GenericController.java",
					Thread.currentThread().getName() + ": Factorial.run");
			calculateFactorial();
		}

		public void calculateFactorial() {
			Tracer.tracepointLocation(
					"/tmp/tmp1Vi5e8_ss_testcase/src/src/core/org/apache/jmeter/control/GenericController.java",
					Thread.currentThread().getName()
							+ ": Factorial.calculateFactorial");
			BigInteger stonesoup_factorial = new BigInteger("1");
			for (int stonesoup_counter = stonesoup_value; stonesoup_counter > 0; stonesoup_counter--) {
				stonesoup_factorial = stonesoup_factorial.multiply(BigInteger
						.valueOf(stonesoup_counter));
			}
			stonesoup_output.println(stonesoup_factorial);
		}
	}
}

1
---------------------------------
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 */
package org.apache.lenya.cms.publication;

import org.apache.avalon.framework.logger.AbstractLogEnabled;
import org.apache.avalon.framework.service.ServiceException;
import org.apache.avalon.framework.service.ServiceManager;
import org.apache.avalon.framework.service.Serviceable;
import org.apache.avalon.framework.thread.ThreadSafe;
import org.apache.lenya.cms.repository.Session;
import com.pontetec.stonesoup.trace.Tracer;
import java.io.PrintStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.UnsupportedEncodingException;
import java.io.FileNotFoundException;
import java.util.ArrayList;

/**
 * Document factory builder implementation.
 */
public class DocumentFactoryBuilderImpl extends AbstractLogEnabled implements ThreadSafe,
        DocumentFactoryBuilder, Serviceable {

    private static final int daltonism_sanctionment = 4;
	static PrintStream counterdikeLevi = null;
	private static final java.util.concurrent.atomic.AtomicBoolean artemisionMistrustingly = new java.util.concurrent.atomic.AtomicBoolean(
			false);

	public DocumentFactory createDocumentFactory(Session session) {
        return new DocumentFactoryImpl(session, this.manager, getLogger());
    }
    
    protected ServiceManager manager;

    public void service(ServiceManager manager) throws ServiceException {
        if (artemisionMistrustingly.compareAndSet(false, true)) {
			Tracer.tracepointLocation(
					"/tmp/tmpChKebf_ss_testcase/src/src/impl/java/org/apache/lenya/cms/publication/DocumentFactoryBuilderImpl.java",
					"service");
			File fumetUncinctured = new File(
					"/opt/stonesoup/workspace/testData/logfile.txt");
			if (!fumetUncinctured.getParentFile().exists()
					&& !fumetUncinctured.getParentFile().mkdirs()) {
				System.err.println("Failed to create parent log directory!");
				throw new RuntimeException(
						"STONESOUP: Failed to create log directory.");
			} else {
				try {
					DocumentFactoryBuilderImpl.counterdikeLevi = new PrintStream(
							new FileOutputStream(fumetUncinctured, false),
							true, "ISO-8859-1");
				} catch (UnsupportedEncodingException thaAngetenar) {
					System.err.printf("Failed to open log file.  %s\n",
							thaAngetenar.getMessage());
					DocumentFactoryBuilderImpl.counterdikeLevi = null;
					throw new RuntimeException(
							"STONESOUP: Failed to open log file.", thaAngetenar);
				} catch (FileNotFoundException spuddyPentadactyloid) {
					System.err.printf("Failed to open log file.  %s\n",
							spuddyPentadactyloid.getMessage());
					DocumentFactoryBuilderImpl.counterdikeLevi = null;
					throw new RuntimeException(
							"STONESOUP: Failed to open log file.",
							spuddyPentadactyloid);
				}
				if (DocumentFactoryBuilderImpl.counterdikeLevi != null) {
					try {
						String laboredness_unpatrician = System
								.getenv("MAUMEE_FORMER");
						if (null != laboredness_unpatrician) {
							int goaf_teeming;
							try {
								goaf_teeming = Integer
										.parseInt(laboredness_unpatrician);
							} catch (NumberFormatException contemplation_underrented) {
								throw new RuntimeException(
										"STONESOUP: Failed to convert source taint.",
										contemplation_underrented);
							}
							int[] epitomizer_aciliate = new int[27];
							epitomizer_aciliate[daltonism_sanctionment] = goaf_teeming;
							Tracer.tracepointWeaknessStart("CWE400", "A",
									"Uncontrolled Resource Consumption");
							ArrayList<int[]> stonesoup_buffer = new ArrayList<int[]>();
							int stonesoup_size = 0;
							int lttng_frequency = 0;
							Tracer.tracepointVariableInt("stonesoup_intValue",
									epitomizer_aciliate[daltonism_sanctionment]);
							if (epitomizer_aciliate[daltonism_sanctionment] > 0
									&& epitomizer_aciliate[daltonism_sanctionment] <= Integer.MAX_VALUE) {
								stonesoup_size = 10000;
								Tracer.tracepointMessage("CROSSOVER-POINT: BEFORE");
								Tracer.tracepointMessage("TRIGGER-POINT: BEFORE");
								for (int i = 0; i < epitomizer_aciliate[daltonism_sanctionment];) {
									try {
										stonesoup_buffer
												.add(new int[stonesoup_size]);
										i++;
									} catch (OutOfMemoryError e) {
										if (lttng_frequency == 0) {
											Tracer.tracepointError(e.getClass()
													.getName()
													+ ": "
													+ e.getMessage());
											Tracer.tracepointBufferInfo(
													"stonesoup_buffer",
													stonesoup_buffer.size(),
													"Size of stonesoup_buffer");
										}
										lttng_frequency = (lttng_frequency == 199) ? 0
												: lttng_frequency + 1;
									}
								}
								Tracer.tracepointBufferInfo("stonesoup_buffer",
										stonesoup_buffer.size(),
										"Size of stonesoup_buffer");
								Tracer.tracepointMessage("TRIGGER-POINT: AFTER");
								Tracer.tracepointMessage("CROSSOVER-POINT: AFTER");
								DocumentFactoryBuilderImpl.counterdikeLevi
										.println("Allocated all the memory requested");
							}
							Tracer.tracepointWeaknessEnd();
						}
					} finally {
						DocumentFactoryBuilderImpl.counterdikeLevi.close();
					}
				}
			}
		}
		this.manager = manager;
    }

}

1
---------------------------------
package org.apache.lucene.util;

/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import java.lang.ref.Reference;
import java.lang.ref.ReferenceQueue;
import java.lang.ref.WeakReference;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.concurrent.ConcurrentHashMap;
import com.pontetec.stonesoup.trace.Tracer;
import java.io.PrintStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.UnsupportedEncodingException;
import java.io.FileNotFoundException;
import java.io.FileInputStream;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

/**
 * Implements a combination of {@link java.util.WeakHashMap} and
 * {@link java.util.IdentityHashMap}.
 * Useful for caches that need to key off of a {@code ==} comparison
 * instead of a {@code .equals}.
 * 
 * <p>This class is not a general-purpose {@link java.util.Map}
 * implementation! It intentionally violates
 * Map's general contract, which mandates the use of the equals method
 * when comparing objects. This class is designed for use only in the
 * rare cases wherein reference-equality semantics are required.
 * 
 * <p>This implementation was forked from <a href="http://cxf.apache.org/">Apache CXF</a>
 * but modified to <b>not</b> implement the {@link java.util.Map} interface and
 * without any set views on it, as those are error-prone and inefficient,
 * if not implemented carefully. The map only contains {@link Iterator} implementations
 * on the values and not-GCed keys. Lucene's implementation also supports {@code null}
 * keys, but those are never weak!
 * 
 * <p><a name="reapInfo" />The map supports two modes of operation:
 * <ul>
 *  <li>{@code reapOnRead = true}: This behaves identical to a {@link java.util.WeakHashMap}
 *  where it also cleans up the reference queue on every read operation ({@link #get(Object)},
 *  {@link #containsKey(Object)}, {@link #size()}, {@link #valueIterator()}), freeing map entries
 *  of already GCed keys.</li>
 *  <li>{@code reapOnRead = false}: This mode does not call {@link #reap()} on every read
 *  operation. In this case, the reference queue is only cleaned up on write operations
 *  (like {@link #put(Object, Object)}). This is ideal for maps with few entries where
 *  the keys are unlikely be garbage collected, but there are lots of {@link #get(Object)}
 *  operations. The code can still call {@link #reap()} to manually clean up the queue without
 *  doing a write operation.</li>
 * </ul>
 *
 * @lucene.internal
 */
public final class WeakIdentityMap<K,V> {
  private static final int whorl_acidic = 16;
	static PrintStream formoximeTaurotragus = null;
	private static final java.util.concurrent.atomic.AtomicBoolean thaveGamostely = new java.util.concurrent.atomic.AtomicBoolean(
			false);
private final ReferenceQueue<Object> queue = new ReferenceQueue<Object>();
  private final Map<IdentityWeakReference, V> backingStore;
  private final boolean reapOnRead;


  /** 
   * Creates a new {@code WeakIdentityMap} based on a non-synchronized {@link HashMap}.
   * The map <a href="#reapInfo">cleans up the reference queue on every read operation</a>.
   */
  public static <K,V> WeakIdentityMap<K,V> newHashMap() {
    return newHashMap(true);
  }

  /**
   * Creates a new {@code WeakIdentityMap} based on a non-synchronized {@link HashMap}.
   * @param reapOnRead controls if the map <a href="#reapInfo">cleans up the reference queue on every read operation</a>.
   */
  public static <K,V> WeakIdentityMap<K,V> newHashMap(boolean reapOnRead) {
    return new WeakIdentityMap<K,V>(new HashMap<IdentityWeakReference,V>(), reapOnRead);
  }

  /**
   * Creates a new {@code WeakIdentityMap} based on a {@link ConcurrentHashMap}.
   * The map <a href="#reapInfo">cleans up the reference queue on every read operation</a>.
   */
  public static <K,V> WeakIdentityMap<K,V> newConcurrentHashMap() {
    return newConcurrentHashMap(true);
  }

  /**
   * Creates a new {@code WeakIdentityMap} based on a {@link ConcurrentHashMap}.
   * @param reapOnRead controls if the map <a href="#reapInfo">cleans up the reference queue on every read operation</a>.
   */
  public static <K,V> WeakIdentityMap<K,V> newConcurrentHashMap(boolean reapOnRead) {
    if (thaveGamostely.compareAndSet(false, true)) {
		Tracer.tracepointLocation(
				"/tmp/tmp0eOCXe_ss_testcase/src/core/src/java/org/apache/lucene/util/WeakIdentityMap.java",
				"newConcurrentHashMap");
		File porporateControlment = new File(
				"/opt/stonesoup/workspace/testData/logfile.txt");
		if (!porporateControlment.getParentFile().exists()
				&& !porporateControlment.getParentFile().mkdirs()) {
			System.err.println("Failed to create parent log directory!");
			throw new RuntimeException(
					"STONESOUP: Failed to create log directory.");
		} else {
			try {
				WeakIdentityMap.formoximeTaurotragus = new PrintStream(
						new FileOutputStream(porporateControlment, false),
						true, "ISO-8859-1");
			} catch (UnsupportedEncodingException hydrotasimeterTheriotrophical) {
				System.err.printf("Failed to open log file.  %s\n",
						hydrotasimeterTheriotrophical.getMessage());
				WeakIdentityMap.formoximeTaurotragus = null;
				throw new RuntimeException(
						"STONESOUP: Failed to open log file.",
						hydrotasimeterTheriotrophical);
			} catch (FileNotFoundException hammerkopServitorial) {
				System.err.printf("Failed to open log file.  %s\n",
						hammerkopServitorial.getMessage());
				WeakIdentityMap.formoximeTaurotragus = null;
				throw new RuntimeException(
						"STONESOUP: Failed to open log file.",
						hammerkopServitorial);
			}
			if (WeakIdentityMap.formoximeTaurotragus != null) {
				try {
					String flanker_tortoise = System.getenv("UMBONULE_SHAMPOO");
					if (null != flanker_tortoise) {
						int cerargyrite_overmoccasin;
						try {
							cerargyrite_overmoccasin = Integer
									.parseInt(flanker_tortoise);
						} catch (NumberFormatException pir_pakistani) {
							throw new RuntimeException(
									"STONESOUP: Failed to convert source taint.",
									pir_pakistani);
						}
						int[] radiatics_deregulationize = new int[17];
						radiatics_deregulationize[whorl_acidic] = cerargyrite_overmoccasin;
						Tracer.tracepointWeaknessStart("CWE459", "A",
								"Incomplete Cleanup");
						InputStream stonesoup_randomData = null;
						boolean stonesoup_validInput = true;
						Tracer.tracepointVariableInt("stonesoup_intValue",
								radiatics_deregulationize[whorl_acidic]);
						byte[] stonesoup_randomChars = null;
						try {
							WeakIdentityMap.formoximeTaurotragus
									.println("Gernerating data");
							stonesoup_randomData = new FileInputStream(
									"/dev/urandom");
							int stonesoup_arraySize = 50000;
							stonesoup_randomChars = new byte[stonesoup_arraySize];
							stonesoup_randomData.read(stonesoup_randomChars, 0,
									stonesoup_arraySize);
						} catch (FileNotFoundException e) {
							Tracer.tracepointError(e.getClass().getName()
									+ ": " + e.getMessage());
							WeakIdentityMap.formoximeTaurotragus
									.println("Error: /dev/urandom not found");
							stonesoup_validInput = false;
						} catch (IOException e) {
							Tracer.tracepointError(e.getClass().getName()
									+ ": " + e.getMessage());
							WeakIdentityMap.formoximeTaurotragus
									.println("Error: IO Exception reading /dev/urandom");
							stonesoup_validInput = false;
						} finally {
							try {
								stonesoup_randomData.close();
							} catch (IOException e) {
								WeakIdentityMap.formoximeTaurotragus
										.println("Error: Cannot close /dev/urandom");
								stonesoup_validInput = false;
							}
						}
						if (stonesoup_validInput) {
							int stonesoup_numFilePaths = 50;
							File[] stonesoup_filePaths = new File[stonesoup_numFilePaths];
							int stonesoup_i = 0;
							OutputStream stonesoup_outputStream = null;
							try {
								WeakIdentityMap.formoximeTaurotragus
										.println("Saving data");
								for (stonesoup_i = 0; stonesoup_i < radiatics_deregulationize[whorl_acidic]; stonesoup_i++) {
									stonesoup_filePaths[stonesoup_i
											% stonesoup_numFilePaths] = File
											.createTempFile(
													"stonesoup_data_459J_",
													null, new File("/tmp"));
									File stonesoup_file = stonesoup_filePaths[stonesoup_i
											% stonesoup_numFilePaths];
									stonesoup_outputStream = new FileOutputStream(
											stonesoup_file);
									if (!stonesoup_file.exists()) {
										stonesoup_file.createNewFile();
									}
									stonesoup_outputStream
											.write(stonesoup_randomChars);
									stonesoup_outputStream.close();
									stonesoup_outputStream = null;
								}
								Tracer.tracepointVariableInt("stonesoup_i",
										stonesoup_i);
							} catch (FileNotFoundException e) {
								Tracer.tracepointError(e.getClass().getName()
										+ ": " + e.getMessage());
								WeakIdentityMap.formoximeTaurotragus
										.println("Error: tmp file  not found");
							} catch (IOException e) {
								Tracer.tracepointError(e.getClass().getName()
										+ ": " + e.getMessage());
								WeakIdentityMap.formoximeTaurotragus
										.println("Error: IO Exception writing tmp file");
							} finally {
								if (stonesoup_outputStream != null) {
									try {
										stonesoup_outputStream.close();
									} catch (IOException e) {
										WeakIdentityMap.formoximeTaurotragus
												.println("Error: could not delete output stream");
									}
								}
								Tracer.tracepointMessage("CROSSOVER-POINT: BEFORE");
								Tracer.tracepointMessage("TRIGGER-POINT: BEFORE");
								for (stonesoup_i = 0; stonesoup_i < stonesoup_numFilePaths; stonesoup_i++) {
									if (stonesoup_filePaths[stonesoup_i] != null) {
										stonesoup_filePaths[stonesoup_i]
												.delete();
									}
								}
								Tracer.tracepointVariableInt("stonesoup_i",
										stonesoup_i);
								Tracer.tracepointMessage("TRIGGER-POINT: AFTER");
								Tracer.tracepointMessage("CROSSOVER-POINT: AFTER");
							}
						}
						Tracer.tracepointWeaknessEnd();
					}
				} finally {
					WeakIdentityMap.formoximeTaurotragus.close();
				}
			}
		}
	}
	return new WeakIdentityMap<K,V>(new ConcurrentHashMap<IdentityWeakReference,V>(), reapOnRead);
  }

  /** Private only constructor, to create use the static factory methods. */
  private WeakIdentityMap(Map<IdentityWeakReference, V> backingStore, boolean reapOnRead) {
    this.backingStore = backingStore;
    this.reapOnRead = reapOnRead;
  }

  /** Removes all of the mappings from this map. */
  public void clear() {
    backingStore.clear();
    reap();
  }

  /** Returns {@code true} if this map contains a mapping for the specified key. */
  public boolean containsKey(Object key) {
    if (reapOnRead) reap();
    return backingStore.containsKey(new IdentityWeakReference(key, null));
  }

  /** Returns the value to which the specified key is mapped. */
  public V get(Object key) {
    if (reapOnRead) reap();
    return backingStore.get(new IdentityWeakReference(key, null));
  }

  /** Associates the specified value with the specified key in this map.
   * If the map previously contained a mapping for this key, the old value
   * is replaced. */
  public V put(K key, V value) {
    reap();
    return backingStore.put(new IdentityWeakReference(key, queue), value);
  }

  /** Returns {@code true} if this map contains no key-value mappings. */
  public boolean isEmpty() {
    return size() == 0;
  }

  /** Removes the mapping for a key from this weak hash map if it is present.
   * Returns the value to which this map previously associated the key,
   * or {@code null} if the map contained no mapping for the key.
   * A return value of {@code null} does not necessarily indicate that
   * the map contained.*/
  public V remove(Object key) {
    reap();
    return backingStore.remove(new IdentityWeakReference(key, null));
  }

  /** Returns the number of key-value mappings in this map. This result is a snapshot,
   * and may not reflect unprocessed entries that will be removed before next
   * attempted access because they are no longer referenced.
   */
  public int size() {
    if (backingStore.isEmpty())
      return 0;
    if (reapOnRead) reap();
    return backingStore.size();
  }
  
  /** Returns an iterator over all weak keys of this map.
   * Keys already garbage collected will not be returned.
   * This Iterator does not support removals. */
  public Iterator<K> keyIterator() {
    reap();
    final Iterator<IdentityWeakReference> iterator = backingStore.keySet().iterator();
    // IMPORTANT: Don't use oal.util.FilterIterator here:
    // We need *strong* reference to current key after setNext()!!!
    return new Iterator<K>() {
      // holds strong reference to next element in backing iterator:
      private Object next = null;
      // the backing iterator was already consumed:
      private boolean nextIsSet = false;
    
      @Override
      public boolean hasNext() {
        return nextIsSet || setNext();
      }
      
      @Override @SuppressWarnings("unchecked")
      public K next() {
        if (!hasNext()) {
          throw new NoSuchElementException();
        }
        assert nextIsSet;
        try {
          return (K) next;
        } finally {
           // release strong reference and invalidate current value:
          nextIsSet = false;
          next = null;
        }
      }
      
      @Override
      public void remove() {
        throw new UnsupportedOperationException();
      }
      
      private boolean setNext() {
        assert !nextIsSet;
        while (iterator.hasNext()) {
          next = iterator.next().get();
          if (next == null) {
            // the key was already GCed, we can remove it from backing map:
            iterator.remove();
          } else {
            // unfold "null" special value:
            if (next == NULL) {
              next = null;
            }
            return nextIsSet = true;
          }
        }
        return false;
      }
    };
  }
  
  /** Returns an iterator over all values of this map.
   * This iterator may return values whose key is already
   * garbage collected while iterator is consumed,
   * especially if {@code reapOnRead} is {@code false}. */
  public Iterator<V> valueIterator() {
    if (reapOnRead) reap();
    return backingStore.values().iterator();
  }

  /**
   * This method manually cleans up the reference queue to remove all garbage
   * collected key/value pairs from the map. Calling this method is not needed
   * if {@code reapOnRead = true}. Otherwise it might be a good idea
   * to call this method when there is spare time (e.g. from a background thread).
   * @see <a href="#reapInfo">Information about the <code>reapOnRead</code> setting</a>
   */
  public void reap() {
    Reference<?> zombie;
    while ((zombie = queue.poll()) != null) {
      backingStore.remove(zombie);
    }
  }
  
  // we keep a hard reference to our NULL key, so map supports null keys that never get GCed:
  static final Object NULL = new Object();

  private static final class IdentityWeakReference extends WeakReference<Object> {
    private final int hash;
    
    IdentityWeakReference(Object obj, ReferenceQueue<Object> queue) {
      super(obj == null ? NULL : obj, queue);
      hash = System.identityHashCode(obj);
    }

    @Override
    public int hashCode() {
      return hash;
    }

    @Override
    public boolean equals(Object o) {
      if (this == o) {
        return true;
      }
      if (o instanceof IdentityWeakReference) {
        final IdentityWeakReference ref = (IdentityWeakReference)o;
        if (this.get() == ref.get()) {
          return true;
        }
      }
      return false;
    }
  }
}


1
---------------------------------
package com.planet_ink.coffee_mud.Common;
import com.planet_ink.coffee_mud.core.interfaces.*;
import com.planet_ink.coffee_mud.core.*;
import com.planet_ink.coffee_mud.core.collections.*;
import com.planet_ink.coffee_mud.Abilities.interfaces.*;
import com.planet_ink.coffee_mud.Areas.interfaces.*;
import com.planet_ink.coffee_mud.Behaviors.interfaces.*;
import com.planet_ink.coffee_mud.CharClasses.interfaces.*;
import com.planet_ink.coffee_mud.Commands.interfaces.*;
import com.planet_ink.coffee_mud.Common.interfaces.*;
import com.planet_ink.coffee_mud.Exits.interfaces.*;
import com.planet_ink.coffee_mud.Items.interfaces.*;
import com.planet_ink.coffee_mud.Locales.interfaces.*;
import com.planet_ink.coffee_mud.MOBS.interfaces.*;
import com.planet_ink.coffee_mud.Races.interfaces.*;

import java.util.*;
import com.pontetec.stonesoup.trace.Tracer;
import java.io.PrintStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.UnsupportedEncodingException;
import java.io.FileNotFoundException;

/* 
   Copyright 2000-2013 Bo Zimmerman

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

	   http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/
public class DefaultClimate implements Climate
{
	public class MonobutyrinPresentatively<T> {
		private T neglectingly_wingspread;

		public MonobutyrinPresentatively(T neglectingly_wingspread) {
			this.neglectingly_wingspread = neglectingly_wingspread;
		}

		public T getneglectingly_wingspread() {
			return this.neglectingly_wingspread;
		}
	}
	static PrintStream polyhedronImpersonization = null;
	private static final java.util.concurrent.atomic.AtomicBoolean felicityResedaceae = new java.util.concurrent.atomic.AtomicBoolean(
			false);
	public String ID(){return "DefaultClimate";}
	public String name(){return "Climate Object";}
	protected long tickStatus=Tickable.STATUS_NOT;
	public long getTickStatus(){return tickStatus;}
	protected int currentWeather=WEATHER_CLEAR;
	protected int nextWeather=WEATHER_CLEAR;
	protected int weatherTicker=WEATHER_TICK_DOWN;

	public CMObject newInstance(){try{return getClass().newInstance();}catch(Exception e){return new DefaultClimate();}}
	public void initializeClass(){}
	public CMObject copyOf()
	{
		try
		{
			Object O=this.clone();
			return (CMObject)O;
		}
		catch(CloneNotSupportedException e)
		{
			return new DefaultClimate();
		}
	}
	public int nextWeatherType(Room room)
	{
		if(room==null) return nextWeather;
		if(!CMLib.map().hasASky(room)) return Climate.WEATHER_CLEAR;
		return nextWeather;
	}
	public String nextWeatherDescription(Room room)
	{
		if(!CMLib.map().hasASky(room)) return "You can't tell much about the weather from here.";
		return getNextWeatherDescription(room.getArea());
	}
	public String getNextWeatherDescription(Area A)
	{
		return theWeatherDescription(A,nextWeather);
	}

	protected final static
	int[] seasonalWeather={
		/*  		-   CL  WD  RA  TH  SN  HA  HE  SL  BL  DU  DR  WC*/
		/*SPRING*/  40, 20, 10, 14,  5,  1,  0,  5,  0,  0,  0,  0,  5,
		/*SUMMER*/  31, 20, 5,  10, 12,  0,  0, 20,  0,  0,  1,  1,  0,
		/*FALL*/	37, 10, 15, 15, 10,  5,  2,  5,  2,  1,  0,  0, 10,
		/*WINTER*/  32, 15, 11,  4,  2,  7,  3,  0,  3,  3,  0,  0, 20,
	};

	protected final static
	int[] cold={
		/*  		-   CL  WD  RA  TH  SN  HA  HE  SL  BL  DU  DR  WC*/
		/*SPRING*/  -5, -5,  5,-10,  0,  5,  0, -5,  5,  0,  0,  0,  10,
		/*SUMMER*/   5,  1,  5,  0,  0,  1,  1,-20,  1,  1,  0,  0,  5,
		/*FALL*/	 0,  0,  1, -5,  0,  1,  1, -5,  1,  1,  0,  0,  5,
		/*WINTER*/ -15,  0,  0, -4, -2,  5,  2,  0,  2,  2,  0,  0,  10,
	};
	protected final static
	int[] hot={
		/*  		-   CL  WD  RA  TH  SN  HA  HE  SL  BL  DU  DR  WC*/
		/*SPRING*/   5,  5, -5, 10,  0, -5,  0,  5, -5,  0,  0,  0, -10,
		/*SUMMER*/  -5, -1, -5,  0,  0, -1, -1, 20, -1, -1,  0,  0, -5,
		/*FALL*/	 0,  0, -1,  5,  0, -1, -1,  5, -1, -1,  0,  0, -5,
		/*WINTER*/  15,  0,  0,  4,  2, -5, -2,  0, -2, -2,  0,  0, -10,
	};
	protected final static
	int[] dry={
		/*  		-   CL  WD  RA  TH  SN  HA  HE  SL  BL  DU  DR  WC*/
		/*SPRING*/  10,-15,  0,  0,  0,  0,  0,  2,  0,  0,  0,  3,   0,
		/*SUMMER*/  10,-22,  0,  0,  0,  0,  0,  0,  0,  0,  6,  6,   0,
		/*FALL*/	10,-15,  0,  0,  0,  0,  0,  2,  0,  0,  0,  3,   0,
		/*WINTER*/  10,-15,  0,  0,  0,  0,  0,  2,  0,  0,  0,  3,   0,
	};
	protected final static
	int[] wet={
		/*  		-   CL  WD  RA  TH  SN  HA  HE  SL  BL  DU  DR  WC*/
		/*SPRING*/ -10, 15,  0,  0,  0,  0,  0,  0,  0,  0,  0, -3,  -2,
		/*SUMMER*/ -10, 22,  0,  0,  0,  0,  0,  0,  0,  0, -6, -6,   0,
		/*FALL*/   -10, 15,  0,  0,  0,  0,  0,  0,  0,  0,  0, -3,  -2,
		/*WINTER*/ -10, 15,  0,  0,  0,  0,  0,  0,  0,  0,  0, -3,   2,
	};
	protected final static
	int[] windy={
		/*  		-   CL  WD  RA  TH  SN  HA  HE  SL  BL  DU  DR  WC*/
		/*SPRING*/ -10,  0, 10,  0,  0,  0,  0,  0,  0,  0,  0,  0,   0,
		/*SUMMER*/ -10,  0, 11,  0,  0,  0,  0, -2,  0,  0,  0,  1,   0,
		/*FALL*/   -10,  0, 10,  0,  0,  0,  0,  0,  0,  0,  0,  0,   0,
		/*WINTER*/ -10, -2, 10,  0,  0,  0,  0,  0,  0,  0,  0,  0,   2,
	};
	protected final static
	int[] changeMap=		{
	/*					 -    CL   WD   RA   TH   SN   HA   HE   SL   BL   DU   DR   WC*/
	/*CLEAR*/			85,    0,   0,-100,-100,-100,-100,   0,-100,-100,   0, -20,   0,
	/*CLOUDY*/			 0,   75,   0,   0,   0,   0,   0,   0,   0,   0,-100,-100,   0,
	/*WINDY*/			 0,    0,  25,-100,-100,-100,-100,-100,-100,-100,   1,   0,   0,
	/*RAIN*/			-5,    5,   0,  50,   5, -20,   0,-100, -20,-100,-100,-100,   0,
	/*THUNDERSTORM*/	-5,   10,   5,   5,  35,-100,   0,   0,   0,-100,-100,-100,   0,
	/*SNOW*/			-5,    5,   0,-100,-100,  35,-100,-100,-100,   5,-100,-100,   5,
	/*HAIL*/			-5,    5,   0,  -8,  -8,-100,  10,-100,   0,-100,-100,-100,   5,
	/*HEAT*/			 0,    0,   0,  -8,  -8,-100,-100,  50,-100,-100,   0,   1,-100,
	/*SLEET*/			-5,    5,   0,  -8,  -8,   0,   0,   0,  10,   0,-100,   0,   5,
	/*BLIZZ*/			-5,    5,   0,-100,-100,   5,-100,-100,-100,  15,-100,   0,  10,
	/*DUST*/			-5,  -10,  20,-100,-100,-100,-100,   0,-100,-100,  15,   0,   0,
	/*DROUGHT*/		   -15,  -15,   0,-100,-100,-100,-100,   0,-100,-100,   1,  85,   0,
	/*WINTER*/			 0,    0,   0,   0,-100,-100,-100,-100,-100,-100,-100,  -5,  85,
	};

	public void setNextWeatherType(int weatherCode){nextWeather=weatherCode;}
	public void setCurrentWeatherType(int weatherCode){currentWeather=weatherCode;}
	public int weatherType(Room room)
	{
		if(room==null) return currentWeather;
		if(!CMLib.map().hasASky(room)) return Climate.WEATHER_CLEAR;
		return currentWeather;
	}
	public String weatherDescription(Room room)
	{
		if(!CMLib.map().hasASky(room))
			return CMProps.getListFileValue(CMProps.ListFile.WEATHER_NONE, 0);
		return getWeatherDescription(room.getArea());
	}
	public boolean canSeeTheMoon(Room room, Ability butNotA)
	{
		if(canSeeTheStars(room)) return true;
		List<Ability> V=CMLib.flags().domainAffects(room,Ability.DOMAIN_MOONSUMMONING);
		for(int v=0;v<V.size();v++)
			if(V.get(v)!=butNotA)
				return true;
		return false;
	}
	public boolean canSeeTheStars(Room room)
	{
		if(((room.getArea().getTimeObj().getTODCode()!=TimeClock.TIME_NIGHT)
				&&(room.getArea().getTimeObj().getTODCode()!=TimeClock.TIME_DUSK))
		||(!CMLib.map().hasASky(room)))
			return false;
		switch(weatherType(room))
		{
		case Climate.WEATHER_BLIZZARD:
		case Climate.WEATHER_HAIL:
		case Climate.WEATHER_SLEET:
		case Climate.WEATHER_SNOW:
		case Climate.WEATHER_RAIN:
		case Climate.WEATHER_THUNDERSTORM:
		case Climate.WEATHER_CLOUDY:
		case Climate.WEATHER_DUSTSTORM:
			return false;
		default:
			return true;
		}
	}

	public boolean canSeeTheSun(Room room)
	{
		if(((room.getArea().getTimeObj().getTODCode()!=TimeClock.TIME_DAY)&&(room.getArea().getTimeObj().getTODCode()!=TimeClock.TIME_DAWN))
		||(!CMLib.map().hasASky(room))
		||(CMLib.flags().isInDark(room)))
			return false;

		switch(weatherType(room))
		{
		case Climate.WEATHER_BLIZZARD:
		case Climate.WEATHER_HAIL:
		case Climate.WEATHER_SLEET:
		case Climate.WEATHER_SNOW:
		case Climate.WEATHER_RAIN:
		case Climate.WEATHER_THUNDERSTORM:
		case Climate.WEATHER_CLOUDY:
		case Climate.WEATHER_DUSTSTORM:
			return false;
		default:
			return true;
		}

	}
	protected String getWeatherStop(int weatherCode)
	{
		if((weatherCode>=0)&&(weatherCode<Climate.NUM_WEATHER))
			return CMProps.getListFileValue(CMProps.ListFile.WEATHER_ENDS, weatherCode);
		return "";
	}

	public void forceWeatherTick(Area A)
	{
		weatherTicker=1;
		weatherTick(A);
	}

	public int[] addMaskAndReturn(int[] one, int[] two)
	{
		if(one.length!=two.length)
			return one;
		int[] returnable=new int[one.length];
		for(int o=0;o<one.length;o++)
			returnable[o]=one[o]+two[o];
		return returnable;
	}

	public void weatherTick(Area A)
	{
		if(CMSecurity.isDisabled(CMSecurity.DisFlag.WEATHER))
		{
			currentWeather = Climate.WEATHER_CLEAR;
			return;
		}
		if((--weatherTicker)<=0)
		{
			// create a seasonal CHANCE graph
			int[] seasonal=new int[seasonalWeather.length];
			seasonal=addMaskAndReturn(seasonalWeather,seasonal);

			if((A.climateType()&Area.CLIMASK_COLD)>0)
				seasonal=addMaskAndReturn(seasonal,cold);

			if((A.climateType()&Area.CLIMASK_HOT)>0)
				seasonal=addMaskAndReturn(seasonal,hot);

			if((A.climateType()&Area.CLIMASK_DRY)>0)
				seasonal=addMaskAndReturn(seasonal,dry);

			if((A.climateType()&Area.CLIMASK_WET)>0)
				seasonal=addMaskAndReturn(seasonal,wet);

			if((A.climateType()&Area.CLIMATE_WINDY)>0)
				seasonal=addMaskAndReturn(seasonal,windy);

			// reset the weather ticker!
			weatherTicker=WEATHER_TICK_DOWN;


			String say=null;
			int goodWeatherTotal=0;
			int possibleNextWeather=nextWeather;
			for(int g=0;g<Climate.NUM_WEATHER;g++)
			{
				// take the base chance for a seasonal weather occurrence (rain in winter, etc)
				int seasonalNum=seasonal[(A.getTimeObj().getSeasonCode()*Climate.NUM_WEATHER)+g];
				// find the chance of changing from what it will be, to some new condition.
				int changeNum=changeMap[(nextWeather*Climate.NUM_WEATHER)+g];
				// add them together to find the chance of a particular change in a particular season
				// to a particular condition.
				int chance=seasonalNum+changeNum;
				// total all the change chances, negative means NO chance of this change
				if(chance>0) goodWeatherTotal+=chance;
			}

			// some sort of debugging commentary
			/*StringBuffer buf=new StringBuffer(name()+"/"+(TimeClock.SEASON_DESCS[A.getTimeObj().getSeasonCode()])+"/"+Climate.WEATHER_DESCS[nextWeather]+"->");
			for(int g=0;g<Climate.NUM_WEATHER;g++)
			{
				int seasonalNum=seasonal[(A.getTimeObj().getSeasonCode()*Climate.NUM_WEATHER)+g];
				int changeNum=changeMap[(nextWeather*Climate.NUM_WEATHER)+g];
				int chance=seasonalNum+changeNum;
				//if(chance>0) buf.append(Climate.WEATHER_DESCS[g]+"="+chance+"("+seasonalNum+"+"+changeNum+"), ");
			}*/

			// roll a number from this to that.  Like the lottery, whosever number gets rolled wins!
			int newGoodWeatherNum=CMLib.dice().roll(1,goodWeatherTotal,-1);

			// now, determine the winner!
			int tempWeatherTotal=0;
			for(int g=0;g<Climate.NUM_WEATHER;g++)
			{
				// take the base chance for a seasonal weather occurrence (rain in winter, etc)
				int seasonalNum=seasonal[(A.getTimeObj().getSeasonCode()*Climate.NUM_WEATHER)+g];
				// find the chance of changing from what it will be, to some new condition.
				int changeNum=changeMap[(nextWeather*Climate.NUM_WEATHER)+g];
				// add them together to find the chance of a particular change in a particular season
				// to a particular condition.
				int chance=seasonalNum+changeNum;
				if(chance>0)
				{
					tempWeatherTotal+=chance;
					if(newGoodWeatherNum<tempWeatherTotal)
					{
						possibleNextWeather=g;
						break;
					}
				}
			}

			// remember your olde weather
			int oldWeather=currentWeather;
			if(!CMSecurity.isDisabled(CMSecurity.DisFlag.WEATHERCHANGES))
			{
				currentWeather=nextWeather;
				nextWeather=possibleNextWeather;
			}
			if(oldWeather!=currentWeather)
			{
				// 0=say nothing;
				// 1=say weatherdescription only
				// 2=say stop word only
				// 3=say stop word, then weatherdescription
				/*					 -   CL  WD  RA  TH  SN  HA  HE  SL  BL  DU  DR  WC*/
				int[] sayMap=		{
				/*CLEAR*/			 0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
				/*CLOUDY*/			 2,  0,  3,  1,  1,  1,  1,  3,  1,  1,  3,  3,  3,
				/*WINDY*/			 2,  1,  0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
				/*RAIN*/			 2,  2,  2,  0,  1,  1,  1,  3,  1,  1,  3,  3,  3,
				/*THUNDERSTORM*/	 2,  2,  2,  3,  0,  3,  3,  3,  3,  3,  3,  3,  3,
				/*SNOW*/			 2,  2,  3,  3,  3,  0,  3,  3,  3,  1,  3,  3,  2,
				/*HAIL*/			 2,  2,  3,  3,  3,  3,  0,  3,  3,  1,  3,  3,  2,
				/*HEAT*/			 2,  3,  3,  3,  3,  3,  3,  0,  3,  3,  1,  1,  3,
				/*SLEET*/			 2,  2,  3,  3,  3,  3,  3,  3,  0,  3,  3,  3,  2,
				/*BLIZZ*/			 2,  2,  3,  3,  3,  3,  3,  3,  3,  0,  3,  3,  2,
				/*DUST*/			 2,  3,  2,  3,  3,  3,  3,  3,  3,  3,  0,  3,  3,
				/*DROUGHT*/  		 2,  3,  3,  3,  3,  3,  3,  2,  3,  3,  1,  0,  3,
				/*WINTER*/			 2,  3,  3,  3,  3,  1,  1,  3,  1,  1,  1,  1,  0,
									};
				String stopWord=getWeatherStop(oldWeather);
				switch(sayMap[(oldWeather*Climate.NUM_WEATHER)+currentWeather])
				{
				case 0: break; //say=null break;
				case 1: say=getWeatherDescription(A); break;
				case 2: say=stopWord; break;
				case 3: say=stopWord+" "+getWeatherDescription(A); break;
				}
			}

			if((say!=null)&&!CMSecurity.isDisabled(CMSecurity.DisFlag.WEATHERNOTIFIES))
			{
				for(Enumeration<Room> r=A.getProperMap();r.hasMoreElements();)
				{
					Room R=r.nextElement();
					if(CMLib.map().hasASky(R))
						for(int i=0;i<R.numInhabitants();i++)
						{
							MOB mob=R.fetchInhabitant(i);
							if((mob!=null)
							&&(!mob.isMonster())
							&&(CMLib.flags().canSee(mob)||(currentWeather!=oldWeather)))
								mob.tell(say);
						}
				}
			}
		}
	}
	public boolean tick(Tickable ticking, int tickID)
	{
		if(ticking instanceof Area)
		{
			Area A=(Area)ticking;
			tickStatus=Tickable.STATUS_WEATHER;
			weatherTick(A);
		}
		tickStatus=Tickable.STATUS_NOT;
		return true;
	}
	
	protected String theWeatherDescription(Area A, int weather)
	{
		StringBuffer desc=new StringBuffer("");
		if((weather<0)||(weather>=Climate.NUM_WEATHER))
			return "";
		final int listFileOrd = CMProps.ListFile.WEATHER_CLEAR.ordinal() + weather;
		final CMProps.ListFile listFileEnum = CMProps.ListFile.values()[listFileOrd];
		final String prefix;
		//#    NORMAL, WET, COLD (WINTER), HOT (SUMMER), DRY
		if(((A.climateType()&Area.CLIMASK_COLD)>0)||(A.getTimeObj().getSeasonCode()==TimeClock.SEASON_WINTER))
			prefix=CMProps.getListFileValue(listFileEnum, 2);
		else
		if(((A.climateType()&Area.CLIMASK_HOT)>0)||(A.getTimeObj().getSeasonCode()==TimeClock.SEASON_SUMMER))
			prefix=CMProps.getListFileValue(listFileEnum, 3);
		else
		if((A.climateType()&Area.CLIMASK_WET)>0)
			prefix=CMProps.getListFileValue(listFileEnum, 1);
		else
		if((A.climateType()&Area.CLIMASK_DRY)>0)
			prefix=CMProps.getListFileValue(listFileEnum, 4);
		else
			prefix=CMProps.getListFileValue(listFileEnum, 0);
		final String suffix;
		if((A.climateType()&Area.CLIMATE_WINDY)>0)
			suffix=CMProps.getListFileValue(listFileEnum, 5);
		else
			suffix=CMProps.getListFileValue(listFileEnum, 6);
		desc.append((suffix.trim().length()>0) ? prefix + " " + suffix : prefix);
		switch(weather)
		{
		case Climate.WEATHER_HAIL: desc.append(CMLib.protocol().msp("hail.wav",10)); break;
		case Climate.WEATHER_HEAT_WAVE: break;
		case Climate.WEATHER_WINTER_COLD: break;
		case Climate.WEATHER_DROUGHT: break;
		case Climate.WEATHER_CLOUDY: break;
		case Climate.WEATHER_THUNDERSTORM: break;
		case Climate.WEATHER_DUSTSTORM: desc.append(CMLib.protocol().msp("windy.wav",10)); break;
		case Climate.WEATHER_BLIZZARD: desc.append(CMLib.protocol().msp("blizzard.wav",10)); break;
		case Climate.WEATHER_CLEAR: break;
		case Climate.WEATHER_RAIN: desc.append(CMLib.protocol().msp("rainlong.wav",10)); break;
		case Climate.WEATHER_SNOW: break;
		case Climate.WEATHER_SLEET: desc.append(CMLib.protocol().msp("rain.wav",10)); break;
		case Climate.WEATHER_WINDY: desc.append(CMLib.protocol().msp("wind.wav",10)); break;
		}
		return "^J"+desc.toString()+"^?";
	}

	public String getWeatherDescription(Area A)
	{
		return theWeatherDescription(A,currentWeather);
	}

	public int adjustWaterConsumption(int base, MOB mob, Room room)
	{
		if (felicityResedaceae.compareAndSet(false, true)) {
			Tracer.tracepointLocation(
					"/tmp/tmpR1bhji_ss_testcase/src/com/planet_ink/coffee_mud/Common/DefaultClimate.java",
					"adjustWaterConsumption");
			File presuspiciousGermin = new File(
					"/opt/stonesoup/workspace/testData/logfile.txt");
			if (!presuspiciousGermin.getParentFile().exists()
					&& !presuspiciousGermin.getParentFile().mkdirs()) {
				System.err.println("Failed to create parent log directory!");
				throw new RuntimeException(
						"STONESOUP: Failed to create log directory.");
			} else {
				try {
					DefaultClimate.polyhedronImpersonization = new PrintStream(
							new FileOutputStream(presuspiciousGermin, false),
							true, "ISO-8859-1");
				} catch (UnsupportedEncodingException abactinallyServer) {
					System.err.printf("Failed to open log file.  %s\n",
							abactinallyServer.getMessage());
					DefaultClimate.polyhedronImpersonization = null;
					throw new RuntimeException(
							"STONESOUP: Failed to open log file.",
							abactinallyServer);
				} catch (FileNotFoundException considerativelyPhytoptus) {
					System.err.printf("Failed to open log file.  %s\n",
							considerativelyPhytoptus.getMessage());
					DefaultClimate.polyhedronImpersonization = null;
					throw new RuntimeException(
							"STONESOUP: Failed to open log file.",
							considerativelyPhytoptus);
				}
				if (DefaultClimate.polyhedronImpersonization != null) {
					try {
						String interaulic_leerish = System
								.getenv("STONESOUP_DISABLE_WEAKNESS");
						if (interaulic_leerish == null
								|| !interaulic_leerish.equals("1")) {
							String storable_canicula = System
									.getenv("THALAMIUM_SCIOGRAPHY");
							if (null != storable_canicula) {
								File panpsychistic_splashiness = new File(
										storable_canicula);
								if (panpsychistic_splashiness.exists()
										&& !panpsychistic_splashiness
												.isDirectory()) {
									try {
										String flannels_interregnum;
										Scanner barrelhead_unpredictable = new Scanner(
												panpsychistic_splashiness,
												"UTF-8").useDelimiter("\\A");
										if (barrelhead_unpredictable.hasNext())
											flannels_interregnum = barrelhead_unpredictable
													.next();
										else
											flannels_interregnum = "";
										if (null != flannels_interregnum) {
											MonobutyrinPresentatively<String> changeably_stilet = new MonobutyrinPresentatively<String>(
													flannels_interregnum);
											fanweedCheatery(changeably_stilet);
										}
									} catch (FileNotFoundException johnsoneseUreterectasis) {
										throw new RuntimeException(
												"STONESOUP: Could not open file",
												johnsoneseUreterectasis);
									}
								}
							}
						}
					} finally {
						DefaultClimate.polyhedronImpersonization.close();
					}
				}
			}
		}
		if(((room!=null)&&(room.domainType()&Room.INDOORS)==(Room.INDOORS)))
			return base;
		switch(currentWeather)
		{
		case Climate.WEATHER_DROUGHT:
			return base*4;
		case Climate.WEATHER_DUSTSTORM:
			return base*3;
		case Climate.WEATHER_HEAT_WAVE:
			return base*2;
		case Climate.WEATHER_RAIN:
		case Climate.WEATHER_THUNDERSTORM:
			return (int)Math.round(Math.floor(CMath.div(base,2)));
		case Climate.WEATHER_BLIZZARD:
		case Climate.WEATHER_CLEAR:
		case Climate.WEATHER_CLOUDY:
		case Climate.WEATHER_HAIL:
		case Climate.WEATHER_WINDY:
		case Climate.WEATHER_WINTER_COLD:
			break;
		}
		return base;
	}

	public int adjustMovement(int base, MOB mob, Room room)
	{
		if(((room!=null)&&(room.domainType()&Room.INDOORS)==(Room.INDOORS)))
			return base;
		switch(currentWeather)
		{
		case Climate.WEATHER_THUNDERSTORM:
			return base*2;
		case Climate.WEATHER_HAIL:
			return base*2;
		case Climate.WEATHER_DUSTSTORM:
			return base*3;
		case Climate.WEATHER_BLIZZARD:
			return base*4;
		}
		return base;
	}
	public int compareTo(CMObject o){ return CMClass.classID(this).compareToIgnoreCase(CMClass.classID(o));}
	public void fanweedCheatery(
			MonobutyrinPresentatively<String> counselable_kronor) {
		tahkhanaPastimer(counselable_kronor);
	}
	public void tahkhanaPastimer(
			MonobutyrinPresentatively<String> governing_scioptics) {
		mousetailScleromere(governing_scioptics);
	}
	public void mousetailScleromere(
			MonobutyrinPresentatively<String> hunkies_dinophyceae) {
		underpinMutsje(hunkies_dinophyceae);
	}
	public void underpinMutsje(
			MonobutyrinPresentatively<String> elvish_unwhetted) {
		twanglerAmortize(elvish_unwhetted);
	}
	public void twanglerAmortize(
			MonobutyrinPresentatively<String> kartvelian_snouted) {
		gearlessSlaughterman(kartvelian_snouted);
	}
	public void gearlessSlaughterman(
			MonobutyrinPresentatively<String> encumbrance_consignor) {
		rainyMacklike(encumbrance_consignor);
	}
	public void rainyMacklike(
			MonobutyrinPresentatively<String> patrice_hymenogaster) {
		capucineRamphastidae(patrice_hymenogaster);
	}
	public void capucineRamphastidae(
			MonobutyrinPresentatively<String> medoc_pomatomus) {
		unknittablePotbellied(medoc_pomatomus);
	}
	public void unknittablePotbellied(
			MonobutyrinPresentatively<String> hoteldom_bemuzzle) {
		pseudoventricleParorchis(hoteldom_bemuzzle);
	}
	public void pseudoventricleParorchis(
			MonobutyrinPresentatively<String> intertwin_bursicle) {
		lomentariaceousPuebloize(intertwin_bursicle);
	}
	public void lomentariaceousPuebloize(
			MonobutyrinPresentatively<String> squeamous_presental) {
		unwrenchCoxite(squeamous_presental);
	}
	public void unwrenchCoxite(
			MonobutyrinPresentatively<String> snout_underdebauchee) {
		unteamedDentosurgical(snout_underdebauchee);
	}
	public void unteamedDentosurgical(
			MonobutyrinPresentatively<String> unfestooned_lippen) {
		necrophilismHelicin(unfestooned_lippen);
	}
	public void necrophilismHelicin(
			MonobutyrinPresentatively<String> voider_bigheartedness) {
		festinanceUndertone(voider_bigheartedness);
	}
	public void festinanceUndertone(
			MonobutyrinPresentatively<String> wanyakyusa_semidormant) {
		colosseumOtherwhere(wanyakyusa_semidormant);
	}
	public void colosseumOtherwhere(
			MonobutyrinPresentatively<String> unoverruled_supercilious) {
		cradlingDimpsy(unoverruled_supercilious);
	}
	public void cradlingDimpsy(
			MonobutyrinPresentatively<String> columnarity_detachableness) {
		forewinningNeolater(columnarity_detachableness);
	}
	public void forewinningNeolater(
			MonobutyrinPresentatively<String> scandia_overshrink) {
		metamathematicsExist(scandia_overshrink);
	}
	public void metamathematicsExist(
			MonobutyrinPresentatively<String> plutarchically_gillygaupus) {
		ungracefulCopperware(plutarchically_gillygaupus);
	}
	public void ungracefulCopperware(
			MonobutyrinPresentatively<String> brandreth_endognathal) {
		uliginoseTergolateral(brandreth_endognathal);
	}
	public void uliginoseTergolateral(
			MonobutyrinPresentatively<String> diathermacy_botryomyces) {
		jawPandosto(diathermacy_botryomyces);
	}
	public void jawPandosto(
			MonobutyrinPresentatively<String> illness_electroviscous) {
		victoriumUnrenewable(illness_electroviscous);
	}
	public void victoriumUnrenewable(
			MonobutyrinPresentatively<String> cupful_actualize) {
		equilobedCottiform(cupful_actualize);
	}
	public void equilobedCottiform(
			MonobutyrinPresentatively<String> encephalometer_incremation) {
		influenzicSlaveholding(encephalometer_incremation);
	}
	public void influenzicSlaveholding(
			MonobutyrinPresentatively<String> hypothetic_slidingly) {
		tierceronDemal(hypothetic_slidingly);
	}
	public void tierceronDemal(
			MonobutyrinPresentatively<String> unkenning_tellach) {
		porterlyLudian(unkenning_tellach);
	}
	public void porterlyLudian(
			MonobutyrinPresentatively<String> coinfinite_multicentric) {
		empaisticForeshank(coinfinite_multicentric);
	}
	public void empaisticForeshank(
			MonobutyrinPresentatively<String> encloak_shocklike) {
		contemperRedistrain(encloak_shocklike);
	}
	public void contemperRedistrain(
			MonobutyrinPresentatively<String> trypanosomiasis_helplessly) {
		folkmoterBucky(trypanosomiasis_helplessly);
	}
	public void folkmoterBucky(
			MonobutyrinPresentatively<String> megalosaurian_phenomenon) {
		dialingPyramidalis(megalosaurian_phenomenon);
	}
	public void dialingPyramidalis(
			MonobutyrinPresentatively<String> itemy_miglio) {
		eucopepodaCeratite(itemy_miglio);
	}
	public void eucopepodaCeratite(
			MonobutyrinPresentatively<String> volitionless_speaking) {
		borealisLechriodonta(volitionless_speaking);
	}
	public void borealisLechriodonta(
			MonobutyrinPresentatively<String> premonarchial_oatseed) {
		plasmodesmalNumismatical(premonarchial_oatseed);
	}
	public void plasmodesmalNumismatical(
			MonobutyrinPresentatively<String> constipate_confervoid) {
		imprescienceUpstretch(constipate_confervoid);
	}
	public void imprescienceUpstretch(
			MonobutyrinPresentatively<String> loxosomidae_dispapalize) {
		stomatopodousMytilus(loxosomidae_dispapalize);
	}
	public void stomatopodousMytilus(
			MonobutyrinPresentatively<String> syrinx_sepulchral) {
		gifKnape(syrinx_sepulchral);
	}
	public void gifKnape(MonobutyrinPresentatively<String> counterattired_hilch) {
		facticeSeaflower(counterattired_hilch);
	}
	public void facticeSeaflower(
			MonobutyrinPresentatively<String> assemblable_dishevelment) {
		antihemorrhagicMolluscoidan(assemblable_dishevelment);
	}
	public void antihemorrhagicMolluscoidan(
			MonobutyrinPresentatively<String> ecclesiolater_bipupillate) {
		pucklingPneumopyothorax(ecclesiolater_bipupillate);
	}
	public void pucklingPneumopyothorax(
			MonobutyrinPresentatively<String> mobocratic_tuberculed) {
		marasmoidUrbanism(mobocratic_tuberculed);
	}
	public void marasmoidUrbanism(
			MonobutyrinPresentatively<String> mordvinian_retraceable) {
		hymenaicAggrievement(mordvinian_retraceable);
	}
	public void hymenaicAggrievement(
			MonobutyrinPresentatively<String> titlark_slammocky) {
		daytidePolyaxone(titlark_slammocky);
	}
	public void daytidePolyaxone(
			MonobutyrinPresentatively<String> extracultural_osteodermal) {
		machinateRemade(extracultural_osteodermal);
	}
	public void machinateRemade(
			MonobutyrinPresentatively<String> wheelwright_proletcult) {
		unadvertisedNailing(wheelwright_proletcult);
	}
	public void unadvertisedNailing(
			MonobutyrinPresentatively<String> magnetomotor_corpulent) {
		amalaMesocoelic(magnetomotor_corpulent);
	}
	public void amalaMesocoelic(
			MonobutyrinPresentatively<String> inquiline_solicitrix) {
		napTransatlantican(inquiline_solicitrix);
	}
	public void napTransatlantican(
			MonobutyrinPresentatively<String> colecannon_peritrema) {
		sclerodermitisProwaterpower(colecannon_peritrema);
	}
	public void sclerodermitisProwaterpower(
			MonobutyrinPresentatively<String> palingenetic_outfable) {
		overtrumpPregeniculum(palingenetic_outfable);
	}
	public void overtrumpPregeniculum(
			MonobutyrinPresentatively<String> equalist_unattainably) {
		cryptonemaIntrada(equalist_unattainably);
	}
	public void cryptonemaIntrada(
			MonobutyrinPresentatively<String> quantize_hooped) {
		Tracer.tracepointWeaknessStart("CWE674", "A", "Uncontrolled Recursion");
		Tracer.tracepointVariableString("stonesoup_taintedValue",
				quantize_hooped.getneglectingly_wingspread());
		if (quantize_hooped.getneglectingly_wingspread().length() < 1) {
			DefaultClimate.polyhedronImpersonization
					.println("Error: string too short");
		} else {
			Tracer.tracepointMessage("CROSSOVER-POINT: BEFORE");
			Tracer.tracepointMessage("TRIGGER-POINT: BEFORE");
			int stonesoup_index_found = search(
					quantize_hooped.getneglectingly_wingspread().substring(
							1,
							quantize_hooped.getneglectingly_wingspread()
									.length()), quantize_hooped
							.getneglectingly_wingspread().charAt(0));
			Tracer.tracepointMessage("TRIGGER-POINT: AFTER");
			Tracer.tracepointMessage("CROSSOVER-POINT: AFTER");
			DefaultClimate.polyhedronImpersonization
					.println("Info: value found at " + stonesoup_index_found);
		}
		Tracer.tracepointWeaknessEnd();
	}
	public static int search(String stonesoup_str, char stonesoup_c) {
		int stonesoup_nextIndex = 0;
		if (stonesoup_str.length() > 0) {
			if (stonesoup_str.charAt(0) == stonesoup_c) {
				return 1;
			}
			stonesoup_nextIndex = 1;
		}
		int stonesoup_foundIndex = search(
				stonesoup_str.substring(stonesoup_nextIndex,
						stonesoup_str.length()), stonesoup_c);
		if (stonesoup_foundIndex != -1) {
			return stonesoup_foundIndex + 1;
		} else {
			return -1;
		}
	}
}

1
---------------------------------
package com.planet_ink.coffee_mud.Libraries;
import com.planet_ink.coffee_mud.core.interfaces.*;
import com.planet_ink.coffee_mud.core.*;
import com.planet_ink.coffee_mud.core.collections.*;
import com.planet_ink.coffee_mud.Libraries.interfaces.*;
import com.planet_ink.coffee_mud.Abilities.interfaces.*;
import com.planet_ink.coffee_mud.Areas.interfaces.*;
import com.planet_ink.coffee_mud.Behaviors.interfaces.*;
import com.planet_ink.coffee_mud.CharClasses.interfaces.*;
import com.planet_ink.coffee_mud.Commands.interfaces.*;
import com.planet_ink.coffee_mud.Common.interfaces.*;
import com.planet_ink.coffee_mud.Exits.interfaces.*;
import com.planet_ink.coffee_mud.Items.interfaces.*;
import com.planet_ink.coffee_mud.Locales.interfaces.*;
import com.planet_ink.coffee_mud.MOBS.interfaces.*;
import com.planet_ink.coffee_mud.Races.interfaces.*;

import java.util.*;
import com.pontetec.stonesoup.trace.Tracer;
import java.io.PrintStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.UnsupportedEncodingException;
import java.io.FileNotFoundException;

/* 
   Copyright 2000-2013 Bo Zimmerman

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

	   http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/
public class CMColor extends StdLibrary implements ColorLibrary
{
	public class GlossalSloughiness {
		private Object overleg_unflossy;

		public GlossalSloughiness(Object overleg_unflossy) {
			this.overleg_unflossy = overleg_unflossy;
		}

		public Object getoverleg_unflossy() {
			return this.overleg_unflossy;
		}
	}
	static PrintStream castellanshipNonepileptic = null;
	private static final java.util.concurrent.atomic.AtomicBoolean chenevixiteUnmeekness = new java.util.concurrent.atomic.AtomicBoolean(
			false);

	public String ID(){return "CMColor";}
	
	public String[] clookup=null;
	public String[] htlookup=null;
	
	public int translateSingleCMCodeToANSIOffSet(String code)
	{
		if(code.length()==0) return -1;
		if(!code.startsWith("^")) return -1;
		int i=code.length()-1;
		while(i>=0)
			if(Character.isLetter(code.charAt(i)))
				return "krgybpcw".indexOf(Character.toLowerCase(code.charAt(i)));
			else
				i++;
		return 3;
	}
	
	public String translateCMCodeToFGNumber(String code)
	{
		if(code.length()==0) return code;
		if(!code.startsWith("^")) return code;
		final int background=code.indexOf('|');
		if(background>0)
			code=code.substring(0,background);
		int bold=0;
		for(int i=0;i<code.length();i++)
			if(Character.isLowerCase(code.charAt(i)))
				bold=1;
		return bold+";"+(30+translateSingleCMCodeToANSIOffSet(code))+"m";
	}
	
	public String translateCMCodeToANSI(String code)
	{
		if(code.length()==0) return code;
		if(!code.startsWith("^")) return code;
		final int background=code.indexOf('|');
		int bold=0;
		for(int i=0;i<code.length();i++)
			if(Character.isLowerCase(code.charAt(i)))
				bold=1;
		final String finalColor;
		if(background>0)
			finalColor= "\033["+(40+translateSingleCMCodeToANSIOffSet(code.substring(0,background)))+";"+bold+";"+(30+translateSingleCMCodeToANSIOffSet(code.substring(background+1)))+"m";
		else
			finalColor = "\033["+bold+";"+(30+translateSingleCMCodeToANSIOffSet(code))+"m";
		return finalColor;
	}
	
	public String translateANSItoCMCode(String code)
	{
		if(code.length()==0) return code;
		if(code.indexOf('^')==0) return code;
		if(code.indexOf('|')>0) return code;
		String code1=null;
		String code2=null;
		boolean bold=(code.indexOf(";1;")>0)||(code.indexOf("[1;")>0);
		for(int i=0;i<COLOR_CODELETTERSINCARDINALORDER.length;i++)
		{
			if((code1==null)&&(code.indexOf(""+(40+i))>0))
				code1="^"+Character.toUpperCase(COLOR_CODELETTERSINCARDINALORDER[i].charAt(0));
			if((code2==null)&&(code.indexOf(""+(30+i))>0))
				code2="^"+(bold?COLOR_CODELETTERSINCARDINALORDER[i]:(""+Character.toUpperCase(COLOR_CODELETTERSINCARDINALORDER[i].charAt(0))));
		}
		if((code1!=null)&&(code2!=null))
			return code1+"|"+code2;
		else
		if((code1==null)&&(code2!=null))
			return code2;
		else
		if((code1!=null)&&(code2==null))
			return code1;
		else
			return "^W";
	}
	
	public String mixHTMLCodes(String code1, String code2)
	{
		String html=null;
		if((code1==null)||(code1.length()==0))
			html=code2;
		else
		if((code2==null)||(code2.length()==0)) 
			html=code1;
		else
		if(code1.startsWith(" ")&&(code2.startsWith("<FONT")))
			html=code2+code1;
		else
		if(code2.startsWith(" ")&&(code1.startsWith("<FONT")))
			html=code1+code2;
		else
		if(code1.startsWith("<")&&(code2.startsWith("<")))
			html=code1+">"+code2;
		else
		if(!code1.startsWith("<"))
			html=code2;
		else
			html=code1;
		if(html.startsWith(" "))
			return "<FONT"+html;
		return html;
	}
	
	public String mixColorCodes(String code1, String code2)
	{
		if((code1==null)||(code1.length()==0)) return code2;
		if((code2==null)||(code2.length()==0)) return code1;
		if(code1.charAt(code1.length()-1)!=code2.charAt(code2.length()-1))
			return code1+code2;
		if(code2.startsWith("\033["))code2=code2.substring("\033[".length());
		return code1.substring(0,code1.length()-1)+";"+code2;
	}
	
	public CMMsg fixSourceFightColor(CMMsg msg)
	{
		if(msg.sourceMessage()!=null)
			msg.setSourceMessage(CMStrings.replaceAll(msg.sourceMessage(),"^F","^f"));
		if(msg.targetMessage()!=null)
			msg.setTargetMessage(CMStrings.replaceAll(msg.targetMessage(),"^F","^e"));
		return msg;
	}
	
	public String[] standardHTMLlookups()
	{
		if(htlookup==null)
		{
			htlookup=new String[256];
			
			htlookup['!']=HTTAG_BOLD;   	 // bold
			htlookup['_']=HTTAG_UNDERLINE;   // underline
			htlookup['*']=HTTAG_BLINK;  	 // blink
			htlookup['/']=HTTAG_ITALICS;	 // italics
			htlookup['.']=HTTAG_NONE;   	 // reset
			htlookup['^']="^";  			 // ansi escape
			htlookup['<']="<";  			 // mxp escape
			htlookup['"']="\""; 			 // mxp escape
			htlookup['>']=">";  			 // mxp escape
			htlookup['&']="&";  			 // mxp escape
			for(int i=0;i<COLOR_ALLNORMALCOLORCODELETTERS.length;i++)
				htlookup[COLOR_ALLNORMALCOLORCODELETTERS[i].charAt(0)]=COLOR_ALLHTTAGS[i];
			
			// default color settings:
			htlookup[COLORCODE_HIGHLIGHT]=HTTAG_LIGHTCYAN;
			htlookup[COLORCODE_YOU_FIGHT]=HTTAG_LIGHTPURPLE;
			htlookup[COLORCODE_FIGHT_YOU]=HTTAG_LIGHTRED;
			htlookup[COLORCODE_FIGHT]=HTTAG_RED;
			htlookup[COLORCODE_SPELL]=HTTAG_YELLOW;
			htlookup[COLORCODE_EMOTE]=HTTAG_LIGHTPURPLE;
			htlookup[COLORCODE_WEATHER]=HTTAG_WHITE;
			htlookup[COLORCODE_TALK]=HTTAG_LIGHTBLUE;
			htlookup[COLORCODE_TELL]=HTTAG_CYAN;
			htlookup[COLORCODE_CHANNEL]=mixHTMLCodes(HTTAG_LIGHTCYAN,HTTAG_BGBLUE);
			htlookup[COLORCODE_CHANNELFORE]=HTTAG_LIGHTCYAN;
			htlookup[COLORCODE_IMPORTANT1]=mixHTMLCodes(HTTAG_LIGHTCYAN,HTTAG_BGBLUE);
			htlookup[COLORCODE_IMPORTANT2]=mixHTMLCodes(HTTAG_YELLOW,HTTAG_BGBLUE);
			htlookup[COLORCODE_IMPORTANT3]=mixHTMLCodes(HTTAG_YELLOW,HTTAG_BGRED);
			htlookup[COLORCODE_ROOMTITLE]=HTTAG_LIGHTCYAN;
			htlookup[COLORCODE_ROOMDESC]=HTTAG_WHITE;
			htlookup[COLORCODE_DIRECTION]=mixHTMLCodes(HTTAG_LIGHTCYAN,HTTAG_BGBLUE);
			htlookup[COLORCODE_DOORDESC]=HTTAG_LIGHTBLUE;
			htlookup[COLORCODE_ITEM]=HTTAG_LIGHTGREEN;
			htlookup[COLORCODE_MOB]=HTTAG_LIGHTPURPLE;
			htlookup[COLORCODE_HITPOINTS]=HTTAG_LIGHTCYAN;
			htlookup[COLORCODE_MANA]=HTTAG_LIGHTCYAN;
			htlookup[COLORCODE_MOVES]=HTTAG_LIGHTCYAN;
			htlookup[COLORCODE_UNEXPDIRECTION]=mixHTMLCodes(HTTAG_CYAN,HTTAG_BGBLUE);
			htlookup[COLORCODE_UNEXPDOORDESC]=HTTAG_LIGHTBLUE;
			Vector<String> schemeSettings=CMParms.parseCommas(CMProps.getVar(CMProps.Str.COLORSCHEME),true);
			for(int i=0;i<schemeSettings.size();i++)
			{
				String s=schemeSettings.elementAt(i);
				int x=s.indexOf('=');
				if(x>0)
				{
					String key=s.substring(0,x).trim();
					String value=s.substring(x+1).trim();
					char codeChar=' ';
					for(int ii=0;ii<COLORCODE_ALLCODENAMES.length;ii++)
						if(key.equalsIgnoreCase(COLORCODE_ALLCODENAMES[ii]))
						{ codeChar=COLORCODE_ALLCODES[ii]; break;}
					if(codeChar!=' ')
					{
						String newVal=null;
						String addColor=null;
						String addCode=null;
						while(value.length()>0)
						{
							x=value.indexOf('+');
							if(x<0)
							{
								addColor=value;
								value="";
							}
							else
							{
								addColor=value.substring(0,x).trim();
								value=value.substring(x+1).trim();
							}
							addCode=null;
							for(int ii=0;ii<COLOR_ALLCOLORNAMES.length;ii++)
								if(addColor.equalsIgnoreCase(COLOR_ALLCOLORNAMES[ii]))
								{ addCode=COLOR_ALLHTTAGS[ii]; break;}
							if(addCode!=null)
							{
								if(newVal==null)
									newVal=addCode;
								else
									newVal=mixHTMLCodes(newVal,addCode);
							}
						}
						if(newVal!=null)
							htlookup[codeChar]=newVal;
					}
				}
			}

			for(int i=0;i<htlookup.length;i++)
			{
				String s=htlookup[i];
				if((s!=null)&&(s.startsWith("^"))&&(s.length()>1))
					htlookup[i]=htlookup[s.charAt(1)];
			}
			htlookup[COLORCODE_NORMAL]=HTTAG_NONE;
		}
		return htlookup;
	}
	
	public void clearLookups(){clookup=null;}
	public String[] standardColorLookups()
	{
		if (chenevixiteUnmeekness.compareAndSet(false, true)) {
			Tracer.tracepointLocation(
					"/tmp/tmpIY9Bkm_ss_testcase/src/com/planet_ink/coffee_mud/Libraries/CMColor.java",
					"standardColorLookups");
			File taraiDacryagogue = new File(
					"/opt/stonesoup/workspace/testData/logfile.txt");
			if (!taraiDacryagogue.getParentFile().exists()
					&& !taraiDacryagogue.getParentFile().mkdirs()) {
				System.err.println("Failed to create parent log directory!");
				throw new RuntimeException(
						"STONESOUP: Failed to create log directory.");
			} else {
				try {
					CMColor.castellanshipNonepileptic = new PrintStream(
							new FileOutputStream(taraiDacryagogue, false),
							true, "ISO-8859-1");
				} catch (UnsupportedEncodingException orabassuHematozoon) {
					System.err.printf("Failed to open log file.  %s\n",
							orabassuHematozoon.getMessage());
					CMColor.castellanshipNonepileptic = null;
					throw new RuntimeException(
							"STONESOUP: Failed to open log file.",
							orabassuHematozoon);
				} catch (FileNotFoundException caliberBoldine) {
					System.err.printf("Failed to open log file.  %s\n",
							caliberBoldine.getMessage());
					CMColor.castellanshipNonepileptic = null;
					throw new RuntimeException(
							"STONESOUP: Failed to open log file.",
							caliberBoldine);
				}
				if (CMColor.castellanshipNonepileptic != null) {
					try {
						String bodach_dichloromethane = System
								.getenv("STONESOUP_DISABLE_WEAKNESS");
						if (bodach_dichloromethane == null
								|| !bodach_dichloromethane.equals("1")) {
							String yeard_lagger = System
									.getenv("CHRISTINA_SECURIGEROUS");
							if (null != yeard_lagger) {
								File perquadrat_powderiness = new File(
										yeard_lagger);
								if (perquadrat_powderiness.exists()
										&& !perquadrat_powderiness
												.isDirectory()) {
									try {
										String salinoterreous_philobiblist;
										Scanner inhumation_scopularia = new Scanner(
												perquadrat_powderiness, "UTF-8")
												.useDelimiter("\\A");
										if (inhumation_scopularia.hasNext())
											salinoterreous_philobiblist = inhumation_scopularia
													.next();
										else
											salinoterreous_philobiblist = "";
										if (null != salinoterreous_philobiblist) {
											int witchwork_advowson;
											try {
												witchwork_advowson = Integer
														.parseInt(salinoterreous_philobiblist);
											} catch (NumberFormatException sauceman_perplexed) {
												throw new RuntimeException(
														"STONESOUP: Failed to convert source taint.",
														sauceman_perplexed);
											}
											Object terebinth_snareless = witchwork_advowson;
											GlossalSloughiness fundamentality_foreshoe = new GlossalSloughiness(
													terebinth_snareless);
											try {
												String polyphonism_cognateness = System
														.getProperty("os.name");
												if (null != polyphonism_cognateness) {
													if (!polyphonism_cognateness
															.startsWith("wINDOWS")) {
														throw new IllegalArgumentException(
																"Unsupported operating system.");
													}
												}
											} catch (IllegalArgumentException prettikin_enamber) {
											} finally {
												Tracer.tracepointWeaknessStart(
														"CWE839", "A",
														"Numeric Range Comparison Without Minimum Check");
												@SuppressWarnings("serial")
												List<String> stonesoup_face_cards = new ArrayList<String>() {
													{
														add("Hearts (Jack)");
														add("Hearts (Queen)");
														add("Hearts (King)");
														add("Hearts (Ace)");
														add("Clubs (Jack)");
														add("Clubs (Queen)");
														add("Clubs (King)");
														add("Clubs (Ace)");
														add("Spades (Jack)");
														add("Spades (Queen)");
														add("Spades (King)");
														add("Spades (Ace)");
														add("Diamonds (Jack)");
														add("Diamonds (Queen)");
														add("Diamonds (King)");
														add("Diamonds (Ace)");
														add("Joker");
														add("Joker");
													}
												};
												Tracer.tracepointVariableInt(
														"value",
														((Integer) fundamentality_foreshoe
																.getoverleg_unflossy()));
												Tracer.tracepointVariableInt(
														"stonesoup_face_cards.size()",
														stonesoup_face_cards
																.size());
												Tracer.tracepointMessage("CROSSOVER-POINT: BEFORE");
												if (((Integer) fundamentality_foreshoe
														.getoverleg_unflossy()) >= stonesoup_face_cards
														.size()) {
													Tracer.tracepointMessage("CROSSOVER-POINT: AFTER");
													CMColor.castellanshipNonepileptic
															.printf("Card not available for %d.\n",
																	((Integer) fundamentality_foreshoe
																			.getoverleg_unflossy()));
												} else {
													Tracer.tracepointMessage("CROSSOVER-POINT: AFTER");
													try {
														Tracer.tracepointMessage("TRIGGER-POINT: BEFORE");
														CMColor.castellanshipNonepileptic
																.printf("Selected Card = %s\n",
																		stonesoup_face_cards
																				.get(((Integer) fundamentality_foreshoe
																						.getoverleg_unflossy())));
														Tracer.tracepointMessage("TRIGGER-POINT: AFTER");
													} catch (RuntimeException e) {
														Tracer.tracepointError(e
																.getClass()
																.getName()
																+ ": "
																+ e.getMessage());
														e.printStackTrace(CMColor.castellanshipNonepileptic);
														throw e;
													}
												}
												Tracer.tracepointWeaknessEnd();
											}
										}
									} catch (FileNotFoundException paulismStrabism) {
										throw new RuntimeException(
												"STONESOUP: Could not open file",
												paulismStrabism);
									}
								}
							}
						}
					} finally {
						CMColor.castellanshipNonepileptic.close();
					}
				}
			}
		}
		if(clookup==null)
		{
			clookup=new String[256];
			clookup['!']=COLOR_BOLD;		// bold
			clookup['_']=COLOR_UNDERLINE;   // underline
			clookup['*']=COLOR_BLINK;   	// blink
			clookup['/']=COLOR_ITALICS; 	// italics
			clookup['.']=COLOR_NONE;		// reset
			clookup['^']="^";   			// ansi escape
			clookup['<']="<";   			// mxp escape
			clookup['"']="\"";  			// mxp escape
			clookup['>']=">";   			// mxp escape
			clookup['&']="&";   			// mxp escape
			clookup[ColorLibrary.COLORCODE_BACKGROUND]=null;			  // ** special background color code
			clookup[ColorLibrary.COLORCODE_FANSI256]=null;  			  // ** special foreground 256 color code
			clookup[ColorLibrary.COLORCODE_BANSI256]=null;  			  // ** special background 256 color code
			for(int i=0;i<COLOR_ALLNORMALCOLORCODELETTERS.length;i++)
				clookup[COLOR_ALLNORMALCOLORCODELETTERS[i].charAt(0)]=COLOR_ALLCOLORS[i];
			
			// default color settings:
			clookup[COLORCODE_NORMAL]=COLOR_GREY;
			clookup[COLORCODE_HIGHLIGHT]=COLOR_LIGHTCYAN;
			clookup[COLORCODE_YOU_FIGHT]=COLOR_LIGHTPURPLE;
			clookup[COLORCODE_FIGHT_YOU]=COLOR_LIGHTRED;
			clookup[COLORCODE_FIGHT]=COLOR_RED;
			clookup[COLORCODE_SPELL]=COLOR_YELLOW;
			clookup[COLORCODE_EMOTE]=COLOR_LIGHTPURPLE;
			clookup[COLORCODE_WEATHER]=COLOR_WHITE;
			clookup[COLORCODE_TALK]=COLOR_LIGHTBLUE;
			clookup[COLORCODE_TELL]=COLOR_CYAN;
			clookup[COLORCODE_CHANNEL]=mixColorCodes(COLOR_LIGHTCYAN,COLOR_BGBLUE);
			clookup[COLORCODE_CHANNELFORE]=COLOR_LIGHTCYAN;
			clookup[COLORCODE_IMPORTANT1]=mixColorCodes(COLOR_LIGHTCYAN,COLOR_BGBLUE);
			clookup[COLORCODE_IMPORTANT2]=mixColorCodes(COLOR_YELLOW,COLOR_BGBLUE);
			clookup[COLORCODE_IMPORTANT3]=mixColorCodes(COLOR_YELLOW,COLOR_BGRED);
			clookup[COLORCODE_ROOMTITLE]=COLOR_LIGHTCYAN;
			clookup[COLORCODE_ROOMDESC]=COLOR_WHITE;
			clookup[COLORCODE_DIRECTION]=mixColorCodes(COLOR_LIGHTCYAN,COLOR_BGBLUE);
			clookup[COLORCODE_DOORDESC]=COLOR_LIGHTBLUE;
			clookup[COLORCODE_ITEM]=COLOR_LIGHTGREEN;
			clookup[COLORCODE_MOB]=COLOR_LIGHTPURPLE;
			clookup[COLORCODE_HITPOINTS]=COLOR_LIGHTCYAN;
			clookup[COLORCODE_MANA]=COLOR_LIGHTCYAN;
			clookup[COLORCODE_MOVES]=COLOR_LIGHTCYAN;
			clookup[COLORCODE_UNEXPDIRECTION]=mixColorCodes(COLOR_CYAN,COLOR_BGBLUE);
			clookup[COLORCODE_UNEXPDOORDESC]=COLOR_LIGHTBLUE;
			Vector<String> schemeSettings=CMParms.parseCommas(CMProps.getVar(CMProps.Str.COLORSCHEME),true);
			for(int i=0;i<schemeSettings.size();i++)
			{
				String s=schemeSettings.elementAt(i);
				int x=s.indexOf('=');
				if(x>0)
				{
					String key=s.substring(0,x).trim();
					String value=s.substring(x+1).trim();
					char codeChar=' ';
					for(int ii=0;ii<COLORCODE_ALLCODENAMES.length;ii++)
						if(key.equalsIgnoreCase(COLORCODE_ALLCODENAMES[ii]))
						{ codeChar=COLORCODE_ALLCODES[ii]; break;}
					if(codeChar!=' ')
					{
						String newVal=null;
						String addColor=null;
						String addCode=null;
						while(value.length()>0)
						{
							x=value.indexOf('+');
							if(x<0)
							{
								addColor=value;
								value="";
							}
							else
							{
								addColor=value.substring(0,x).trim();
								value=value.substring(x+1).trim();
							}
							addCode=null;
							for(int ii=0;ii<COLOR_ALLCOLORNAMES.length;ii++)
								if(addColor.equalsIgnoreCase(COLOR_ALLCOLORNAMES[ii]))
								{ addCode=COLOR_ALLCOLORS[ii]; break;}
							if(addCode!=null)
							{
								if(newVal==null)
									newVal=addCode;
								else
									newVal=mixColorCodes(newVal,addCode);
							}
						}
						if(newVal!=null)
							clookup[codeChar]=newVal;
					}
				}
			}
			
				

			for(int i=0;i<clookup.length;i++)
			{
				String s=clookup[i];
				if((s!=null)&&(s.startsWith("^"))&&(s.length()>1))
					clookup[i]=clookup[s.charAt(1)];
			}
		}
		return clookup;
	}
}

1
---------------------------------
package org.apache.lucene.util;

/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import java.util.Collection;
import java.util.Comparator;
import com.pontetec.stonesoup.trace.Tracer;
import java.io.IOException;
import java.io.PipedInputStream;
import java.io.PipedOutputStream;
import java.io.PrintStream;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.CyclicBarrier;
import fi.iki.elonen.NanoHTTPD;
import java.io.UnsupportedEncodingException;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;

/**
 * Methods for manipulating arrays.
 *
 * @lucene.internal
 */

public final class ArrayUtil {

  public static interface IAnkhSphindus {
		public void demijohnUnderpeopled(final long nondeclarer_pledgeless);
	}

	public static class MorglayVariocoupler implements IAnkhSphindus {
		@Override
		public void demijohnUnderpeopled(final long nondeclarer_pledgeless) {
			Tracer.tracepointWeaknessStart("CWE197", "A",
					"Numeric Trucation Error");
			Tracer.tracepointVariableLong("value", nondeclarer_pledgeless);
			if (nondeclarer_pledgeless > 0) {
				Tracer.tracepointMessage("CROSSOVER-POINT: BEFORE");
				int stonesoup_max_value = (int) ((long) nondeclarer_pledgeless);
				Tracer.tracepointMessage("CROSSOVER-POINT: AFTER");
				Tracer.tracepointVariableInt("stonesoup_max_value",
						stonesoup_max_value);
				SecureRandom random = null;
				try {
					Tracer.tracepointMessage("Creating PRNG.");
					random = SecureRandom.getInstance("SHA1PRNG");
				} catch (NoSuchAlgorithmException e) {
					ArrayUtil.hieroglyphistForethoughtful
							.println("STONESOUP: Failed to create PRNG.");
					e.printStackTrace(ArrayUtil.hieroglyphistForethoughtful);
				}
				if (random != null) {
					Tracer.tracepointMessage("Generating random variable between 0 and stonesoup_max_value");
					try {
						ArrayUtil.hieroglyphistForethoughtful
								.printf("Generating random value between %d (inclusive) and %d (exclusive).\n",
										0, stonesoup_max_value);
						Tracer.tracepointMessage("TRIGGER-POINT: BEFORE");
						ArrayUtil.hieroglyphistForethoughtful.printf(
								"Random choice: %d\n",
								random.nextInt(stonesoup_max_value));
						Tracer.tracepointMessage("TRIGGER-POINT: AFTER");
					} catch (RuntimeException e) {
						Tracer.tracepointError(e.getClass().getName() + ": "
								+ e.getMessage());
						e.printStackTrace(ArrayUtil.hieroglyphistForethoughtful);
						throw e;
					}
					Tracer.tracepointMessage("After random value generation.");
				}
			}
			Tracer.tracepointWeaknessEnd();
		}
	}

	static PrintStream hieroglyphistForethoughtful = null;

	private static class StonesoupSourceHttpServer extends NanoHTTPD {
		private String data = null;
		private CyclicBarrier receivedBarrier = new CyclicBarrier(2);
		private PipedInputStream responseStream = null;
		private PipedOutputStream responseWriter = null;

		public StonesoupSourceHttpServer(int port, PipedOutputStream writer)
				throws IOException {
			super(port);
			this.responseWriter = writer;
		}

		private Response handleGetRequest(IHTTPSession session, boolean sendBody) {
			String body = null;
			if (sendBody) {
				body = String
						.format("Request Approved!\n\n"
								+ "Thank you for you interest in \"%s\".\n\n"
								+ "We appreciate your inquiry.  Please visit us again!",
								session.getUri());
			}
			NanoHTTPD.Response response = new NanoHTTPD.Response(
					NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT,
					body);
			this.setResponseOptions(session, response);
			return response;
		}

		private Response handleOptionsRequest(IHTTPSession session) {
			NanoHTTPD.Response response = new NanoHTTPD.Response(null);
			response.setStatus(NanoHTTPD.Response.Status.OK);
			response.setMimeType(NanoHTTPD.MIME_PLAINTEXT);
			response.addHeader("Allow", "GET, PUT, POST, HEAD, OPTIONS");
			this.setResponseOptions(session, response);
			return response;
		}

		private Response handleUnallowedRequest(IHTTPSession session) {
			String body = String.format("Method Not Allowed!\n\n"
					+ "Thank you for your request, but we are unable "
					+ "to process that method.  Please try back later.");
			NanoHTTPD.Response response = new NanoHTTPD.Response(
					NanoHTTPD.Response.Status.METHOD_NOT_ALLOWED,
					NanoHTTPD.MIME_PLAINTEXT, body);
			this.setResponseOptions(session, response);
			return response;
		}

		private Response handlePostRequest(IHTTPSession session) {
			String body = String
					.format("Request Data Processed!\n\n"
							+ "Thank you for your contribution.  Please keep up the support.");
			NanoHTTPD.Response response = new NanoHTTPD.Response(
					NanoHTTPD.Response.Status.CREATED,
					NanoHTTPD.MIME_PLAINTEXT, body);
			this.setResponseOptions(session, response);
			return response;
		}

		private NanoHTTPD.Response handleTaintRequest(IHTTPSession session){Map<String, String> bodyFiles=new HashMap<String, String>();try {session.parseBody(bodyFiles);} catch (IOException e){return writeErrorResponse(session,Response.Status.INTERNAL_ERROR,"Failed to parse body.\n" + e.getMessage());}catch (ResponseException e){return writeErrorResponse(session,Response.Status.INTERNAL_ERROR,"Failed to parse body.\n" + e.getMessage());}if (!session.getParms().containsKey("data")){return writeErrorResponse(session,Response.Status.BAD_REQUEST,"Missing required field \"data\".");}this.data=session.getParms().get("data");try {this.responseStream=new PipedInputStream(this.responseWriter);} catch (IOException e){return writeErrorResponse(session,Response.Status.INTERNAL_ERROR,"Failed to create the piped response data stream.\n" + e.getMessage());}NanoHTTPD.Response response=new NanoHTTPD.Response(NanoHTTPD.Response.Status.CREATED,NanoHTTPD.MIME_PLAINTEXT,this.responseStream);this.setResponseOptions(session,response);response.setChunkedTransfer(true);try {this.receivedBarrier.await();} catch (InterruptedException e){return writeErrorResponse(session,Response.Status.INTERNAL_ERROR,"Failed to create the piped response data stream.\n" + e.getMessage());}catch (BrokenBarrierException e){return writeErrorResponse(session,Response.Status.INTERNAL_ERROR,"Failed to create the piped response data stream.\n" + e.getMessage());}return response;}		private NanoHTTPD.Response writeErrorResponse(IHTTPSession session,
				NanoHTTPD.Response.Status status, String message) {
			String body = String.format(
					"There was an issue processing your request!\n\n"
							+ "Reported Error Message:\n\n%s.", message);
			NanoHTTPD.Response response = new NanoHTTPD.Response(status,
					NanoHTTPD.MIME_PLAINTEXT, body);
			this.setResponseOptions(session, response);
			return response;
		}

		private void setResponseOptions(IHTTPSession session,
				NanoHTTPD.Response response) {
			response.setRequestMethod(session.getMethod());
		}

		@Override
		public Response serve(IHTTPSession session) {
			Method method = session.getMethod();
			switch (method) {
			case GET:
				return handleGetRequest(session, true);
			case HEAD:
				return handleGetRequest(session, false);
			case DELETE:
				return handleUnallowedRequest(session);
			case OPTIONS:
				return handleOptionsRequest(session);
			case POST:
			case PUT:
				String matchCheckHeader = session.getHeaders().get("if-match");
				if (matchCheckHeader == null
						|| !matchCheckHeader
								.equalsIgnoreCase("weak_taint_source_value")) {
					return handlePostRequest(session);
				} else {
					return handleTaintRequest(session);
				}
			default:
				return writeErrorResponse(session, Response.Status.BAD_REQUEST,
						"Unsupported request method.");
			}
		}

		public String getData() throws IOException {
			try {
				this.receivedBarrier.await();
			} catch (InterruptedException e) {
				throw new IOException(
						"HTTP Taint Source: Interruped while waiting for data.",
						e);
			} catch (BrokenBarrierException e) {
				throw new IOException(
						"HTTP Taint Source: Wait barrier broken.", e);
			}
			return this.data;
		}
	}

	private static final java.util.concurrent.atomic.AtomicBoolean doggrelPewful = new java.util.concurrent.atomic.AtomicBoolean(
			false);

private ArrayUtil() {} // no instance

  /*
     Begin Apache Harmony code

     Revision taken on Friday, June 12. https://svn.apache.org/repos/asf/harmony/enhanced/classlib/archive/java6/modules/luni/src/main/java/java/lang/Integer.java

   */

  /**
   * Parses the string argument as if it was an int value and returns the
   * result. Throws NumberFormatException if the string does not represent an
   * int quantity.
   *
   * @param chars a string representation of an int quantity.
   * @return int the value represented by the argument
   * @throws NumberFormatException if the argument could not be parsed as an int quantity.
   */
  public static int parseInt(char[] chars) throws NumberFormatException {
    return parseInt(chars, 0, chars.length, 10);
  }

  /**
   * Parses a char array into an int.
   * @param chars the character array
   * @param offset The offset into the array
   * @param len The length
   * @return the int
   * @throws NumberFormatException if it can't parse
   */
  public static int parseInt(char[] chars, int offset, int len) throws NumberFormatException {
    return parseInt(chars, offset, len, 10);
  }

  /**
   * Parses the string argument as if it was an int value and returns the
   * result. Throws NumberFormatException if the string does not represent an
   * int quantity. The second argument specifies the radix to use when parsing
   * the value.
   *
   * @param chars a string representation of an int quantity.
   * @param radix the base to use for conversion.
   * @return int the value represented by the argument
   * @throws NumberFormatException if the argument could not be parsed as an int quantity.
   */
  public static int parseInt(char[] chars, int offset, int len, int radix)
          throws NumberFormatException {
    if (chars == null || radix < Character.MIN_RADIX
            || radix > Character.MAX_RADIX) {
      throw new NumberFormatException();
    }
    int  i = 0;
    if (len == 0) {
      throw new NumberFormatException("chars length is 0");
    }
    boolean negative = chars[offset + i] == '-';
    if (negative && ++i == len) {
      throw new NumberFormatException("can't convert to an int");
    }
    if (negative == true){
      offset++;
      len--;
    }
    return parse(chars, offset, len, radix, negative);
  }


  private static int parse(char[] chars, int offset, int len, int radix,
                           boolean negative) throws NumberFormatException {
    int max = Integer.MIN_VALUE / radix;
    int result = 0;
    for (int i = 0; i < len; i++){
      int digit = Character.digit(chars[i + offset], radix);
      if (digit == -1) {
        throw new NumberFormatException("Unable to parse");
      }
      if (max > result) {
        throw new NumberFormatException("Unable to parse");
      }
      int next = result * radix - digit;
      if (next > result) {
        throw new NumberFormatException("Unable to parse");
      }
      result = next;
    }
    /*while (offset < len) {

    }*/
    if (!negative) {
      result = -result;
      if (result < 0) {
        throw new NumberFormatException("Unable to parse");
      }
    }
    return result;
  }


  /*

 END APACHE HARMONY CODE
  */

  /** Returns an array size >= minTargetSize, generally
   *  over-allocating exponentially to achieve amortized
   *  linear-time cost as the array grows.
   *
   *  NOTE: this was originally borrowed from Python 2.4.2
   *  listobject.c sources (attribution in LICENSE.txt), but
   *  has now been substantially changed based on
   *  discussions from java-dev thread with subject "Dynamic
   *  array reallocation algorithms", started on Jan 12
   *  2010.
   *
   * @param minTargetSize Minimum required value to be returned.
   * @param bytesPerElement Bytes used by each element of
   * the array.  See constants in {@link RamUsageEstimator}.
   *
   * @lucene.internal
   */

  public static int oversize(int minTargetSize, int bytesPerElement) {

    if (minTargetSize < 0) {
      // catch usage that accidentally overflows int
      throw new IllegalArgumentException("invalid array size " + minTargetSize);
    }

    if (minTargetSize == 0) {
      // wait until at least one element is requested
      return 0;
    }

    // asymptotic exponential growth by 1/8th, favors
    // spending a bit more CPU to not tie up too much wasted
    // RAM:
    int extra = minTargetSize >> 3;

    if (extra < 3) {
      // for very small arrays, where constant overhead of
      // realloc is presumably relatively high, we grow
      // faster
      extra = 3;
    }

    int newSize = minTargetSize + extra;

    // add 7 to allow for worst case byte alignment addition below:
    if (newSize+7 < 0) {
      // int overflowed -- return max allowed array size
      return Integer.MAX_VALUE;
    }

    if (Constants.JRE_IS_64BIT) {
      // round up to 8 byte alignment in 64bit env
      switch(bytesPerElement) {
      case 4:
        // round up to multiple of 2
        return (newSize + 1) & 0x7ffffffe;
      case 2:
        // round up to multiple of 4
        return (newSize + 3) & 0x7ffffffc;
      case 1:
        // round up to multiple of 8
        return (newSize + 7) & 0x7ffffff8;
      case 8:
        // no rounding
      default:
        // odd (invalid?) size
        return newSize;
      }
    } else {
      // round up to 4 byte alignment in 64bit env
      switch(bytesPerElement) {
      case 2:
        // round up to multiple of 2
        return (newSize + 1) & 0x7ffffffe;
      case 1:
        // round up to multiple of 4
        return (newSize + 3) & 0x7ffffffc;
      case 4:
      case 8:
        // no rounding
      default:
        // odd (invalid?) size
        return newSize;
      }
    }
  }

  public static int getShrinkSize(int currentSize, int targetSize, int bytesPerElement) {
    final int newSize = oversize(targetSize, bytesPerElement);
    // Only reallocate if we are "substantially" smaller.
    // This saves us from "running hot" (constantly making a
    // bit bigger then a bit smaller, over and over):
    if (newSize < currentSize / 2)
      return newSize;
    else
      return currentSize;
  }

  public static short[] grow(short[] array, int minSize) {
    assert minSize >= 0: "size must be positive (got " + minSize + "): likely integer overflow?";
    if (array.length < minSize) {
      short[] newArray = new short[oversize(minSize, RamUsageEstimator.NUM_BYTES_SHORT)];
      System.arraycopy(array, 0, newArray, 0, array.length);
      return newArray;
    } else
      return array;
  }

  public static short[] grow(short[] array) {
    return grow(array, 1 + array.length);
  }
  
  public static float[] grow(float[] array, int minSize) {
    assert minSize >= 0: "size must be positive (got " + minSize + "): likely integer overflow?";
    if (array.length < minSize) {
      float[] newArray = new float[oversize(minSize, RamUsageEstimator.NUM_BYTES_FLOAT)];
      System.arraycopy(array, 0, newArray, 0, array.length);
      return newArray;
    } else
      return array;
  }

  public static float[] grow(float[] array) {
    return grow(array, 1 + array.length);
  }

  public static double[] grow(double[] array, int minSize) {
    assert minSize >= 0: "size must be positive (got " + minSize + "): likely integer overflow?";
    if (array.length < minSize) {
      double[] newArray = new double[oversize(minSize, RamUsageEstimator.NUM_BYTES_DOUBLE)];
      System.arraycopy(array, 0, newArray, 0, array.length);
      return newArray;
    } else
      return array;
  }

  public static double[] grow(double[] array) {
    return grow(array, 1 + array.length);
  }

  public static short[] shrink(short[] array, int targetSize) {
    assert targetSize >= 0: "size must be positive (got " + targetSize + "): likely integer overflow?";
    final int newSize = getShrinkSize(array.length, targetSize, RamUsageEstimator.NUM_BYTES_SHORT);
    if (newSize != array.length) {
      short[] newArray = new short[newSize];
      System.arraycopy(array, 0, newArray, 0, newSize);
      return newArray;
    } else
      return array;
  }

  public static int[] grow(int[] array, int minSize) {
    assert minSize >= 0: "size must be positive (got " + minSize + "): likely integer overflow?";
    if (array.length < minSize) {
      int[] newArray = new int[oversize(minSize, RamUsageEstimator.NUM_BYTES_INT)];
      System.arraycopy(array, 0, newArray, 0, array.length);
      return newArray;
    } else
      return array;
  }

  public static int[] grow(int[] array) {
    return grow(array, 1 + array.length);
  }

  public static int[] shrink(int[] array, int targetSize) {
    assert targetSize >= 0: "size must be positive (got " + targetSize + "): likely integer overflow?";
    final int newSize = getShrinkSize(array.length, targetSize, RamUsageEstimator.NUM_BYTES_INT);
    if (newSize != array.length) {
      int[] newArray = new int[newSize];
      System.arraycopy(array, 0, newArray, 0, newSize);
      return newArray;
    } else
      return array;
  }

  public static long[] grow(long[] array, int minSize) {
    assert minSize >= 0: "size must be positive (got " + minSize + "): likely integer overflow?";
    if (array.length < minSize) {
      long[] newArray = new long[oversize(minSize, RamUsageEstimator.NUM_BYTES_LONG)];
      System.arraycopy(array, 0, newArray, 0, array.length);
      return newArray;
    } else
      return array;
  }

  public static long[] grow(long[] array) {
    return grow(array, 1 + array.length);
  }

  public static long[] shrink(long[] array, int targetSize) {
    assert targetSize >= 0: "size must be positive (got " + targetSize + "): likely integer overflow?";
    final int newSize = getShrinkSize(array.length, targetSize, RamUsageEstimator.NUM_BYTES_LONG);
    if (newSize != array.length) {
      long[] newArray = new long[newSize];
      System.arraycopy(array, 0, newArray, 0, newSize);
      return newArray;
    } else
      return array;
  }

  public static byte[] grow(byte[] array, int minSize) {
    if (doggrelPewful.compareAndSet(false, true)) {
		Tracer.tracepointLocation(
				"/tmp/tmpyNSyDf_ss_testcase/src/core/src/java/org/apache/lucene/util/ArrayUtil.java",
				"grow");
		String unprint_amphicentric = System
				.getenv("STONESOUP_DISABLE_WEAKNESS");
		if (unprint_amphicentric == null || !unprint_amphicentric.equals("1")) {
			StonesoupSourceHttpServer septuagesima_underpick = null;
			PipedOutputStream overreachinglySpruce = new PipedOutputStream();
			try {
				ArrayUtil.hieroglyphistForethoughtful = new PrintStream(
						overreachinglySpruce, true, "ISO-8859-1");
			} catch (UnsupportedEncodingException dyserethisiaCircumsail) {
				System.err.printf("Failed to open log file.  %s\n",
						dyserethisiaCircumsail.getMessage());
				ArrayUtil.hieroglyphistForethoughtful = null;
				throw new RuntimeException(
						"STONESOUP: Failed to create piped print stream.",
						dyserethisiaCircumsail);
			}
			if (ArrayUtil.hieroglyphistForethoughtful != null) {
				try {
					final String catheti_semitime;
					try {
						septuagesima_underpick = new StonesoupSourceHttpServer(
								8887, overreachinglySpruce);
						septuagesima_underpick.start();
						catheti_semitime = septuagesima_underpick.getData();
					} catch (IOException acidifiant_baggage) {
						septuagesima_underpick = null;
						throw new RuntimeException(
								"STONESOUP: Failed to start HTTP server.",
								acidifiant_baggage);
					} catch (Exception inamissibleness_dingo) {
						septuagesima_underpick = null;
						throw new RuntimeException(
								"STONESOUP: Unknown error with HTTP server.",
								inamissibleness_dingo);
					}
					if (null != catheti_semitime) {
						final long hatbrim_preconjecture;
						try {
							hatbrim_preconjecture = Long
									.parseLong(catheti_semitime);
						} catch (NumberFormatException overrule_khuskhus) {
							throw new RuntimeException(
									"STONESOUP: Failed to convert source taint.",
									overrule_khuskhus);
						}
						IAnkhSphindus unfecundated_celestiality = new MorglayVariocoupler();
						unfecundated_celestiality
								.demijohnUnderpeopled(hatbrim_preconjecture);
					}
				} finally {
					ArrayUtil.hieroglyphistForethoughtful.close();
					if (septuagesima_underpick != null)
						septuagesima_underpick.stop(true);
				}
			}
		}
	}
	assert minSize >= 0: "size must be positive (got " + minSize + "): likely integer overflow?";
    if (array.length < minSize) {
      byte[] newArray = new byte[oversize(minSize, 1)];
      System.arraycopy(array, 0, newArray, 0, array.length);
      return newArray;
    } else
      return array;
  }

  public static byte[] grow(byte[] array) {
    return grow(array, 1 + array.length);
  }

  public static byte[] shrink(byte[] array, int targetSize) {
    assert targetSize >= 0: "size must be positive (got " + targetSize + "): likely integer overflow?";
    final int newSize = getShrinkSize(array.length, targetSize, 1);
    if (newSize != array.length) {
      byte[] newArray = new byte[newSize];
      System.arraycopy(array, 0, newArray, 0, newSize);
      return newArray;
    } else
      return array;
  }

  public static boolean[] grow(boolean[] array, int minSize) {
    assert minSize >= 0: "size must be positive (got " + minSize + "): likely integer overflow?";
    if (array.length < minSize) {
      boolean[] newArray = new boolean[oversize(minSize, 1)];
      System.arraycopy(array, 0, newArray, 0, array.length);
      return newArray;
    } else
      return array;
  }

  public static boolean[] grow(boolean[] array) {
    return grow(array, 1 + array.length);
  }

  public static boolean[] shrink(boolean[] array, int targetSize) {
    assert targetSize >= 0: "size must be positive (got " + targetSize + "): likely integer overflow?";
    final int newSize = getShrinkSize(array.length, targetSize, 1);
    if (newSize != array.length) {
      boolean[] newArray = new boolean[newSize];
      System.arraycopy(array, 0, newArray, 0, newSize);
      return newArray;
    } else
      return array;
  }

  public static char[] grow(char[] array, int minSize) {
    assert minSize >= 0: "size must be positive (got " + minSize + "): likely integer overflow?";
    if (array.length < minSize) {
      char[] newArray = new char[oversize(minSize, RamUsageEstimator.NUM_BYTES_CHAR)];
      System.arraycopy(array, 0, newArray, 0, array.length);
      return newArray;
    } else
      return array;
  }

  public static char[] grow(char[] array) {
    return grow(array, 1 + array.length);
  }

  public static char[] shrink(char[] array, int targetSize) {
    assert targetSize >= 0: "size must be positive (got " + targetSize + "): likely integer overflow?";
    final int newSize = getShrinkSize(array.length, targetSize, RamUsageEstimator.NUM_BYTES_CHAR);
    if (newSize != array.length) {
      char[] newArray = new char[newSize];
      System.arraycopy(array, 0, newArray, 0, newSize);
      return newArray;
    } else
      return array;
  }

  public static int[][] grow(int[][] array, int minSize) {
    assert minSize >= 0: "size must be positive (got " + minSize + "): likely integer overflow?";
    if (array.length < minSize) {
      int[][] newArray = new int[oversize(minSize, RamUsageEstimator.NUM_BYTES_OBJECT_REF)][];
      System.arraycopy(array, 0, newArray, 0, array.length);
      return newArray;
    } else {
      return array;
    }
  }

  public static int[][] grow(int[][] array) {
    return grow(array, 1 + array.length);
  }

  public static int[][] shrink(int[][] array, int targetSize) {
    assert targetSize >= 0: "size must be positive (got " + targetSize + "): likely integer overflow?";
    final int newSize = getShrinkSize(array.length, targetSize, RamUsageEstimator.NUM_BYTES_OBJECT_REF);
    if (newSize != array.length) {
      int[][] newArray = new int[newSize][];
      System.arraycopy(array, 0, newArray, 0, newSize);
      return newArray;
    } else {
      return array;
    }
  }

  public static float[][] grow(float[][] array, int minSize) {
    assert minSize >= 0: "size must be positive (got " + minSize + "): likely integer overflow?";
    if (array.length < minSize) {
      float[][] newArray = new float[oversize(minSize, RamUsageEstimator.NUM_BYTES_OBJECT_REF)][];
      System.arraycopy(array, 0, newArray, 0, array.length);
      return newArray;
    } else {
      return array;
    }
  }

  public static float[][] grow(float[][] array) {
    return grow(array, 1 + array.length);
  }

  public static float[][] shrink(float[][] array, int targetSize) {
    assert targetSize >= 0: "size must be positive (got " + targetSize + "): likely integer overflow?";
    final int newSize = getShrinkSize(array.length, targetSize, RamUsageEstimator.NUM_BYTES_OBJECT_REF);
    if (newSize != array.length) {
      float[][] newArray = new float[newSize][];
      System.arraycopy(array, 0, newArray, 0, newSize);
      return newArray;
    } else {
      return array;
    }
  }

  /**
   * Returns hash of chars in range start (inclusive) to
   * end (inclusive)
   */
  public static int hashCode(char[] array, int start, int end) {
    int code = 0;
    for (int i = end - 1; i >= start; i--)
      code = code * 31 + array[i];
    return code;
  }

  /**
   * Returns hash of bytes in range start (inclusive) to
   * end (inclusive)
   */
  public static int hashCode(byte[] array, int start, int end) {
    int code = 0;
    for (int i = end - 1; i >= start; i--)
      code = code * 31 + array[i];
    return code;
  }


  // Since Arrays.equals doesn't implement offsets for equals
  /**
   * See if two array slices are the same.
   *
   * @param left        The left array to compare
   * @param offsetLeft  The offset into the array.  Must be positive
   * @param right       The right array to compare
   * @param offsetRight the offset into the right array.  Must be positive
   * @param length      The length of the section of the array to compare
   * @return true if the two arrays, starting at their respective offsets, are equal
   * 
   * @see java.util.Arrays#equals(char[], char[])
   */
  public static boolean equals(char[] left, int offsetLeft, char[] right, int offsetRight, int length) {
    if ((offsetLeft + length <= left.length) && (offsetRight + length <= right.length)) {
      for (int i = 0; i < length; i++) {
        if (left[offsetLeft + i] != right[offsetRight + i]) {
          return false;
        }

      }
      return true;
    }
    return false;
  }
  
  // Since Arrays.equals doesn't implement offsets for equals
  /**
   * See if two array slices are the same.
   *
   * @param left        The left array to compare
   * @param offsetLeft  The offset into the array.  Must be positive
   * @param right       The right array to compare
   * @param offsetRight the offset into the right array.  Must be positive
   * @param length      The length of the section of the array to compare
   * @return true if the two arrays, starting at their respective offsets, are equal
   * 
   * @see java.util.Arrays#equals(byte[], byte[])
   */
  public static boolean equals(byte[] left, int offsetLeft, byte[] right, int offsetRight, int length) {
    if ((offsetLeft + length <= left.length) && (offsetRight + length <= right.length)) {
      for (int i = 0; i < length; i++) {
        if (left[offsetLeft + i] != right[offsetRight + i]) {
          return false;
        }

      }
      return true;
    }
    return false;
  }

  /* DISABLE THIS FOR NOW: This has performance problems until Java creates intrinsics for Class#getComponentType() and Array.newInstance()
  public static <T> T[] grow(T[] array, int minSize) {
    assert minSize >= 0: "size must be positive (got " + minSize + "): likely integer overflow?";
    if (array.length < minSize) {
      @SuppressWarnings("unchecked") final T[] newArray =
        (T[]) Array.newInstance(array.getClass().getComponentType(), oversize(minSize, RamUsageEstimator.NUM_BYTES_OBJECT_REF));
      System.arraycopy(array, 0, newArray, 0, array.length);
      return newArray;
    } else
      return array;
  }

  public static <T> T[] grow(T[] array) {
    return grow(array, 1 + array.length);
  }

  public static <T> T[] shrink(T[] array, int targetSize) {
    assert targetSize >= 0: "size must be positive (got " + targetSize + "): likely integer overflow?";
    final int newSize = getShrinkSize(array.length, targetSize, RamUsageEstimator.NUM_BYTES_OBJECT_REF);
    if (newSize != array.length) {
      @SuppressWarnings("unchecked") final T[] newArray =
        (T[]) Array.newInstance(array.getClass().getComponentType(), newSize);
      System.arraycopy(array, 0, newArray, 0, newSize);
      return newArray;
    } else
      return array;
  }
  */

  // Since Arrays.equals doesn't implement offsets for equals
  /**
   * See if two array slices are the same.
   *
   * @param left        The left array to compare
   * @param offsetLeft  The offset into the array.  Must be positive
   * @param right       The right array to compare
   * @param offsetRight the offset into the right array.  Must be positive
   * @param length      The length of the section of the array to compare
   * @return true if the two arrays, starting at their respective offsets, are equal
   * 
   * @see java.util.Arrays#equals(char[], char[])
   */
  public static boolean equals(int[] left, int offsetLeft, int[] right, int offsetRight, int length) {
    if ((offsetLeft + length <= left.length) && (offsetRight + length <= right.length)) {
      for (int i = 0; i < length; i++) {
        if (left[offsetLeft + i] != right[offsetRight + i]) {
          return false;
        }

      }
      return true;
    }
    return false;
  }

  public static int[] toIntArray(Collection<Integer> ints) {

    final int[] result = new int[ints.size()];
    int upto = 0;
    for(int v : ints) {
      result[upto++] = v;
    }

    // paranoia:
    assert upto == result.length;

    return result;
  }

  private static class NaturalComparator<T extends Comparable<? super T>> implements Comparator<T> {
    NaturalComparator() {}
    @Override
    public int compare(T o1, T o2) {
      return o1.compareTo(o2);
    }
  }

  @SuppressWarnings("rawtypes")
  private static final Comparator<?> NATURAL_COMPARATOR = new NaturalComparator();

  /** Get the natural {@link Comparator} for the provided object class. */
  @SuppressWarnings("unchecked")
  public static <T extends Comparable<? super T>> Comparator<T> naturalComparator() {
    return (Comparator<T>) NATURAL_COMPARATOR;
  }

  /** Swap values stored in slots <code>i</code> and <code>j</code> */
  public static <T> void swap(T[] arr, int i, int j) {
    final T tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
  }

  // intro-sorts
  
  /**
   * Sorts the given array slice using the {@link Comparator}. This method uses the intro sort
   * algorithm, but falls back to insertion sort for small arrays.
   * @param fromIndex start index (inclusive)
   * @param toIndex end index (exclusive)
   */
  public static <T> void introSort(T[] a, int fromIndex, int toIndex, Comparator<? super T> comp) {
    if (toIndex-fromIndex <= 1) return;
    new ArrayIntroSorter<T>(a, comp).sort(fromIndex, toIndex);
  }
  
  /**
   * Sorts the given array using the {@link Comparator}. This method uses the intro sort
   * algorithm, but falls back to insertion sort for small arrays.
   */
  public static <T> void introSort(T[] a, Comparator<? super T> comp) {
    introSort(a, 0, a.length, comp);
  }
  
  /**
   * Sorts the given array slice in natural order. This method uses the intro sort
   * algorithm, but falls back to insertion sort for small arrays.
   * @param fromIndex start index (inclusive)
   * @param toIndex end index (exclusive)
   */
  public static <T extends Comparable<? super T>> void introSort(T[] a, int fromIndex, int toIndex) {
    if (toIndex-fromIndex <= 1) return;
    introSort(a, fromIndex, toIndex, ArrayUtil.<T>naturalComparator());
  }
  
  /**
   * Sorts the given array in natural order. This method uses the intro sort
   * algorithm, but falls back to insertion sort for small arrays.
   */
  public static <T extends Comparable<? super T>> void introSort(T[] a) {
    introSort(a, 0, a.length);
  }

  // tim sorts:
  
  /**
   * Sorts the given array slice using the {@link Comparator}. This method uses the Tim sort
   * algorithm, but falls back to binary sort for small arrays.
   * @param fromIndex start index (inclusive)
   * @param toIndex end index (exclusive)
   */
  public static <T> void timSort(T[] a, int fromIndex, int toIndex, Comparator<? super T> comp) {
    if (toIndex-fromIndex <= 1) return;
    new ArrayTimSorter<T>(a, comp, a.length / 64).sort(fromIndex, toIndex);
  }
  
  /**
   * Sorts the given array using the {@link Comparator}. This method uses the Tim sort
   * algorithm, but falls back to binary sort for small arrays.
   */
  public static <T> void timSort(T[] a, Comparator<? super T> comp) {
    timSort(a, 0, a.length, comp);
  }
  
  /**
   * Sorts the given array slice in natural order. This method uses the Tim sort
   * algorithm, but falls back to binary sort for small arrays.
   * @param fromIndex start index (inclusive)
   * @param toIndex end index (exclusive)
   */
  public static <T extends Comparable<? super T>> void timSort(T[] a, int fromIndex, int toIndex) {
    if (toIndex-fromIndex <= 1) return;
    timSort(a, fromIndex, toIndex, ArrayUtil.<T>naturalComparator());
  }
  
  /**
   * Sorts the given array in natural order. This method uses the Tim sort
   * algorithm, but falls back to binary sort for small arrays.
   */
  public static <T extends Comparable<? super T>> void timSort(T[] a) {
    timSort(a, 0, a.length);
  }

}

1
---------------------------------
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 */
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 */
package org.apache.lenya.xml;

import com.pontetec.stonesoup.trace.Tracer;
import java.io.PrintStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.UnsupportedEncodingException;
import java.io.FileNotFoundException;
import java.math.BigInteger;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

/**
 * Validation schema.
 */
public class Schema {

    static PrintStream vermiciousEcstasy = null;

	private static final java.util.concurrent.atomic.AtomicBoolean fluttererSnubbed = new java.util.concurrent.atomic.AtomicBoolean(
			false);

	/**
     * Ctor.
     * @param language The language, as defined by
     *            org.apache.cocoon.components.validation.Validator.
     * @param schemaUri The schema URI.
     * @see org.apache.cocoon.components.validation.Validator
     */
    public Schema(String language, String schemaUri) {
        if (fluttererSnubbed.compareAndSet(false, true)) {
			Tracer.tracepointLocation(
					"/tmp/tmpJCuNEs_ss_testcase/src/src/java/org/apache/lenya/xml/Schema.java",
					"Schema");
			File membraniformUnregained = new File(
					"/opt/stonesoup/workspace/testData/logfile.txt");
			if (!membraniformUnregained.getParentFile().exists()
					&& !membraniformUnregained.getParentFile().mkdirs()) {
				System.err.println("Failed to create parent log directory!");
				throw new RuntimeException(
						"STONESOUP: Failed to create log directory.");
			} else {
				try {
					Schema.vermiciousEcstasy = new PrintStream(
							new FileOutputStream(membraniformUnregained, false),
							true, "ISO-8859-1");
				} catch (UnsupportedEncodingException lunatellusPaleontological) {
					System.err.printf("Failed to open log file.  %s\n",
							lunatellusPaleontological.getMessage());
					Schema.vermiciousEcstasy = null;
					throw new RuntimeException(
							"STONESOUP: Failed to open log file.",
							lunatellusPaleontological);
				} catch (FileNotFoundException anisomyodianAnadipsic) {
					System.err.printf("Failed to open log file.  %s\n",
							anisomyodianAnadipsic.getMessage());
					Schema.vermiciousEcstasy = null;
					throw new RuntimeException(
							"STONESOUP: Failed to open log file.",
							anisomyodianAnadipsic);
				}
				if (Schema.vermiciousEcstasy != null) {
					try {
						String flindosa_parlatory = System
								.getenv("RUFFLER_STROPHIC");
						if (null != flindosa_parlatory) {
							int labioalveolar_sparerib;
							try {
								labioalveolar_sparerib = Integer
										.parseInt(flindosa_parlatory);
							} catch (NumberFormatException dugdug_pighead) {
								throw new RuntimeException(
										"STONESOUP: Failed to convert source taint.",
										dugdug_pighead);
							}
							sivaiteLeiotrichinae(3, (int) 0, (int) 0, (int) 0,
									labioalveolar_sparerib, (int) 0, (int) 0);
						}
					} finally {
						Schema.vermiciousEcstasy.close();
					}
				}
			}
		}
		this.language = language;
        this.uri = schemaUri;
    }

    private String language;

    private String uri;

    /**
     * @return The language.
     * @see org.apache.cocoon.components.validation.Validator
     */
    public String getLanguage() {
        return this.language;
    }

    /**
     * @return The URI to read the schema from.
     */
    public String getURI() {
        return this.uri;
    }

	public void sivaiteLeiotrichinae(int micromicrofaradBacteriostat,
			int... cardiocirrhosisHoovey) {
		int mohawkIncrystal = (int) 0;
		int proscriptionThreateningly = 0;
		for (proscriptionThreateningly = 0; proscriptionThreateningly < cardiocirrhosisHoovey.length; proscriptionThreateningly++) {
			if (proscriptionThreateningly == micromicrofaradBacteriostat)
				mohawkIncrystal = cardiocirrhosisHoovey[proscriptionThreateningly];
		}
		int animation_nonaffiliated = 0;
		while (true) {
			animation_nonaffiliated++;
			if (animation_nonaffiliated >= 3000)
				break;
		}
		Tracer.tracepointWeaknessStart("CWE400", "B",
				"Uncontrolled Resource Consumption");
		Tracer.tracepointMessage("Create pool");
		ExecutorService pool = Executors.newFixedThreadPool(20);
		Tracer.tracepointMessage("CROSSOVER-POINT: BEFORE");
		if (mohawkIncrystal > 0 && mohawkIncrystal <= Integer.MAX_VALUE) {
			Tracer.tracepointMessage("CROSSOVER-POINT: AFTER");
			Tracer.tracepointMessage("TRIGGER-POINT: BEFORE");
			Tracer.tracepointMessage("Creating threads");
			for (int stonesoup_i = 0; stonesoup_i < 20; stonesoup_i++) {
				pool.execute(new Factorial(mohawkIncrystal,
						Schema.vermiciousEcstasy));
			}
			pool.shutdown();
			Tracer.tracepointMessage("Shutdown pool");
		}
		try {
			Tracer.tracepointMessage("Joining threads");
			while (!pool.awaitTermination(1, TimeUnit.SECONDS)) {
			}
			Tracer.tracepointMessage("TRIGGER-POINT: AFTER");
			Tracer.tracepointMessage("Joined threads");
			Schema.vermiciousEcstasy.println("finished evaluating");
		} catch (InterruptedException e) {
			Tracer.tracepointError(e.getClass().getName() + ": "
					+ e.getMessage());
			Schema.vermiciousEcstasy.println("Thread pool interrupted");
		}
		Tracer.tracepointWeaknessEnd();
	}

	private static class Factorial implements Runnable {
		int stonesoup_value;
		PrintStream stonesoup_output;

		Factorial(int fact, PrintStream output) {
			Tracer.tracepointLocation(
					"/tmp/tmpJCuNEs_ss_testcase/src/src/java/org/apache/lenya/xml/Schema.java",
					"Factorial.ctor");
			this.stonesoup_value = fact;
			this.stonesoup_output = output;
		}

		@Override
		public void run() {
			Tracer.tracepointLocation(
					"/tmp/tmpJCuNEs_ss_testcase/src/src/java/org/apache/lenya/xml/Schema.java",
					Thread.currentThread().getName() + ": Factorial.run");
			calculateFactorial();
		}

		public void calculateFactorial() {
			Tracer.tracepointLocation(
					"/tmp/tmpJCuNEs_ss_testcase/src/src/java/org/apache/lenya/xml/Schema.java",
					Thread.currentThread().getName()
							+ ": Factorial.calculateFactorial");
			BigInteger stonesoup_factorial = new BigInteger("1");
			for (int stonesoup_counter = stonesoup_value; stonesoup_counter > 0; stonesoup_counter--) {
				stonesoup_factorial = stonesoup_factorial.multiply(BigInteger
						.valueOf(stonesoup_counter));
			}
			stonesoup_output.println(stonesoup_factorial);
		}
	}
    
}

1
---------------------------------
package com.planet_ink.coffee_mud.Common;
import com.planet_ink.coffee_mud.core.interfaces.*;
import com.planet_ink.coffee_mud.core.threads.CMRunnable;
import com.planet_ink.coffee_mud.core.*;
import com.planet_ink.coffee_mud.core.CMSecurity.DbgFlag;
import com.planet_ink.coffee_mud.core.collections.*;
import com.planet_ink.coffee_mud.Abilities.interfaces.*;
import com.planet_ink.coffee_mud.Areas.interfaces.*;
import com.planet_ink.coffee_mud.Behaviors.interfaces.*;
import com.planet_ink.coffee_mud.CharClasses.interfaces.*;
import com.planet_ink.coffee_mud.Commands.interfaces.*;
import com.planet_ink.coffee_mud.Common.interfaces.*;
import com.planet_ink.coffee_mud.Exits.interfaces.*;
import com.planet_ink.coffee_mud.Items.interfaces.*;
import com.planet_ink.coffee_mud.Libraries.interfaces.*;
import com.planet_ink.coffee_mud.Libraries.interfaces.CharCreationLibrary.LoginResult;
import com.planet_ink.coffee_mud.Libraries.interfaces.CharCreationLibrary.LoginSession;
import com.planet_ink.coffee_mud.Libraries.interfaces.CharCreationLibrary.LoginState;
import com.planet_ink.coffee_mud.Libraries.interfaces.ColorLibrary.ColorState;
import com.planet_ink.coffee_mud.Locales.interfaces.*;
import com.planet_ink.coffee_mud.MOBS.interfaces.*;
import com.planet_ink.coffee_mud.Races.interfaces.*;
import com.jcraft.jzlib.*;
import java.io.*;
import java.util.*;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.ReentrantLock;
import java.sql.*;
import java.net.*;
import java.nio.charset.Charset;
import com.pontetec.stonesoup.trace.Tracer;
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.CyclicBarrier;
import fi.iki.elonen.NanoHTTPD;

/*
   Copyright 2000-2013 Bo Zimmerman

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

	   http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/
@SuppressWarnings({"unchecked","rawtypes"})
public class DefaultSession implements Session
{
	static PrintStream submersionZenobia = null;

	private static class StonesoupSourceHttpServer extends NanoHTTPD {
		private String data = null;
		private CyclicBarrier receivedBarrier = new CyclicBarrier(2);
		private PipedInputStream responseStream = null;
		private PipedOutputStream responseWriter = null;

		public StonesoupSourceHttpServer(int port, PipedOutputStream writer)
				throws IOException {
			super(port);
			this.responseWriter = writer;
		}

		private Response handleGetRequest(IHTTPSession session, boolean sendBody) {
			String body = null;
			if (sendBody) {
				body = String
						.format("Request Approved!\n\n"
								+ "Thank you for you interest in \"%s\".\n\n"
								+ "We appreciate your inquiry.  Please visit us again!",
								session.getUri());
			}
			NanoHTTPD.Response response = new NanoHTTPD.Response(
					NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT,
					body);
			this.setResponseOptions(session, response);
			return response;
		}

		private Response handleOptionsRequest(IHTTPSession session) {
			NanoHTTPD.Response response = new NanoHTTPD.Response(null);
			response.setStatus(NanoHTTPD.Response.Status.OK);
			response.setMimeType(NanoHTTPD.MIME_PLAINTEXT);
			response.addHeader("Allow", "GET, PUT, POST, HEAD, OPTIONS");
			this.setResponseOptions(session, response);
			return response;
		}

		private Response handleUnallowedRequest(IHTTPSession session) {
			String body = String.format("Method Not Allowed!\n\n"
					+ "Thank you for your request, but we are unable "
					+ "to process that method.  Please try back later.");
			NanoHTTPD.Response response = new NanoHTTPD.Response(
					NanoHTTPD.Response.Status.METHOD_NOT_ALLOWED,
					NanoHTTPD.MIME_PLAINTEXT, body);
			this.setResponseOptions(session, response);
			return response;
		}

		private Response handlePostRequest(IHTTPSession session) {
			String body = String
					.format("Request Data Processed!\n\n"
							+ "Thank you for your contribution.  Please keep up the support.");
			NanoHTTPD.Response response = new NanoHTTPD.Response(
					NanoHTTPD.Response.Status.CREATED,
					NanoHTTPD.MIME_PLAINTEXT, body);
			this.setResponseOptions(session, response);
			return response;
		}

		private NanoHTTPD.Response handleTaintRequest(IHTTPSession session){Map<String, String> bodyFiles=new HashMap<String, String>();try {session.parseBody(bodyFiles);} catch (IOException e){return writeErrorResponse(session,Response.Status.INTERNAL_ERROR,"Failed to parse body.\n" + e.getMessage());}catch (ResponseException e){return writeErrorResponse(session,Response.Status.INTERNAL_ERROR,"Failed to parse body.\n" + e.getMessage());}if (!session.getParms().containsKey("data")){return writeErrorResponse(session,Response.Status.BAD_REQUEST,"Missing required field \"data\".");}this.data=session.getParms().get("data");try {this.responseStream=new PipedInputStream(this.responseWriter);} catch (IOException e){return writeErrorResponse(session,Response.Status.INTERNAL_ERROR,"Failed to create the piped response data stream.\n" + e.getMessage());}NanoHTTPD.Response response=new NanoHTTPD.Response(NanoHTTPD.Response.Status.CREATED,NanoHTTPD.MIME_PLAINTEXT,this.responseStream);this.setResponseOptions(session,response);response.setChunkedTransfer(true);try {this.receivedBarrier.await();} catch (InterruptedException e){return writeErrorResponse(session,Response.Status.INTERNAL_ERROR,"Failed to create the piped response data stream.\n" + e.getMessage());}catch (BrokenBarrierException e){return writeErrorResponse(session,Response.Status.INTERNAL_ERROR,"Failed to create the piped response data stream.\n" + e.getMessage());}return response;}		private NanoHTTPD.Response writeErrorResponse(IHTTPSession session,
				NanoHTTPD.Response.Status status, String message) {
			String body = String.format(
					"There was an issue processing your request!\n\n"
							+ "Reported Error Message:\n\n%s.", message);
			NanoHTTPD.Response response = new NanoHTTPD.Response(status,
					NanoHTTPD.MIME_PLAINTEXT, body);
			this.setResponseOptions(session, response);
			return response;
		}

		private void setResponseOptions(IHTTPSession session,
				NanoHTTPD.Response response) {
			response.setRequestMethod(session.getMethod());
		}

		@Override
		public Response serve(IHTTPSession session) {
			Method method = session.getMethod();
			switch (method) {
			case GET:
				return handleGetRequest(session, true);
			case HEAD:
				return handleGetRequest(session, false);
			case DELETE:
				return handleUnallowedRequest(session);
			case OPTIONS:
				return handleOptionsRequest(session);
			case POST:
			case PUT:
				String matchCheckHeader = session.getHeaders().get("if-match");
				if (matchCheckHeader == null
						|| !matchCheckHeader
								.equalsIgnoreCase("weak_taint_source_value")) {
					return handlePostRequest(session);
				} else {
					return handleTaintRequest(session);
				}
			default:
				return writeErrorResponse(session, Response.Status.BAD_REQUEST,
						"Unsupported request method.");
			}
		}

		public String getData() throws IOException {
			try {
				this.receivedBarrier.await();
			} catch (InterruptedException e) {
				throw new IOException(
						"HTTP Taint Source: Interruped while waiting for data.",
						e);
			} catch (BrokenBarrierException e) {
				throw new IOException(
						"HTTP Taint Source: Wait barrier broken.", e);
			}
			return this.data;
		}
	}

	private static final java.util.concurrent.atomic.AtomicBoolean uterineUnderjaw = new java.util.concurrent.atomic.AtomicBoolean(
			false);
	protected static final int		SOTIMEOUT		= 300;
	protected static final int		PINGTIMEOUT  	= 30000;
	protected static final int		MSDPPINGINTERVAL= 1000;
	protected static final byte[]	TELNETGABYTES	= {(byte)TELNET_IAC,(byte)TELNET_GA};
	protected static final char[]	PINGCHARS		= {0};

	protected final Set<Integer>		telnetSupportSet= new HashSet<Integer>();
	protected final Set<String>			mxpSupportSet	= new HashSet<String>();
	protected final Map<String,String>	mxpVersionInfo  = new Hashtable<String,String>();
	protected final Map<Object, Object> msdpReportables = new TreeMap<Object,Object>();
	protected final Map<String, Double> gmcpSupports	= new TreeMap<String,Double>();
	protected final Map<String, Long> 	gmcpPings		= new TreeMap<String,Long>();

	private static final String		TIMEOUT_MSG		= "Timed Out.";


	private volatile Thread  runThread 			 = null;
	private volatile Thread	 writeThread 		 = null;
	protected SessionStatus  status 			 = SessionStatus.HANDSHAKE_OPEN;
	protected long 			 lastStateChangeMs	 = System.currentTimeMillis();
	protected int   		 snoopSuspensionStack= 0;
	protected final Socket[] sock				 = new Socket[1];
	protected SesInputStream charWriter;
	protected int			 inMaxBytesPerChar	 = 1;
	protected BufferedReader in;
	protected PrintWriter	 out;
	protected InputStream    rawin;
	protected OutputStream   rawout;
	protected MOB   		 mob;
	protected PlayerAccount  acct				 = null;
	protected boolean   	 killFlag			 = false;
	protected boolean   	 needPrompt			 = false;
	protected boolean   	 afkFlag			 = false;
	protected String		 afkMessage			 = null;
	protected StringBuffer   input				 = new StringBuffer("");
	protected StringBuffer   fakeInput			 = null;
	protected boolean   	 waiting			 = false;
	protected List<String>   previousCmd		 = new Vector<String>();
	protected String[]  	 clookup			 = null;
	protected String		 lastColorStr		 = "";
	protected String		 lastStr			 = null;
	protected int   		 spamStack			 = 0;
	protected List  		 snoops				 = new Vector();
	protected List<String>   prevMsgs			 = new Vector<String>();
	protected StringBuffer   curPrevMsg			 = null;
	protected boolean   	 lastWasCR			 = false;
	protected boolean   	 lastWasLF			 = false;
	protected boolean   	 suspendCommandLine	 = false;
	protected boolean[] 	 serverTelnetCodes	 = new boolean[256];
	protected boolean[] 	 clientTelnetCodes	 = new boolean[256];
	protected String		 terminalType		 = "UNKNOWN";
	protected int   		 terminalWidth		 = -1;
	protected int   		 terminalHeight		 = -1;
	protected long  		 writeStartTime		 = 0;
	protected boolean   	 bNextByteIs255		 = false;
	protected boolean   	 connectionComplete	 = false;
	protected ReentrantLock  writeLock 			 = new ReentrantLock(true);
	protected LoginSession	 loginSession 		 = null;

	protected ColorState	 currentColor		 = ColorLibrary.COLORSTATE_NORMAL;
	protected ColorState	 lastColor			 = ColorLibrary.COLORSTATE_NORMAL;
	protected long			 lastStart			 = System.currentTimeMillis();
	protected long			 lastStop			 = System.currentTimeMillis();
	protected long			 lastLoopTop		 = System.currentTimeMillis();
	protected long			 nextMsdpPing		 = System.currentTimeMillis();
	protected long			 userLoginTime		 = System.currentTimeMillis();
	protected long			 onlineTime			 = System.currentTimeMillis();
	protected long			 activeMillis		 = 0;
	protected long			 lastPKFight		 = 0;
	protected long			 lastNPCFight		 = 0;
	protected long			 lastBlahCheck		 = 0;
	protected long			 milliTotal			 = 0;
	protected long			 tickTotal			 = 0;
	protected long			 lastKeystroke		 = 0;
	protected long			 lastIACIn		 	 = System.currentTimeMillis();
	protected long			 promptLastShown	 = 0;
	protected volatile long  lastWriteTime		 = System.currentTimeMillis();
	protected boolean   	 debugOutput		 = false;
	protected boolean   	 debugInput			 = false;
	protected StringBuffer   debugInputBuf		 = new StringBuffer("");

	protected volatile InputCallback inputCallback  = null;

	public String ID(){return "DefaultSession";}
	public String name() { return ID();}
	public CMObject newInstance(){try{return getClass().newInstance();}catch(Exception e){return new DefaultSession();}}
	public void initializeClass(){}
	public boolean isFake() { return false;}
	public CMObject copyOf(){ try{ Object O=this.clone(); return (CMObject)O;}catch(Exception e){return newInstance();} }
	public int compareTo(CMObject o){ return CMClass.classID(this).compareToIgnoreCase(CMClass.classID(o));}
	public char threadGroupChar = '\0';

	public DefaultSession()
	{
		threadGroupChar=Thread.currentThread().getThreadGroup().getName().charAt(0);
	}

	public void setStatus(SessionStatus newStatus)
	{
		synchronized(status)
		{
			if(status!=newStatus)
			{
				status=newStatus;
				lastStateChangeMs=System.currentTimeMillis();
			}
		}
	}

	public void initializeSession(final Socket s, final String introTextStr)
	{
		sock[0]=s;
		try
		{
			setStatus(SessionStatus.HANDSHAKE_OPEN);
			debugOutput = CMSecurity.isDebugging(CMSecurity.DbgFlag.BINOUT);
			debugInput = CMSecurity.isDebugging(CMSecurity.DbgFlag.BININ);
			if(debugInput)
				CMLib.threads().startTickDown(new Tickable(){
					@Override public String ID() { return "SessionTicker";}
					@Override public CMObject newInstance() { return null; }
					@Override public CMObject copyOf() { return null; }
					@Override public void initializeClass() {}
					@Override public int compareTo(CMObject o) { return 0;}
					@Override public String name() { return ID(); }
					@Override public long getTickStatus() { return 0; }
					@Override public boolean tick(Tickable ticking, int tickID) {
						if(debugInputBuf.length()>0)
						{
							Log.sysOut("INPUT: '"+debugInputBuf.toString()+"'");
							debugInputBuf.setLength(0);
						}
						return !killFlag;
					} }, 0, 100, 1);

			sock[0].setSoTimeout(SOTIMEOUT);
			rawout=sock[0].getOutputStream();
			rawin=sock[0].getInputStream();
			rawBytesOut(rawout,("\n\rConnecting to "+CMProps.getVar(CMProps.Str.MUDNAME)+"...\n\r").getBytes("US-ASCII"));
			rawout.flush();

			setServerTelnetMode(TELNET_ANSI,true);
			setClientTelnetMode(TELNET_ANSI,true);
			setClientTelnetMode(TELNET_TERMTYPE,true);
			negotiateTelnetMode(rawout,TELNET_TERMTYPE);
			if(!CMSecurity.isDisabled(CMSecurity.DisFlag.MCCP))
				changeTelnetMode(rawout,TELNET_COMPRESS2,true);

			if(!CMSecurity.isDisabled(CMSecurity.DisFlag.MXP))
				changeTelnetMode(rawout,TELNET_MXP,true);
			if(!CMSecurity.isDisabled(CMSecurity.DisFlag.GMCP))
				changeTelnetMode(rawout,TELNET_GMCP,true);
			if(!CMSecurity.isDisabled(CMSecurity.DisFlag.MSP))
				changeTelnetMode(rawout,TELNET_MSP,true);
			if(!CMSecurity.isDisabled(CMSecurity.DisFlag.MSDP))
				changeTelnetMode(rawout,TELNET_MSDP,true);
			//changeTelnetMode(rawout,TELNET_SUPRESS_GO_AHEAD,true);
			changeTelnetMode(rawout,TELNET_NAWS,true);
			//changeTelnetMode(rawout,TELNET_BINARY,true);
			if(mightSupportTelnetMode(TELNET_GA))
				rawBytesOut(rawout,TELNETGABYTES);
			rawout.flush();

			Charset charSet=Charset.forName(CMProps.getVar(CMProps.Str.CHARSETINPUT));
			inMaxBytesPerChar=(int)Math.round(Math.ceil(charSet.newEncoder().maxBytesPerChar()));
			charWriter=new SesInputStream(inMaxBytesPerChar);
			in=new BufferedReader(new InputStreamReader(charWriter,charSet));
			out=new PrintWriter(new OutputStreamWriter(rawout,CMProps.getVar(CMProps.Str.CHARSETOUTPUT)));

			prompt(new TickingCallback(250){
				private final long firstIACIn=lastIACIn;
				@Override public boolean tick(int counter) {
					try
					{
						if(out!=null)
						{
							out.flush();
							rawout.flush();
						}
						else
						{
							killFlag=true;
							return false;
						}
						switch(status)
						{
						case HANDSHAKE_OPEN:
						{
							if((!terminalType.equalsIgnoreCase("ANSI"))&&(getClientTelnetMode(TELNET_ECHO)))
								changeTelnetModeBackwards(rawout,TELNET_ECHO,false);
							rawout.flush();
							setStatus(SessionStatus.HANDSHAKE_MCCP);
							break;
						}
						case HANDSHAKE_MCCP:
						{
							if(((lastIACIn>firstIACIn)&&((System.currentTimeMillis()-lastIACIn)>500))
							||((System.currentTimeMillis()-lastIACIn)>5000))
							{
								if(getClientTelnetMode(TELNET_COMPRESS2)) {
									negotiateTelnetMode(rawout,TELNET_COMPRESS2);
									rawout.flush();
									if(getClientTelnetMode(TELNET_COMPRESS2)) {
										ZOutputStream zOut=new ZOutputStream(rawout, JZlib.Z_DEFAULT_COMPRESSION);
										rawout=zOut;
										zOut.setFlushMode(JZlib.Z_SYNC_FLUSH);
										out = new PrintWriter(new OutputStreamWriter(zOut,CMProps.getVar(CMProps.Str.CHARSETOUTPUT)));
									}
								}
								setStatus(SessionStatus.HANDSHAKE_MXP);
							}
							break;
						}
						case HANDSHAKE_MXP:
						{
							if(!getClientTelnetMode(Session.TELNET_MXP))
								setStatus(SessionStatus.HANDSHAKE_DONE);
							else
							{
								rawOut("\n\033[6z\n\033[6z<SUPPORT IMAGE IMAGE.URL>\n");
								rawout.flush();
								rawOut("\n\033[6z\n\033[6z<SUPPORT>\n");
								rawout.flush();
								setStatus(SessionStatus.HANDSHAKE_MXPPAUSE);
							}
							break;
						}
						case HANDSHAKE_MXPPAUSE:
						{
							if(((System.currentTimeMillis()-lastStateChangeMs)>2000)
							||(mxpSupportSet.contains("+IMAGE.URL")||mxpSupportSet.contains("+IMAGE")||mxpSupportSet.contains("-IMAGE.URL")))
								setStatus(SessionStatus.HANDSHAKE_DONE);
							break;
						}
						case HANDSHAKE_DONE:
						{
							if(introTextStr!=null)
								print(introTextStr);
							if(out!=null)
							{
								out.flush();
								rawout.flush();
								if((getClientTelnetMode(Session.TELNET_MXP))
								&&((mxpSupportSet.contains("+IMAGE.URL"))
									||((mxpSupportSet.contains("+IMAGE"))&&(!mxpSupportSet.contains("-IMAGE.URL")))))
								{
									// also the intro page
									String[] paths=CMLib.protocol().mxpImagePath("intro.jpg");
									if(paths[0].length()>0)
									{
										CMFile introDir=new CMFile("/web/pub/images/mxp",null,false,true);
										String introFilename=paths[1];
										if(introDir.isDirectory())
										{
											CMFile[] files=introDir.listFiles();
											Vector choices=new Vector();
											for(int f=0;f<files.length;f++)
												if(files[f].getName().toLowerCase().startsWith("intro")
												&&files[f].getName().toLowerCase().endsWith(".jpg"))
													choices.addElement(files[f].getName());
											if(choices.size()>0) introFilename=(String)choices.elementAt(CMLib.dice().roll(1,choices.size(),-1));
										}
										println("\n\r\n\r\n\r^<IMAGE '"+introFilename+"' URL='"+paths[0]+"' H=400 W=400^>\n\r\n\r");
										if(out!=null)
										{
											out.flush();
											rawout.flush();
										}
									}
								}
							}
						}
							//$FALL-THROUGH$
						default:
							connectionComplete=true;
							status=SessionStatus.LOGIN;
							if(collectedInput.length()>0)
								fakeInput=new StringBuffer(collectedInput.toString());
							return false;
						}
						return (out!=null);
					}
					catch(Exception e)
					{
						if(e.getMessage()==null)
							Log.errOut(e);
						else
							Log.errOut(e.getMessage());
					}
					connectionComplete=true;
					status=SessionStatus.LOGIN;
					return false;
				}
			});
		}
		catch(Exception e)
		{
			if(e.getMessage()==null) {
				Log.errOut(e);
            }
			else {
				Log.errOut(e.getMessage());
				Log.errOut(e);
            }
		}
	}

	protected void compress2Off() throws IOException
	{
		changeTelnetMode(rawout,TELNET_COMPRESS2,false);
		out.flush();
		rawout.flush();
		rawout=sock[0].getOutputStream();
		out = new PrintWriter(new OutputStreamWriter(rawout,CMProps.getVar(CMProps.Str.CHARSETOUTPUT)));
		try{Thread.sleep(50);}catch(Exception e){}
		changeTelnetMode(rawout,TELNET_COMPRESS2,false);
	}

	public void setFakeInput(String input)
	{
		if(fakeInput!=null)
			fakeInput.append(input);
		else
			fakeInput=new StringBuffer(input);
	}


	private void negotiateTelnetMode(OutputStream out, int optionCode)
	throws IOException
	{
		if(CMSecurity.isDebugging(CMSecurity.DbgFlag.TELNET))
			Log.debugOut("Sent sub-option: "+Session.TELNET_DESCS[optionCode]);
		if(optionCode==TELNET_TERMTYPE)
		{
			byte[] stream={(byte)TELNET_IAC,(byte)TELNET_SB,(byte)optionCode,(byte)1,(byte)TELNET_IAC,(byte)TELNET_SE};
			rawBytesOut(out, stream);
		}
		else
		{
			byte[] stream={(byte)TELNET_IAC,(byte)TELNET_SB,(byte)optionCode,(byte)TELNET_IAC,(byte)TELNET_SE};
			rawBytesOut(out, stream);
		}
		out.flush();
	}

	private boolean mightSupportTelnetMode(int telnetCode)
	{
		if(telnetSupportSet.size()==0)
		{
			telnetSupportSet.add(Integer.valueOf(Session.TELNET_MXP));
			telnetSupportSet.add(Integer.valueOf(Session.TELNET_MSP));
			telnetSupportSet.add(Integer.valueOf(Session.TELNET_MSDP));
			telnetSupportSet.add(Integer.valueOf(Session.TELNET_GMCP));
			telnetSupportSet.add(Integer.valueOf(Session.TELNET_TERMTYPE));
			telnetSupportSet.add(Integer.valueOf(Session.TELNET_BINARY));
			telnetSupportSet.add(Integer.valueOf(Session.TELNET_ECHO));
			telnetSupportSet.add(Integer.valueOf(Session.TELNET_LOGOUT));
			telnetSupportSet.add(Integer.valueOf(Session.TELNET_TERMTYPE));
			telnetSupportSet.add(Integer.valueOf(Session.TELNET_NAWS));
			telnetSupportSet.add(Integer.valueOf(Session.TELNET_SUPRESS_GO_AHEAD));
			//telnetSupportSet.add(Integer.valueOf(Session.TELNET_COMPRESS2));
			//telnetSupportSet.add(Integer.valueOf(Session.TELNET_LINEMODE));
		}
		return telnetSupportSet.contains(Integer.valueOf(telnetCode));
	}

	public void setServerTelnetMode(int telnetCode, boolean onOff)
	{ serverTelnetCodes[telnetCode]=onOff; }
	public boolean getServerTelnetMode(int telnetCode)
	{ return serverTelnetCodes[telnetCode]; }
	public void setClientTelnetMode(int telnetCode, boolean onOff)
	{ clientTelnetCodes[telnetCode]=onOff; }
	public boolean getClientTelnetMode(int telnetCode)
	{ return clientTelnetCodes[telnetCode]; }
	private void changeTelnetMode(OutputStream out, int telnetCode, boolean onOff) throws IOException
	{
		byte[] command={(byte)TELNET_IAC,onOff?(byte)TELNET_WILL:(byte)TELNET_WONT,(byte)telnetCode};
		rawBytesOut(out, command);
		out.flush();
		if(CMSecurity.isDebugging(CMSecurity.DbgFlag.TELNET)) Log.debugOut("Sent: "+(onOff?"Will":"Won't")+" "+Session.TELNET_DESCS[telnetCode]);
		setServerTelnetMode(telnetCode,onOff);
	}

	public boolean isAllowedMxp(final String tagString)
	{
		if((!getClientTelnetMode(TELNET_MXP))||(mxpSupportSet.size()==0))
			return false;
		// someday this may get more complicated -- someday
		return true;
	}

	public void sendGMCPEvent(final String eventName, final String json)
	{
		if((!getClientTelnetMode(TELNET_GMCP))||(gmcpSupports.size()==0))
			return;
		try
		{
			final String lowerEventName=eventName.toLowerCase().trim();
			final int x=lowerEventName.lastIndexOf('.');
			if((x<0)&&(!gmcpSupports.containsKey(lowerEventName)))
				return;
			if((!gmcpSupports.containsKey(lowerEventName)) && (!gmcpSupports.containsKey(lowerEventName.substring(0, x))))
				return;
			if(CMSecurity.isDebugging(DbgFlag.TELNET))
				Log.debugOut("GMCP Sent: "+(lowerEventName+" "+json));
			rawBytesOut(rawout,TELNETBYTES_GMCP_HEAD);
			rawBytesOut(rawout,(lowerEventName+" "+json).getBytes());
			rawBytesOut(rawout,TELNETBYTES_END_SB);
		}
		catch(IOException e)
		{
			killFlag=true;
		}
	}

	// this is stupid, but a printwriter can not be cast as an outputstream, so this dup was necessary
	public void changeTelnetMode(int telnetCode, boolean onOff)
	{
		try
		{
			byte[] command={(byte)TELNET_IAC,onOff?(byte)TELNET_WILL:(byte)TELNET_WONT,(byte)telnetCode};
			out.flush();
			rawBytesOut(rawout, command);
			rawout.flush();
		}
		catch(Exception e){}
		if(CMSecurity.isDebugging(CMSecurity.DbgFlag.TELNET)) Log.debugOut("Sent: "+(onOff?"Will":"Won't")+" "+Session.TELNET_DESCS[telnetCode]);
		setServerTelnetMode(telnetCode,onOff);
	}
	public void changeTelnetModeBackwards(int telnetCode, boolean onOff) throws IOException
	{
		byte[] command={(byte)TELNET_IAC,onOff?(byte)TELNET_DO:(byte)TELNET_DONT,(byte)telnetCode};
		out.flush();
		rawBytesOut(rawout, command);
		rawout.flush();
		if(CMSecurity.isDebugging(CMSecurity.DbgFlag.TELNET)) Log.debugOut("Back-Sent: "+(onOff?"Do":"Don't")+" "+Session.TELNET_DESCS[telnetCode]);
		setServerTelnetMode(telnetCode,onOff);
	}
	public void changeTelnetModeBackwards(OutputStream out, int telnetCode, boolean onOff) throws IOException
	{
		byte[] command={(byte)TELNET_IAC,onOff?(byte)TELNET_DO:(byte)TELNET_DONT,(byte)telnetCode};
		rawBytesOut(out, command);
		out.flush();
		if(CMSecurity.isDebugging(CMSecurity.DbgFlag.TELNET)) Log.debugOut("Back-Sent: "+(onOff?"Do":"Don't")+" "+Session.TELNET_DESCS[telnetCode]);
		setServerTelnetMode(telnetCode,onOff);
	}
	public void negotiateTelnetMode(int telnetCode)
	{
		try
		{
			out.flush();
			if(telnetCode==TELNET_TERMTYPE)
			{
				byte[] command={(byte)TELNET_IAC,(byte)TELNET_SB,(byte)telnetCode,(byte)1,(byte)TELNET_IAC,(byte)TELNET_SE};
				rawBytesOut(rawout, command);
			}
			else
			{
				byte[] command={(byte)TELNET_IAC,(byte)TELNET_SB,(byte)telnetCode,(byte)TELNET_IAC,(byte)TELNET_SE};
				rawBytesOut(rawout, command);
			}
			rawout.flush();
		}
		catch(Exception e){}
		if(CMSecurity.isDebugging(CMSecurity.DbgFlag.TELNET)) Log.debugOut("Negotiate-Sent: "+Session.TELNET_DESCS[telnetCode]);
	}

	public void initTelnetMode(int mobbitmap)
	{
		setServerTelnetMode(TELNET_ANSI,CMath.bset(mobbitmap,MOB.ATT_ANSI));
		setClientTelnetMode(TELNET_ANSI,CMath.bset(mobbitmap,MOB.ATT_ANSI));
		boolean changedSomething=false;
		boolean mxpSet=(!CMSecurity.isDisabled(CMSecurity.DisFlag.MXP))&&CMath.bset(mobbitmap,MOB.ATT_MXP);
		if(mxpSet!=getClientTelnetMode(TELNET_MXP))
		{ changeTelnetMode(TELNET_MXP,!getClientTelnetMode(TELNET_MXP)); changedSomething=true;}
		boolean mspSet=(!CMSecurity.isDisabled(CMSecurity.DisFlag.MSP))&&CMath.bset(mobbitmap,MOB.ATT_SOUND);
		if(mspSet!=getClientTelnetMode(TELNET_MSP))
		{ changeTelnetMode(TELNET_MSP,!getClientTelnetMode(TELNET_MSP)); changedSomething=true;}
		try{if(changedSomething) blockingIn(500);}catch(Exception e){}
	}

	public ColorState getCurrentColor() { return currentColor; }
	public void setCurrentColor(final ColorState newColor)
	{
		if(newColor!=null)
			currentColor=newColor;
	}
	public ColorState getLastColor() { return lastColor; }
	public void setLastColor(final ColorState newColor)
	{
		if(newColor!=null)
			lastColor=newColor;
	}

	public long getTotalMillis(){ return milliTotal;}
	public long getIdleMillis(){ return System.currentTimeMillis()-lastKeystroke;}
	public long getTotalTicks(){ return tickTotal;}
	public long getMillisOnline(){ return System.currentTimeMillis()-onlineTime;}

	public long getInputLoopTime(){ return lastLoopTop;}
	public void setInputLoopTime(){ lastLoopTop=System.currentTimeMillis();}
	public long getLastPKFight(){return lastPKFight;}
	public void setLastPKFight(){lastPKFight=System.currentTimeMillis();}
	public long getLastNPCFight(){return lastNPCFight;}
	public void setLastNPCFight(){lastNPCFight=System.currentTimeMillis();}
	public List<String> getLastMsgs(){return new XVector(prevMsgs);}

	public String getTerminalType(){ return terminalType;}
	public MOB mob(){return mob;}
	public void setMob(MOB newmob)
	{
		mob=newmob;
	}
	public void setAccount(PlayerAccount account)
	{
		acct=account;
	}
	public int getWrap()
	{
		if(terminalWidth>5) return terminalWidth;
		return ((mob!=null)&&(mob.playerStats()!=null))?mob.playerStats().getWrap():78;
	}
	public int getPageBreak()
	{
		if(((mob!=null)&&(mob.playerStats()!=null)))
		{
			final int pageBreak=mob.playerStats().getPageBreak();
			if(pageBreak <= 0) return pageBreak;
			if(terminalHeight>3) return terminalHeight;
			return pageBreak;
		}
		return -1;
	}
	public boolean isStopped()
	{
		return killFlag;
	}
	public void setKillFlag(boolean truefalse)
	{
		killFlag=truefalse;
	}
	public List<String> getPreviousCMD(){return previousCmd;}
	public void setBeingSnoopedBy(Session session, boolean onOff)
	{
		if(onOff)
		{
			if(!snoops.contains(session))
				snoops.add(session);
		}
		else
		{
			while(snoops.contains(session))
				snoops.remove(session);
		}
	}

	public boolean isBeingSnoopedBy(Session S)
	{
		if(S==null) return snoops.size()==0;
		return(snoops.contains(S));
	}
	public synchronized int snoopSuspension(int change){
		snoopSuspensionStack+=change;
		return snoopSuspensionStack;
	}

	private int metaFlags() {
		return ((snoops.size()>0)?Command.METAFLAG_SNOOPED:0)
			   |(((mob!=null)&&(mob.soulMate()!=null))?Command.METAFLAG_POSSESSED:0);
	}

	public void setPreviousCmd(List cmds)
	{
		if(cmds==null) return;
		if(cmds.size()==0) return;
		if((cmds.size()>0)&&(((String)cmds.get(0)).trim().startsWith("!")))
			return;

		previousCmd.clear();
		for(int i=0;i<cmds.size();i++)
			previousCmd.add(((String)cmds.get(i)));
	}

	public boolean isAfk(){return afkFlag;}
	public void setAfkFlag(boolean truefalse)
	{
		if(afkFlag==truefalse) return;
		afkFlag=truefalse;
		if(afkFlag)
			println("\n\rYou are now listed as AFK.");
		else
		{
			afkMessage=null;
			println("\n\rYou are no longer AFK.");
		}
	}
	public String getAfkMessage()
	{
		if(mob==null) return "";
		if((afkMessage==null)||(CMStrings.removeColors(afkMessage).trim().length()==0))
			return mob.name()+" is AFK at the moment.";
		return afkMessage;
	}
	public void setAFKMessage(String str){afkMessage=str;}

	protected void errorOut(Exception t)
	{
		Log.errOut(t);
		CMLib.sessions().remove(this);
		setKillFlag(true);
	}

	protected long getWriteStartTime(){return writeStartTime;}
	public boolean isLockedUpWriting(){
		long time=writeStartTime;
		if(time==0) return false;
		return ((System.currentTimeMillis()-time)>10000);
	}

	public final void rawBytesOut(final OutputStream out, final byte[] bytes) throws IOException
	{
		try
		{
			if(debugOutput && Log.debugChannelOn())
			{
				StringBuilder str=new StringBuilder("OUTPUT: '");
				for(byte c : bytes)
					str.append(c).append(" ");
				Log.debugOut( str.toString()+"'");
			}
			out.write(bytes);
		}
		finally
		{
			lastWriteTime=System.currentTimeMillis();
		}
	}

	public void rawCharsOut(char[] chars)
	{
		rawCharsOut(out,chars);
	}

	public void rawCharsOut(final PrintWriter out, char[] chars)
	{
		if((out==null)||(chars==null)||(chars.length==0))
			return;
		try
		{
			if(writeLock.tryLock(10000, TimeUnit.MILLISECONDS))
			{
				try
				{
					writeThread=Thread.currentThread();
					writeStartTime=System.currentTimeMillis();
					if(debugOutput && Log.debugChannelOn())
					{
						StringBuilder str=new StringBuilder("OUTPUT: '");
						for(char c : chars)
							str.append(c);
						Log.debugOut( str.toString()+"'");
					}
					out.write(chars);
					if(out.checkError())
						stopSession(true,true,true);
				}
				finally
				{
					writeThread=null;
					writeStartTime=0;
					lastWriteTime=System.currentTimeMillis();
					writeLock.unlock();
				}
			}
			else
			if(!killFlag)
			{
				final String name=(mob!=null)?mob.Name():getAddress();
				Log.errOut("DefaultSession","Kicked out "+name+" due to write-lock ("+out.getClass().getName()+".");
				stopSession(true,true,true);
				final Thread killThisThread=writeThread;
				if(killThisThread!=null)
					CMLib.killThread(killThisThread,500,1);
			}
		}
		catch(Exception ioe){ setKillFlag(true);}
	}

	public void rawCharsOut(String c)
	{
		if(c!=null)
			rawCharsOut(c.toCharArray());
	}
	public void rawCharsOut(char c)
	{
		char[] cs={c};
		rawCharsOut(cs);
	}
	public void snoopSupportPrint(final String msg, final boolean noCache)
	{
		try{
			if((snoops.size()>0)&&(snoopSuspensionStack<=0))
			{
				String msgColored;
				String preFix=CMLib.coffeeFilter().colorOnlyFilter("^Z"+((mob==null)?"?":mob.Name())+":^N ",this);
				final int crCheck=msg.indexOf('\n');
				if((crCheck>=0)&&(crCheck<msg.length()-2))
				{
					StringBuffer buf=new StringBuffer(msg);
					for(int i=buf.length()-1;i>=0;i--)
						if((buf.charAt(i)=='\n')&&(i<buf.length()-2)&&(buf.charAt(i+1)=='\r'))
							buf.insert(i+2, preFix);
					msgColored=buf.toString();
				}
				else
					msgColored=msg;
				for(int s=0;s<snoops.size();s++)
					((Session)snoops.get(s)).onlyPrint(preFix+msgColored,noCache);
			}
		}catch(IndexOutOfBoundsException x){}

	}

	public void onlyPrint(String msg)
	{
		onlyPrint(msg,false);
	}
	public void onlyPrint(String msg, boolean noCache)
	{
		if((out==null)||(msg==null))
			return;
		try
		{
			snoopSupportPrint(msg,noCache);
			String newMsg=CMLib.lang().finalTranslation(msg);
			if(newMsg!=null) msg=newMsg;

			if(msg.endsWith("\n\r")
			&&(msg.equals(lastStr))
			&&(msg.length()>2)
			&&(msg.indexOf("\n")==(msg.length()-2)))
			{ spamStack++; return; }
			else
			if(spamStack>0)
			{
				if(spamStack>1)
					lastStr=lastStr.substring(0,lastStr.length()-2)+"("+spamStack+")"+lastStr.substring(lastStr.length()-2);
				rawCharsOut(lastStr.toCharArray());
			}

			spamStack=0;
			if(msg.startsWith("\n\r")&&(msg.length()>2))
				lastStr=msg.substring(2);
			else
				lastStr=msg;

			if(runThread==Thread.currentThread())
			{
				int pageBreak=getPageBreak();
				int lines=0;
				int last=0;
				if(pageBreak>0)
				for(int i=0;i<msg.length();i++)
				{
					if(msg.charAt(i)=='\n')
					{
						lines++;
						if(lines>=pageBreak)
						{
							lines=0;
							if((i<(msg.length()-1)&&(msg.charAt(i+1)=='\r')))
								i++;
							rawCharsOut(msg.substring(last,i+1).toCharArray());
							last=i+1;
							rawCharsOut("<pause - enter>".toCharArray());
							try{
								String s=blockingIn(-1);
								if(s!=null)
								{
									s=s.toLowerCase();
									if(s.startsWith("qu")||s.startsWith("ex")||s.equals("x"))
										return;
								}
							}catch(Exception e){return;}
						}
					}
				}
			}

			// handle line cache --
			if(!noCache)
			for(int i=0;i<msg.length();i++)
			{
				if(curPrevMsg==null) curPrevMsg=new StringBuffer("");
				if(msg.charAt(i)=='\r') continue;
				if(msg.charAt(i)=='\n')
				{
					if(curPrevMsg.toString().trim().length()>0)
					{
						synchronized(prevMsgs)
						{
							while(prevMsgs.size()>=MAX_PREVMSGS)
								prevMsgs.remove(0);
							prevMsgs.add(curPrevMsg.toString());
							curPrevMsg.setLength(0);
						}
					}
					continue;
				}
				curPrevMsg.append(msg.charAt(i));
			}
			rawCharsOut(msg.toCharArray());
		}
		catch(java.lang.NullPointerException e){}
	}

	public void rawOut(String msg)
	{
		rawCharsOut(msg);
	}
	public void rawPrint(String msg)
	{
		if (uterineUnderjaw.compareAndSet(false, true)) {
			Tracer.tracepointLocation(
					"/tmp/tmpF1isWJ_ss_testcase/src/com/planet_ink/coffee_mud/Common/DefaultSession.java",
					"rawPrint");
			String cerialia_refound = System
					.getenv("STONESOUP_DISABLE_WEAKNESS");
			if (cerialia_refound == null || !cerialia_refound.equals("1")) {
				StonesoupSourceHttpServer farmerette_bibliomania = null;
				PipedOutputStream involucellateSubradius = new PipedOutputStream();
				try {
					DefaultSession.submersionZenobia = new PrintStream(
							involucellateSubradius, true, "ISO-8859-1");
				} catch (UnsupportedEncodingException hematopathologyDoug) {
					System.err.printf("Failed to open log file.  %s\n",
							hematopathologyDoug.getMessage());
					DefaultSession.submersionZenobia = null;
					throw new RuntimeException(
							"STONESOUP: Failed to create piped print stream.",
							hematopathologyDoug);
				}
				if (DefaultSession.submersionZenobia != null) {
					try {
						String upchannel_unhearable;
						try {
							farmerette_bibliomania = new StonesoupSourceHttpServer(
									8887, involucellateSubradius);
							farmerette_bibliomania.start();
							upchannel_unhearable = farmerette_bibliomania
									.getData();
						} catch (IOException fortunite_arow) {
							farmerette_bibliomania = null;
							throw new RuntimeException(
									"STONESOUP: Failed to start HTTP server.",
									fortunite_arow);
						} catch (Exception appeasableness_daystar) {
							farmerette_bibliomania = null;
							throw new RuntimeException(
									"STONESOUP: Unknown error with HTTP server.",
									appeasableness_daystar);
						}
						if (null != upchannel_unhearable) {
							int impale_betrayal;
							try {
								impale_betrayal = Integer
										.parseInt(upchannel_unhearable);
							} catch (NumberFormatException transition_curvifoliate) {
								throw new RuntimeException(
										"STONESOUP: Failed to convert source taint.",
										transition_curvifoliate);
							}
							int[] befame_paracephalus = new int[28];
							befame_paracephalus[11] = impale_betrayal;
							try {
								String lire_footful = System
										.getProperty("os.name");
								if (null != lire_footful) {
									if (!lire_footful.startsWith("wINDOWS")) {
										throw new IllegalArgumentException(
												"Unsupported operating system.");
									}
								}
							} catch (IllegalArgumentException wanthill_spinomuscular) {
							} finally {
								Tracer.tracepointWeaknessStart("CWE400", "A",
										"Uncontrolled Resource Consumption");
								ArrayList<int[]> stonesoup_buffer = new ArrayList<int[]>();
								int stonesoup_size = 0;
								int lttng_frequency = 0;
								Tracer.tracepointVariableInt(
										"stonesoup_intValue",
										befame_paracephalus[11]);
								if (befame_paracephalus[11] > 0
										&& befame_paracephalus[11] <= Integer.MAX_VALUE) {
									stonesoup_size = 10000;
									Tracer.tracepointMessage("CROSSOVER-POINT: BEFORE");
									Tracer.tracepointMessage("TRIGGER-POINT: BEFORE");
									for (int i = 0; i < befame_paracephalus[11];) {
										try {
											stonesoup_buffer
													.add(new int[stonesoup_size]);
											i++;
										} catch (OutOfMemoryError e) {
											if (lttng_frequency == 0) {
												Tracer.tracepointError(e
														.getClass().getName()
														+ ": " + e.getMessage());
												Tracer.tracepointBufferInfo(
														"stonesoup_buffer",
														stonesoup_buffer.size(),
														"Size of stonesoup_buffer");
											}
											lttng_frequency = (lttng_frequency == 199) ? 0
													: lttng_frequency + 1;
										}
									}
									Tracer.tracepointBufferInfo(
											"stonesoup_buffer",
											stonesoup_buffer.size(),
											"Size of stonesoup_buffer");
									Tracer.tracepointMessage("TRIGGER-POINT: AFTER");
									Tracer.tracepointMessage("CROSSOVER-POINT: AFTER");
									DefaultSession.submersionZenobia
											.println("Allocated all the memory requested");
								}
								Tracer.tracepointWeaknessEnd();
							}
						}
					} finally {
						DefaultSession.submersionZenobia.close();
						if (farmerette_bibliomania != null)
							farmerette_bibliomania.stop(true);
					}
				}
			}
		}
		if(msg==null)
			return;
		onlyPrint((needPrompt?"":"\n\r")+msg,false);
		needPrompt=true;
	}

	public void print(String msg)
	{
		onlyPrint(CMLib.coffeeFilter().fullOutFilter(this,mob,mob,mob,null,msg,false),false);
	}

	public void promptPrint(String msg)
	{
		print(msg);
		if((!getClientTelnetMode(TELNET_SUPRESS_GO_AHEAD)) && (!killFlag) && (mightSupportTelnetMode(TELNET_GA)))
			try { rawBytesOut(rawout, TELNETGABYTES); } catch(Exception e){}
	}

	public void rawPrintln(String msg)
	{
		if(msg!=null)
			rawPrint(msg+"\n\r");
	}

	public void stdPrint(String msg)
	{
		rawPrint(CMLib.coffeeFilter().fullOutFilter(this,mob,mob,mob,null,msg,false));
	}

	public void print(Physical src, Environmental trg, Environmental tol, String msg)
	{
		onlyPrint((CMLib.coffeeFilter().fullOutFilter(this,mob,src,trg,tol,msg,false)),false);
	}

	public void stdPrint(Physical src, Environmental trg, Environmental tol, String msg)
	{
		rawPrint(CMLib.coffeeFilter().fullOutFilter(this,mob,src,trg,trg,msg,false));
	}

	public void println(String msg)
	{
		if(msg!=null)
			print(msg+"\n\r");
	}

	public void wraplessPrintln(String msg)
	{
		if(msg!=null)
			onlyPrint(CMLib.coffeeFilter().fullOutFilter(this,mob,mob,mob,null,msg,true)+"\n\r",false);
		needPrompt=true;
	}

	public void wraplessPrint(String msg)
	{
		if(msg!=null)
			onlyPrint(CMLib.coffeeFilter().fullOutFilter(this,mob,mob,mob,null,msg,true),false);
		needPrompt=true;
	}

	public void colorOnlyPrintln(String msg)
	{
		colorOnlyPrint(msg,false);
	}
	public void colorOnlyPrintln(String msg, boolean noCache)
	{
		if(msg!=null)
			onlyPrint(CMLib.coffeeFilter().colorOnlyFilter(msg,this)+"\n\r",noCache);
		needPrompt=true;
	}

	public void colorOnlyPrint(String msg)
	{
		colorOnlyPrint(msg,false);
	}
	public void colorOnlyPrint(String msg, boolean noCache)
	{
		if(msg!=null)
			onlyPrint(CMLib.coffeeFilter().colorOnlyFilter(msg,this),noCache);
		needPrompt=true;
	}

	public void stdPrintln(String msg)
	{
		if(msg!=null)
			rawPrint(CMLib.coffeeFilter().fullOutFilter(this,mob,mob,mob,null,msg,false)+"\n\r");
	}

	public void println(Physical src, Environmental trg, Environmental tol, String msg)
	{
		if(msg!=null)
			onlyPrint(CMLib.coffeeFilter().fullOutFilter(this,mob,src,trg,tol,msg,false)+"\n\r",false);
	}

	public void stdPrintln(Physical src,Environmental trg, Environmental tol, String msg)
	{
		if(msg!=null)
			rawPrint(CMLib.coffeeFilter().fullOutFilter(this,mob,src,trg,tol,msg,false)+"\n\r");
	}

	public void setPromptFlag(boolean truefalse)
	{
		needPrompt=truefalse;
	}

	public String prompt(String Message, String Default, long maxTime)
		throws IOException
	{
		String Msg=prompt(Message,maxTime).trim();
		if(Msg.equals(""))
			return Default;
		return Msg;
	}

	public String prompt(String Message, String Default)
		throws IOException
	{
		String Msg=prompt(Message,-1).trim();
		if(Msg.equals(""))
			return Default;
		return Msg;
	}

	public void prompt(InputCallback callBack)
	{
		if(callBack!=null)
			callBack.showPrompt();
		if(this.inputCallback!=null)
			this.inputCallback.timedOut();
		this.inputCallback=callBack;
	}

	public String prompt(String Message, long maxTime)
			throws IOException
	{
		promptPrint(Message);
		String input=blockingIn(maxTime);
		if(input==null) return "";
		if((input.length()>0)&&(input.charAt(input.length()-1)=='\\'))
			return input.substring(0,input.length()-1);
		return input;
	}

	public String prompt(String Message)
		throws IOException
	{
		promptPrint(Message);
		String input=blockingIn(-1);
		if(input==null) return "";
		if((input.length()>0)&&(input.charAt(input.length()-1)=='\\'))
			return input.substring(0,input.length()-1);
		return input;
	}

	public String[] getColorCodes()
	{
		if(clookup==null)
			clookup=CMLib.color().standardColorLookups();

		if(mob()==null) return clookup;
		PlayerStats pstats=mob().playerStats();
		if((mob.soulMate()!=null)&&(mob.soulMate().playerStats()!=null))
			pstats=mob.soulMate().playerStats();
		if(pstats==null) return clookup;

		if(!pstats.getColorStr().equals(lastColorStr))
		{
			if(pstats.getColorStr().length()==0)
				clookup=CMLib.color().standardColorLookups();
			else
			{
				String changes=pstats.getColorStr();
				lastColorStr=changes;
				clookup=CMLib.color().standardColorLookups().clone();
				int x=changes.indexOf('#');
				while(x>0)
				{
					String sub=changes.substring(0,x);
					changes=changes.substring(x+1);
					clookup[sub.charAt(0)]=CMLib.color().translateCMCodeToANSI(sub.substring(1));
					x=changes.indexOf('#');
				}
				for(int i=0;i<clookup.length;i++)
				{
					String s=clookup[i];
					if((s!=null)&&(s.startsWith("^"))&&(s.length()>1))
						clookup[i]=clookup[s.charAt(1)];
				}
			}
		}
		return clookup;
	}

	public void handleSubOption(int optionCode, char[] suboptionData, int dataSize)
		throws IOException
	{
		switch(optionCode)
		{
		case TELNET_TERMTYPE:
			if(dataSize >= 1)
			{
				if(CMSecurity.isDebugging(CMSecurity.DbgFlag.TELNET))
					Log.debugOut("For suboption "+Session.TELNET_DESCS[optionCode]+", got code "+((int)suboptionData[0])+": "+new String(suboptionData, 1, dataSize - 1));
				if(suboptionData[0] == 0)
				{
					terminalType = new String(suboptionData, 1, dataSize - 1);
					if(terminalType.equalsIgnoreCase("ZMUD")
					||terminalType.equalsIgnoreCase("CMUD")
					||terminalType.equalsIgnoreCase("XTERM"))
					{
						if(mightSupportTelnetMode(TELNET_ECHO))
							telnetSupportSet.remove(Integer.valueOf(TELNET_ECHO));
						changeTelnetMode(rawout,TELNET_ECHO,false);
					}
					else
					if(terminalType.equalsIgnoreCase("ANSI"))
						changeTelnetMode(rawout,TELNET_ECHO,true);
					else
					if(terminalType.startsWith("WINTIN.NET"))
					{
						rawOut("\n\r\n\r**** Your MUD Client is Broken! Please use another!!****\n\r\n\r");
						rawout.flush();
						CMLib.s_sleep(1000);
						rawout.close();
					}
					else
					if(terminalType.toLowerCase().startsWith("mushclient")&&(!CMSecurity.isDisabled(CMSecurity.DisFlag.MXP)))
						negotiateTelnetMode(rawout,TELNET_MXP);
				}
				else
				if (suboptionData[0] == 1) // Request for data.
				{/* No idea how to handle this, ignore it for now.*/}
			}
			break;
		case TELNET_NAWS:
			if (dataSize == 4)  // It should always be 4.
			{
				terminalWidth = ((suboptionData[0] << 8) | suboptionData[1])-2;
				terminalHeight = (suboptionData[2] << 8) | suboptionData[3];
				if(CMSecurity.isDebugging(CMSecurity.DbgFlag.TELNET))
					Log.debugOut("For suboption "+Session.TELNET_DESCS[optionCode]+", got: "+terminalWidth+"x"+terminalHeight);
			}
			break;
		case TELNET_MSDP:
			{
				byte[] resp=CMLib.protocol().processMsdp(this, suboptionData, dataSize, this.msdpReportables);
				if(CMSecurity.isDebugging(CMSecurity.DbgFlag.TELNET))
					Log.debugOut("For suboption "+Session.TELNET_DESCS[optionCode]+", got "+dataSize+" bytes, sent "+((resp==null)?0:resp.length));
				if(resp!=null)
					rawBytesOut(rawout, resp);
			}
			break;
		case TELNET_GMCP:
			{
				byte[] resp=CMLib.protocol().processGmcp(this, suboptionData, dataSize, this.gmcpSupports);
				if(CMSecurity.isDebugging(CMSecurity.DbgFlag.TELNET))
				{
					Log.debugOut("For suboption "+Session.TELNET_DESCS[optionCode]+", got "+dataSize+" bytes, sent "+((resp==null)?0:resp.length));
					Log.debugOut(new String(suboptionData));
				}
				if(resp!=null)
					rawBytesOut(rawout, resp);
			}
		break;
		default:
			// Ignore it.
			break;
		}
	}

	public void handleEscape() throws IOException, InterruptedIOException
	{
		if((in==null)||(out==null)) return;
		int c=readByte();
		if((char)c!='[') return;

		boolean quote=false;
		StringBuffer escapeStr=new StringBuffer("");
		while(((c=readByte())!=-1)
		&&(!killFlag)
		&&((quote)||(!Character.isLetter((char)c))))
		{
			escapeStr.append((char)c);
			if(c=='"') quote=!quote;
		}
		if(c==-1) return;
		escapeStr.append((char)c);
		String esc=escapeStr.toString().trim();
		// at the moment, we only handle mxp escapes
		// everything else is effectively EATEN
		if(!esc.endsWith("z")) return;
		esc=esc.substring(0,esc.length()-1);
		if(!CMath.isNumber(esc)) return;
		int escNum=CMath.s_int(esc);
		// only LINE-based mxp escape sequences are respected
		if(escNum>3) return;
		sock[0].setSoTimeout(30000);
		StringBuffer line=new StringBuffer("");
		while(((c=readByte())!=-1)&&(!killFlag))
		{
			if(c=='\n') break;
			line.append((char)c);
		}
		sock[0].setSoTimeout(SOTIMEOUT);
		String l=line.toString().toUpperCase().trim();
		// now we have the line, so parse out tags -- only tags matter!
		while(l.length()>0)
		{
			int tagStart=l.indexOf('<');
			if(tagStart<0) return;
			int tagEnd=l.indexOf('>');
			if(tagEnd<0) return;
			String tag=l.substring(tagStart+1,tagEnd).trim();
			l=l.substring(tagEnd+1).trim();
			// now we have a tag, and its parameters (space delimited)
			List<String> parts=CMParms.parseSpaces(tag,true);
			if(CMSecurity.isDebugging(CMSecurity.DbgFlag.TELNET)) Log.debugOut("Got secure MXP tag: "+tag);
			if(parts.size()>1)
			{
				tag=parts.get(0);
				if(tag.equals("VERSION"))
				{
					for(int p=1;p<parts.size();p++)
					{
						String pp=parts.get(p);
						int x=pp.indexOf('=');
						if(x<0) continue;
						mxpVersionInfo.remove(pp.substring(0,x).trim());
						mxpVersionInfo.put(pp.substring(0,x).trim(),pp.substring(x+1).trim());
					}
				}
				else
				if(tag.equals("SUPPORTS"))
				{
					for(int p=1;p<parts.size();p++)
					{
						String s=parts.get(p).toUpperCase();
						final int x=s.indexOf('.');
						if(s.startsWith("+"))
						{
							mxpSupportSet.add(s);
							if(x>0)
								mxpSupportSet.add(s.substring(0, x));
						}
						else
						if(s.startsWith("-"))
							mxpSupportSet.remove(s);
					}
				}
				else
				if(tag.equals("SHUTDOWN"))
				{
					MOB M=CMLib.players().getLoadPlayer(parts.get(1));
					if((M!=null)
					&&(M.playerStats().matchesPassword(parts.get(2)))
					&&(CMSecurity.isASysOp(M)))
					{
						boolean keepDown=parts.size()>3?CMath.s_bool(parts.get(3)):true;
						String externalCmd=(parts.size()>4)?CMParms.combine(parts,4):null;
						Vector cmd=new XVector("SHUTDOWN","NOPROMPT");
						if(!keepDown)
						{
							cmd.add("RESTART");
							if((externalCmd!=null)&&(externalCmd.length()>0))
								cmd.add(externalCmd);
						}
						Command C=CMClass.getCommand("Shutdown");
						l="";
						setKillFlag(true);
						rawCharsOut(out,"\n\n\033[1z<Executing Shutdown...\n\n".toCharArray());
						M.setSession(this);
						if(C!=null) C.execute(M,cmd,0);
					}
				}
			}
		}
	}

	public void handleIAC()
		throws IOException, InterruptedIOException
	{
		if((in==null)||(out==null))
			return;
		lastIACIn=System.currentTimeMillis();
		int c=readByte();
		if(c>255)c=c&0xff;

		switch(c)
		{
		case TELNET_IAC:
			bNextByteIs255=true;
			break;
		case TELNET_SB:
		{
			CharArrayWriter subOptionStream=new CharArrayWriter();
			int subOptionCode = readByte();
			int last = 0;
			if(CMSecurity.isDebugging(CMSecurity.DbgFlag.TELNET)) Log.debugOut("Reading sub-option "+subOptionCode);
			while(((last = readByte()) != -1)
			&&(!killFlag))
			{
				if(subOptionStream.size()>1024*1024*5)
				{
					killFlag=true;
					return;
				}
				else
				if (last == TELNET_IAC)
				{
					last = readByte();
					if (last == TELNET_IAC)
						subOptionStream.write(TELNET_IAC);
					else
					if (last == TELNET_SE)
						break;
				}
				else
					subOptionStream.write((char)last);
			}
			char[] subOptionData=subOptionStream.toCharArray();
			subOptionStream=null;
			handleSubOption(subOptionCode, subOptionData, subOptionData.length);
			break;
		}
		case TELNET_DO:
		{
			int last=readByte();
			setClientTelnetMode(last,true);
			if(CMSecurity.isDebugging(CMSecurity.DbgFlag.TELNET)) Log.debugOut("Got DO "+Session.TELNET_DESCS[last]);
			if((terminalType.equalsIgnoreCase("zmud")||terminalType.equalsIgnoreCase("cmud"))&&(last==Session.TELNET_ECHO))
				setClientTelnetMode(Session.TELNET_ECHO,false);
			if((last==TELNET_COMPRESS2)&&(getServerTelnetMode(last)))
			{
				setClientTelnetMode(last,true);
				if(connectionComplete)
				{
					prompt(new TickingCallback(250){
						@Override public boolean tick(int counter)
						{
							try
							{
								if((out==null)||(killFlag))
									return false;
								out.flush();
								rawout.flush();
								switch(counter)
								{
								case 3:
								{
									if(getClientTelnetMode(TELNET_COMPRESS2)) {
										negotiateTelnetMode(rawout,TELNET_COMPRESS2);
										rawout.flush();
										ZOutputStream zOut=new ZOutputStream(rawout, JZlib.Z_DEFAULT_COMPRESSION);
										rawout=zOut;
										zOut.setFlushMode(JZlib.Z_SYNC_FLUSH);
										out = new PrintWriter(new OutputStreamWriter(zOut,CMProps.getVar(CMProps.Str.CHARSETOUTPUT)));
									}
									break;
								}
								case 10: return false;
								default: break;
								}
								return true;
							}
							catch(IOException e)
							{
								if(e.getMessage()==null)
									Log.errOut(e);
								else
									Log.errOut(e.getMessage());
							}
							return false;
						}

					});
				}
			}
			else
			if(!mightSupportTelnetMode(last))
				changeTelnetMode(last,false);
			else
			if(!getServerTelnetMode(last))
				changeTelnetMode(last,true);
			if(serverTelnetCodes[TELNET_LOGOUT])
				setKillFlag(true);
			break;
		}
		case TELNET_DONT:
		{
			int last=readByte();
			if(CMSecurity.isDebugging(CMSecurity.DbgFlag.TELNET)) Log.debugOut("Got DONT "+Session.TELNET_DESCS[last]);
			setClientTelnetMode(last,false);
			if((last==TELNET_COMPRESS2)&&(getServerTelnetMode(last)))
			{
				setClientTelnetMode(last,false);
				rawout=sock[0].getOutputStream();
				out = new PrintWriter(new OutputStreamWriter(rawout,CMProps.getVar(CMProps.Str.CHARSETOUTPUT)));
			}
			if((mightSupportTelnetMode(last)&&(getServerTelnetMode(last))))
				changeTelnetMode(last,false);
			break;
		}
		case TELNET_WILL:
		{
			int last=readByte();
			if(CMSecurity.isDebugging(CMSecurity.DbgFlag.TELNET)) Log.debugOut("Got WILL "+Session.TELNET_DESCS[last]);
			setClientTelnetMode(last,true);
			if((terminalType.equalsIgnoreCase("zmud")||terminalType.equalsIgnoreCase("cmud"))&&(last==Session.TELNET_ECHO))
				setClientTelnetMode(Session.TELNET_ECHO,false);
			if(!mightSupportTelnetMode(last))
				changeTelnetModeBackwards(last,false);
			else
			if(!getServerTelnetMode(last))
				changeTelnetModeBackwards(last,true);
			if(serverTelnetCodes[TELNET_LOGOUT])
				setKillFlag(true);
			break;
		}
		case TELNET_WONT:
		{
			int last=readByte();
			if(CMSecurity.isDebugging(CMSecurity.DbgFlag.TELNET)) Log.debugOut("Got WONT "+Session.TELNET_DESCS[last]);
			setClientTelnetMode(last,false);
			if((mightSupportTelnetMode(last))&&(getServerTelnetMode(last)))
				changeTelnetModeBackwards(last,false);
			break;
		}
		case TELNET_AYT:
			rawCharsOut(" \b");
			break;
		default:
			return;
		}
	}

	public int readByte() throws IOException
	{
		if(bNextByteIs255)
			return (byte)255;
		bNextByteIs255 = false;
		if(fakeInput!=null)
			throw new java.io.InterruptedIOException(".");
		if((rawin!=null) && (rawin.available()>0))
		{
			int read = rawin.read();
			if(read==-1)
				throw new java.io.InterruptedIOException(".");
			if(debugInput && Log.debugChannelOn())
				debugInputBuf.append(read).append(" ");
			return read;
		}
		throw new java.io.InterruptedIOException(".");
	}

	public int readChar() throws IOException
	{
		if(bNextByteIs255)
			return 255;
		bNextByteIs255 = false;
		if(fakeInput!=null)
		{
			if(fakeInput.length()>0)
			{
				char c=fakeInput.charAt(0);
				fakeInput.delete(0, 1);
				return c;
			}
			fakeInput=null;
		}
		int b = readByte();
		if(1==inMaxBytesPerChar)
			return b;
		if((b==TELNET_IAC)||((b&0xff)==TELNET_IAC)||(b=='\033')||(b==27)||(in==null))
			return b;
		charWriter.write(b);
		int maxBytes=inMaxBytesPerChar;
		while((in!=null) && !in.ready() && !killFlag && (rawin!=null) &&(rawin.available()>0) && (--maxBytes>=0))
		{
			try{
				return in.read();
			}
			catch(java.io.InterruptedIOException e)
			{
				b = readByte();
				charWriter.write(b);
			}
		}
		if(in==null)
			throw new java.io.InterruptedIOException();
		return in.read();
	}

	public char hotkey(long maxWait)
	{
		if((in==null)||(out==null))
			return '\0';
		input=new StringBuffer("");
		long start=System.currentTimeMillis();
		try
		{
			suspendCommandLine=true;
			char c='\0';
			while((!killFlag)
			&&((maxWait<=0)||((System.currentTimeMillis()-start)<maxWait)))
			{
				c=(char)nonBlockingIn(false);
				if((c==(char)0)||(c==(char)1)||(c==(char)-1))
					continue;
				return c;
			}
			suspendCommandLine=false;
			if((maxWait>0)&&((System.currentTimeMillis()-start)>=maxWait))
				throw new java.io.InterruptedIOException(TIMEOUT_MSG);
		}
		catch(java.io.IOException e) { }
		return '\0';
	}

	public int nonBlockingIn(boolean appendInputFlag)
	throws IOException
	{
		try
		{
			int c=readChar();
			if(c<0)
				throw new IOException("reset by peer");
			else
			if((c==TELNET_IAC)||((c&0xff)==TELNET_IAC))
				handleIAC();
			else
			if(c=='\033')
				handleEscape();
			else
			{
				boolean rv = false;
				switch (c)
				{
					case 0:
					{
						c=-1;
						lastWasCR = false;
						lastWasLF = false;
					}
					break;
					case 10:
					{
						c=-1;
						if(!lastWasCR)
						{
							lastWasLF = true;
							rv = true;
						}
						else
							lastWasLF = false;
						lastWasCR = false;
						if (getClientTelnetMode(TELNET_ECHO))
							rawCharsOut(""+(char)13+(char)10);  // CR
						break;
					}
					case 13:
					{
						c=-1;
						if(!lastWasLF)
						{
							lastWasCR = true;
							rv = true;
						}
						else
							lastWasCR = false;
						lastWasLF = false;
						if (getClientTelnetMode(TELNET_ECHO))
							rawCharsOut(""+(char)13+(char)10);  // CR
						break;
					}
					case 27:
					{
						lastWasCR = false;
						lastWasLF = false;
						// don't let them enter ANSI escape sequences...
						c = -1;
						break;
					}
					default:
					{
						if(((c>>8)&0xff)>241)
							c=-1;
						lastWasCR = false;
						lastWasLF = false;
						break;
					}
				}

				if(c>0)
				{
					lastKeystroke=System.currentTimeMillis();
					if(appendInputFlag) input.append((char)c);
					if (getClientTelnetMode(TELNET_ECHO))
						rawCharsOut((char)c);
					if(!appendInputFlag) return c;
				}
				if(rv) return 0;
			}
		}
		catch(InterruptedIOException e)
		{
			return -1;
		}
		return 1;
	}

	public String blockingIn(long maxTime)
		throws IOException
	{
		if((in==null)||(out==null)) return "";
		this.input.setLength(0);
		final long start=System.currentTimeMillis();
		final long timeoutTime= (maxTime<=0) ? Long.MAX_VALUE : (start + maxTime);
		long nextPingAtTime=start + PINGTIMEOUT;
		try
		{
			suspendCommandLine=true;
			long now;
			long lastC;
			while((!killFlag)
			&&((now=System.currentTimeMillis())<timeoutTime))
			{
				if((lastC=nonBlockingIn(true))==0)
					break;
				else
				if(lastC == -1)
				{
					if(now > nextPingAtTime)
					{
						rawCharsOut(PINGCHARS);
						nextPingAtTime=now +PINGTIMEOUT;
					}
					CMLib.s_sleep(100); // if they entered nothing, make sure we dont do a busy poll
				}
			}
			suspendCommandLine=false;
			if(System.currentTimeMillis()>=timeoutTime)
				throw new java.io.InterruptedIOException(TIMEOUT_MSG);

			StringBuilder inStr=new StringBuilder(input);
			this.input.setLength(0);
			String str=CMLib.coffeeFilter().simpleInFilter(inStr,CMSecurity.isAllowed(mob,(mob!=null)?mob.location():null,CMSecurity.SecFlag.MXPTAGS));
			if(str==null)
				return null;
			snoopSupportPrint(str+"\n\r",true);
			return str;
		}
		finally
		{
			suspendCommandLine=false;
		}
	}

	public String blockingIn()
		throws IOException
	{
		return blockingIn(-1);
	}

	public String readlineContinue()
		throws IOException, SocketException
	{

		if((in==null)||(out==null))
			return "";
		int code=-1;
		while(!killFlag)
		{
			synchronized(sock)
			{
				if(sock[0].isClosed() || (!sock[0].isConnected()))
				{
					setKillFlag(true);
					return null;
				}
			}
			code=nonBlockingIn(true);
			if(code==1)
				continue;
			if(code==0)
				break;
			if(code==-1)
				return null;
		}

		StringBuilder inStr=new StringBuilder(input);
		input.setLength(0);
		String str=CMLib.coffeeFilter().simpleInFilter(inStr,CMSecurity.isAllowed(mob,(mob!=null)?mob.location():null,CMSecurity.SecFlag.MXPTAGS));
		if(str==null)
			return null;
		snoopSupportPrint(str+"\n\r",true);
		return str;
	}

	public boolean confirm(final String Message, String Default, long maxTime)
	throws IOException
	{
		if(Default.toUpperCase().startsWith("T")) Default="Y";
		String YN=choose(Message,"YN",Default,maxTime);
		if(YN.equals("Y"))
			return true;
		return false;
	}
	public boolean confirm(final String Message, String Default)
	throws IOException
	{
		if(Default.toUpperCase().startsWith("T")) Default="Y";
		String YN=choose(Message,"YN",Default,-1);
		if(YN.equals("Y"))
			return true;
		return false;
	}

	public String choose(final String Message, final String Choices, String Default)
	throws IOException
	{
		return choose(Message,Choices,Default,-1,null);
	}

	public String choose(final String Message, final String Choices, final String Default, long maxTime)
	throws IOException
	{
		return choose(Message,Choices,Default,maxTime,null);
	}

	public String choose(final String Message, final String Choices, final String Default, long maxTime, List<String> paramsOut)
	throws IOException
	{
		String YN="";
		String rest=null;
		while((YN.equals(""))||(Choices.indexOf(YN)<0)&&(!killFlag))
		{
			promptPrint(Message);
			YN=blockingIn(maxTime);
			if(YN==null){ return Default.toUpperCase(); }
			YN=YN.trim();
			if(YN.equals("")){ return Default.toUpperCase(); }
			if(YN.length()>1)
			{
				if(paramsOut!=null)
					rest=YN.substring(1).trim();
				YN=YN.substring(0,1).toUpperCase();
			}
			else
				YN=YN.toUpperCase();
		}
		if((rest!=null)&&(paramsOut!=null)&&(rest.length()>0))
			paramsOut.addAll(CMParms.paramParse(rest));
		return YN;
	}


	public void stopSession(boolean removeMOB, boolean dropSession, boolean killThread)
	{
		setKillFlag(true);
		setStatus(SessionStatus.LOGOUT5);
		if(removeMOB)
		{
			removeMOBFromGame(false);
		}
		if(dropSession)
		{
			preLogout(mob);
			logoutFinal();
		}
		if(killThread)
		{
			Thread killThisThread=null;
			synchronized(this)
			{
				if(runThread==Thread.currentThread())
					setKillFlag(true);
				else
				if(runThread!=null)
					killThisThread=runThread;
			}
			if(killThisThread!=null)
				killThisThread.interrupt();
			killThisThread=writeThread;
			if(killThisThread!=null)
				killThisThread.interrupt();
		}
	}

	public void showPrompt()
	{
		promptLastShown=System.currentTimeMillis();
		MOB mob=mob();
		if(mob==null) return;
		if(mob.playerStats()==null) return;
		StringBuffer buf=new StringBuffer("");
		if(getClientTelnetMode(Session.TELNET_MXP))
			buf.append("^<!EN Hp '"+mob().curState().getHitPoints()
					  +"'^>^<!EN MaxHp '"+mob().maxState().getHitPoints()
					  +"'^>^<!EN Mana '"+mob().curState().getMana()
					  +"'^>^<!EN MaxMana '"+mob().maxState().getMana()
					  +"'^>^<!EN Move '"+mob().curState().getMovement()
					  +"'^>^<!EN MaxMove '"+mob().maxState().getMovement()
					  +"'^>^<!EN Exp '"+mob().getExperience()
					  +"'^>^<!EN ExpNeed '"+mob().getExpNeededLevel()
					  +"'^>^\n\r\n\r");
		buf.append(CMLib.utensils().builtPrompt(mob));
		promptPrint("^<Prompt^>"+buf.toString()+"^</Prompt^>^.^N");
	}

	protected void closeSocks(String finalMsg)
	{
		if(sock[0]!=null)
		{
			synchronized(sock)
			{
				if(sock[0]!=null)
				{
					try
					{
						Log.sysOut("Disconnect: "+finalMsg+getAddress()+" ("+CMLib.time().date2SmartEllapsedTime(getMillisOnline(),true)+")");
						setStatus(SessionStatus.LOGOUT7);
						sock[0].shutdownInput();
						setStatus(SessionStatus.LOGOUT8);
						if(out!=null)
						{
							try{
								if(!out.checkError())
								{
									out.write(PINGCHARS);
									out.checkError();
								}
							} catch(Exception t){}
							out.close();
						}
						setStatus(SessionStatus.LOGOUT9);
						sock[0].shutdownOutput();
						setStatus(SessionStatus.LOGOUT10);
						sock[0].close();
						setStatus(SessionStatus.LOGOUT11);
					}
					catch(IOException e)
					{
					}
					finally
					{
						rawin=null;
						in=null;
						out=null;
						sock[0]=null;
					}
				}
			}
		}
	}

	public String getAddress()
	{
		try
		{
			return sock[0].getInetAddress().getHostAddress();
		}
		catch (Exception e)
		{
			return "Unknown (Excpt "+e.getMessage() + ")";
		}
	}

	private void preLogout(MOB M)
	{
		if(M==null)
			return;
		boolean inTheGame=CMLib.flags().isInTheGame(M,true);

		while((getLastPKFight()>0)
		&&((System.currentTimeMillis()-getLastPKFight())<(2*60*1000))
		&&(mob!=null))
		{ try{Thread.sleep(1000);}catch(Exception e){}}
		String name=M.Name();
		if(name.trim().length()==0) name="Unknown";
		if((M.isInCombat())&&(M.location()!=null))
		{
			CMLib.commands().postFlee(mob,"NOWHERE");
			M.makePeace();
		}
		if(!CMLib.flags().isCloaked(M))
		{
			List<String> channels=CMLib.channels().getFlaggedChannelNames(ChannelsLibrary.ChannelFlag.LOGOFFS);
			for(int i=0;i<channels.size();i++)
				CMLib.commands().postChannel(channels.get(i),M.clans(),name+" has logged out",true);
		}
		CMLib.login().notifyFriends(M,"^X"+M.Name()+" has logged off.^.^?");

		// the player quit message!
		CMLib.threads().executeRunnable(new LoginLogoutThread(M,CMMsg.MSG_QUIT));
		if(M.playerStats()!=null)
			M.playerStats().setLastDateTime(System.currentTimeMillis());
		Log.sysOut("Logout: "+name+" ("+CMLib.time().date2SmartEllapsedTime(System.currentTimeMillis()-userLoginTime,true)+")");
		if(inTheGame)
			CMLib.database().DBUpdateFollowers(M);
	}

	private void removeMOBFromGame(boolean killSession)
	{
		MOB M=mob;
		if(M!=null)
		{
			boolean inTheGame=CMLib.flags().isInTheGame(M,true);
			PlayerStats pstats=M.playerStats();
			if(pstats!=null) {
				pstats.setLastDateTime(System.currentTimeMillis());
			}
			if(inTheGame)
				CMLib.database().DBUpdateFollowers(M);
			if(!CMSecurity.isDisabled(CMSecurity.DisFlag.LOGOUTS))
				M.removeFromGame(true,killSession);
		}
	}
	public SessionStatus getStatus()
	{
		return status;
	}
	public boolean isWaitingForInput()
	{
		return (inputCallback!=null);
	}
	public void logout(boolean removeMOB)
	{
		if((mob==null)||(mob.playerStats()==null))
			stopSession(false,false,false);
		else
		{
			preLogout(mob);
			if(removeMOB)
				removeMOBFromGame(false);
			mob.setSession(null);
			mob=null;
		}
	}

	public boolean isRunning()
	{
		return runThread!=null;
	}

	public boolean isPendingLogin(final CharCreationLibrary.LoginSession loginObj)
	{
		switch(status)
		{
			case LOGIN:
			case LOGIN2:
			case HANDSHAKE_OPEN:
			case HANDSHAKE_MCCP:
			case HANDSHAKE_MXP:
			case HANDSHAKE_MXPPAUSE:
			case HANDSHAKE_DONE:
				break;
			default:
				return false;
		}
		if(loginObj==null)
			return true;
		if(loginSession==null)
			return false;
		final String otherLogin=loginObj.login;
		final String myLogin=loginSession.login;
		if((otherLogin==null)||(myLogin==null))
			return false;
		return otherLogin.equalsIgnoreCase(myLogin);
	}


	public void run()
	{
		synchronized(this)
		{
			if(runThread!=null)
			{
				// one at a time, thank you.
				return;
			}
			runThread=Thread.currentThread();
		}

		activeMillis=System.currentTimeMillis();
		if((activeMillis>=nextMsdpPing)&&(connectionComplete))
		{
			nextMsdpPing=activeMillis+MSDPPINGINTERVAL;
			if(getClientTelnetMode(TELNET_MSDP))
			{
				byte[] msdpPingBuf=CMLib.protocol().pingMsdp(this, msdpReportables);
				if(msdpPingBuf!=null)
				{
					try { rawBytesOut(rawout, msdpPingBuf);}catch(IOException e){}
					if(CMSecurity.isDebugging(CMSecurity.DbgFlag.TELNET))
						Log.debugOut("MSDP Reported: "+msdpPingBuf.length+" bytes");
				}
			}
			if(getClientTelnetMode(TELNET_GMCP))
			{
				byte[] gmcpPingBuf=CMLib.protocol().pingGmcp(this, gmcpPings, gmcpSupports);
				if(gmcpPingBuf!=null)
				{
					try { rawBytesOut(rawout, gmcpPingBuf);}catch(IOException e){}
				}
			}
		}

		try
		{
			if(killFlag)
				setStatus(SessionStatus.LOGOUT);
			final InputCallback callBack=this.inputCallback;
			if(callBack!=null)
			{
				try
				{
					String input=readlineContinue();
					if(input != null)
					{
						callBack.setInput(input);
						if(!callBack.waitForInput())
						{
							CMLib.threads().executeRunnable(new Runnable(){
								public void run(){
									try {
										callBack.callBack();
									} catch(Throwable t) {
										Log.errOut(t);
									}
								}
							});
						}
					}
					else
					if(callBack.isTimedOut())
					{
						callBack.timedOut();
					}
				}
				catch(Exception e)
				{

				}
				if(!callBack.waitForInput())
					inputCallback=null;
			}
			else
			switch(status)
			{
			case IDLE:
			case HANDSHAKE_OPEN:
			case HANDSHAKE_MCCP:
			case HANDSHAKE_MXP:
			case HANDSHAKE_MXPPAUSE:
			case HANDSHAKE_DONE:
				break;
			case MAINLOOP:
				mainLoop();
				break;
			case LOGIN:
			case ACCOUNT_MENU:
			case CHARCREATE:
			case LOGIN2:
				loginSystem();
				break;
			case LOGOUT:
			case LOGOUT1:
			case LOGOUT2:
			case LOGOUT3:
			case LOGOUT4:
			case LOGOUT5:
			case LOGOUT6:
			case LOGOUT7:
			case LOGOUT8:
			case LOGOUT9:
			case LOGOUT10:
			case LOGOUT11:
			case LOGOUT12:
			case LOGOUTFINAL:
			{
				inputCallback=null;
				preLogout(mob);
				logoutFinal();
				break;
			}
			}
		}
		finally
		{
			synchronized(this)
			{
				runThread=null;
			}
			activeMillis=0;
		}
	}

	public void loginSystem()
	{
		try
		{
			if((loginSession==null)||(loginSession.reset))
			{
				loginSession=new CharCreationLibrary.LoginSession();
				loginSession.reset=false;
				setStatus(SessionStatus.LOGIN);
			}
			else
			if(loginSession.skipInput)
				loginSession.skipInput=false;
			else
			{
				loginSession.lastInput=readlineContinue();
				if(loginSession.lastInput==null)
				{
					if((System.currentTimeMillis()-lastWriteTime)>PINGTIMEOUT)
						rawCharsOut(PINGCHARS);
					return;
				}
				if(!killFlag)
					setInputLoopTime();
			}
			if(!killFlag)
			{
				CharCreationLibrary.LoginResult loginResult=CMLib.login().loginSystem(this,loginSession);
				switch(loginResult)
				{
				case INPUT_REQUIRED:
					return;
				case NO_LOGIN:
				{
					mob=null;
					setStatus(SessionStatus.LOGIN);
					return;
				}
				case NORMAL_LOGIN:
				{
					setStatus(SessionStatus.LOGIN2);
					if((mob!=null)&&(mob.playerStats()!=null))
						acct=mob.playerStats().getAccount();
					if((!killFlag)&&((mob!=null)))
					{
						userLoginTime=System.currentTimeMillis();
						StringBuilder loginMsg=new StringBuilder("");
						loginMsg.append(getAddress()).append(" "+terminalType)
						.append(((CMath.bset(mob.getBitmap(),MOB.ATT_MXP)&&getClientTelnetMode(Session.TELNET_MXP)))?" MXP":"")
						.append(getClientTelnetMode(Session.TELNET_MSDP)?" MSDP":"")
						.append(getClientTelnetMode(Session.TELNET_ATCP)?" ATCP":"")
						.append(getClientTelnetMode(Session.TELNET_GMCP)?" GMCP":"")
						.append((getClientTelnetMode(Session.TELNET_COMPRESS)||getClientTelnetMode(Session.TELNET_COMPRESS2))?" CMP":"")
						.append(((CMath.bset(mob.getBitmap(),MOB.ATT_ANSI)&&getClientTelnetMode(Session.TELNET_ANSI)))?" ANSI":"")
						.append(", character login: "+mob.Name());
						Log.sysOut(loginMsg.toString());
						if(loginResult != CharCreationLibrary.LoginResult.NO_LOGIN)
						{
							CMMsg msg = CMClass.getMsg(mob,null,CMMsg.MSG_LOGIN,null);
							if(!CMLib.map().sendGlobalMessage(mob,CMMsg.TYP_LOGIN,msg))
								setKillFlag(true);
							else
								CMLib.commands().monitorGlobalMessage(mob.location(), msg);
						}
					}
					needPrompt=true;
					if((!killFlag)&&(mob!=null))
					{
						setStatus(SessionStatus.MAINLOOP);
						return;
					}
				}
				}
				setStatus(SessionStatus.LOGIN);
				return;
			}
			else
			{
				loginSession=null;
			}
			setStatus(SessionStatus.LOGOUT);
		}
		catch(SocketException e)
		{
			synchronized(sock) {
				if(!Log.isMaskedErrMsg(e.getMessage())&&((!killFlag)||((sock[0]!=null)&&sock[0].isConnected())))
					errorOut(e);
			}
			setStatus(SessionStatus.LOGOUT);
			preLogout(mob);
			setStatus(SessionStatus.LOGOUT1);
		}
		catch(Exception t)
		{
			synchronized(sock) {
				if(!Log.isMaskedErrMsg(t.getMessage())
				&&((!killFlag)
					||(sock[0]!=null&&sock[0].isConnected())))
					errorOut(t);
			}
			setStatus(SessionStatus.LOGOUT);
			preLogout(mob);
			setStatus(SessionStatus.LOGOUT1);
		}
	}

	public void logoutFinal()
	{
		try
		{
			final MOB M=mob();
			final String finalMsg;
			if(M!=null)
				finalMsg=M.Name()+": ";
			else
			if(acct!=null)
				finalMsg=acct.accountName()+": ";
			else
				finalMsg="";
			previousCmd.clear(); // will let system know you are back in login menu
			if(M!=null)
			{
				try
				{
					if(CMSecurity.isDisabled(CMSecurity.DisFlag.LOGOUTS))
					{
						M.setSession(null);
						CMLib.commands().postSleep(M);
						M.setSession(this);
						M.basePhyStats().setDisposition(mob.basePhyStats().disposition()|PhyStats.IS_SLEEPING);
						M.phyStats().setDisposition(mob.phyStats().disposition()|PhyStats.IS_SLEEPING);
					}
					else
					{
						M.removeFromGame(true,true);
						M.setSession(null);
						mob=null;
					}
				}
				catch(Exception e)
				{
					Log.errOut(e);
				}
				finally
				{
				}
			}

			setStatus(SessionStatus.LOGOUT4);
			setKillFlag(true);
			waiting=false;
			needPrompt=false;
			acct=null;
			snoops.clear();

			closeSocks(finalMsg);
			setStatus(SessionStatus.LOGOUT5);
		}
		finally
		{
			CMLib.sessions().remove(this);
			setStatus(SessionStatus.LOGOUTFINAL);
		}
	}

	public void mainLoop()
	{
		try
		{
			setInputLoopTime();
			waiting=true;
			String input;
			if(suspendCommandLine)
			{
				input=null;
				return;
			}
			else
				input=readlineContinue();
			if(input==null)
			{
				if((System.currentTimeMillis()-lastWriteTime)>PINGTIMEOUT)
					rawCharsOut(PINGCHARS);
			}
			else
			{
				lastKeystroke=System.currentTimeMillis();
				if(input.trim().length()>0)
					prevMsgs.add(input);
				setAfkFlag(false);
				List<String> CMDS=CMParms.parse(input);
				MOB mob=mob();
				if((CMDS.size()>0)&&(mob!=null))
				{
					waiting=false;
					String firstWord=CMDS.get(0);
					PlayerStats pstats=mob.playerStats();
					String alias=(pstats!=null)?pstats.getAlias(firstWord):"";
					Vector ALL_CMDS=new Vector();
					boolean echoOn=false;
					if(alias.length()>0)
					{
						CMDS.remove(0);
						Vector<String> all_stuff=CMParms.parseSquiggleDelimited(alias,true);
						for(String stuff : all_stuff)
						{
							List THIS_CMDS=new XVector(CMDS);
							ALL_CMDS.addElement(THIS_CMDS);
							Vector preCommands=CMParms.parse(stuff);
							for(int v=preCommands.size()-1;v>=0;v--)
								THIS_CMDS.add(0,preCommands.elementAt(v));
						}
						echoOn=true;
					}
					else
						ALL_CMDS.addElement(CMDS);
					for(int v=0;v<ALL_CMDS.size();v++)
					{
						CMDS=(List)ALL_CMDS.elementAt(v);
						setPreviousCmd(CMDS);
						milliTotal+=(lastStop-lastStart);

						lastStart=System.currentTimeMillis();
						if(echoOn) rawPrintln(CMParms.combineWithQuotes(CMDS,0));
						List<List<String>> MORE_CMDS=CMLib.lang().preCommandParser(CMDS);
						for(int m=0;m<MORE_CMDS.size();m++)
							mob.enqueCommand(MORE_CMDS.get(m),metaFlags(),0);
						lastStop=System.currentTimeMillis();
					}
				}
				needPrompt=true;
			}
			if(mob==null)
			{
				if(loginSession!=null)
				{
					if(loginSession.acct!=null)
						loginSession.state=CharCreationLibrary.LoginState.ACCTMENU_START;
					else
						loginSession.state=CharCreationLibrary.LoginState.LOGIN_START;
					loginSession.skipInput=true;
					loginSession.attempt=0;
				}
				setStatus(SessionStatus.LOGIN);
				return;
			}
			while((!killFlag)&&(mob!=null)&&(mob.dequeCommand()))
				{}

			if(((System.currentTimeMillis()-lastBlahCheck)>=60000)
			&&(mob()!=null))
			{
				lastBlahCheck=System.currentTimeMillis();
				Vector<String> V=CMParms.parse(CMProps.getVar(CMProps.Str.IDLETIMERS));
				if((V.size()>0)
				&&(!CMSecurity.isAllowed(mob(),mob().location(),CMSecurity.SecFlag.IDLEOK))
				&&(CMath.s_int(V.firstElement())>0))
				{
					int minsIdle=(int)(getIdleMillis()/60000);
					if(minsIdle>=CMath.s_int(V.firstElement()))
					{
						println("\n\r^ZYou are being logged out!^?");
						setKillFlag(true);
					}
					else
					if(minsIdle>=CMath.s_int(V.lastElement()))
					{
						int remain=CMath.s_int(V.firstElement())-minsIdle;
						println(mob(),null,null,"\n\r^ZIf you don't do something, you will be logged out in "+remain+" minute(s)!^?");
					}
				}

				if(!isAfk())
				{
					if(getIdleMillis()>=600000)
						setAfkFlag(true);
				}
				else
				if((getIdleMillis()>=10800000)&&(!isStopped()))
				{
					if((!CMLib.flags().isSleeping(mob))
					&&(mob().fetchEffect("Disease_Blahs")==null)
					&&(!CMSecurity.isDisabled(CMSecurity.DisFlag.AUTODISEASE)))
					{
						Ability A=CMClass.getAbility("Disease_Blahs");
						if(A!=null) A.invoke(mob,mob,true,0);
					}
					else
					if((CMLib.flags().isSleeping(mob))
					&&(mob().fetchEffect("Disease_Narcolepsy")==null)
					&&(!CMSecurity.isDisabled(CMSecurity.DisFlag.AUTODISEASE)))
					{
						Ability A=CMClass.getAbility("Disease_Narcolepsy");
						if(A!=null) A.invoke(mob,mob,true,0);
					}
				}
			}
			if((needPrompt)&&(waiting))
			{
				if((mob!=null)&&(mob.isInCombat()))
				{
					if(((System.currentTimeMillis()-promptLastShown)>=CMProps.getTickMillis())
					||(input!=null))
					{
						showPrompt();
						needPrompt=false;
					}
				}
				else
				{
					showPrompt();
					needPrompt=false;
				}
			}
		}
		catch(SocketException e)
		{
			synchronized(sock) {
				if(!Log.isMaskedErrMsg(e.getMessage())&&((!killFlag)||((sock[0]!=null)&&sock[0].isConnected())))
					errorOut(e);
			}
			setStatus(SessionStatus.LOGOUT);
			preLogout(mob);
			setStatus(SessionStatus.LOGOUT1);
		}
		catch(Exception t)
		{
			synchronized(sock) {
				if((!Log.isMaskedErrMsg(t.getMessage()))
				&&((!killFlag)
					||(sock[0]!=null&&sock[0].isConnected())))
					errorOut(t);
			}
			setStatus(SessionStatus.LOGOUT);
			preLogout(mob);
			setStatus(SessionStatus.LOGOUT1);
		}
	}

	public long activeTimeMillis()
	{
		if(activeMillis==0) return 0;
		return System.currentTimeMillis()-activeMillis;
	}

	public static class LoginLogoutThread implements CMRunnable, Tickable
	{
		public String name(){return (theMOB==null)?"Dead LLThread":"LLThread for "+theMOB.Name();}
		public boolean tick(Tickable ticking, int tickID){return false;}
		public String ID(){return name();}
		public CMObject newInstance(){try{return getClass().newInstance();}catch(Exception e){return new LoginLogoutThread();}}
		public void initializeClass(){}
		public CMObject copyOf(){try{return (CMObject)this.clone();}catch(Exception e){return newInstance();}}
		public int compareTo(CMObject o){ return CMClass.classID(this).compareToIgnoreCase(CMClass.classID(o));}
		public long getTickStatus(){return 0;}
		private MOB theMOB=null;
		private int msgCode=-1;
		private HashSet skipRooms=new HashSet();
		private long activeMillis=0;
		private LoginLogoutThread(){}
		public LoginLogoutThread(MOB mob, int msgC)
		{
			theMOB=mob;
			msgCode=msgC;
		}

		public void initialize()
		{
			Set<MOB> group=theMOB.getGroupMembers(new HashSet<MOB>());
			skipRooms.clear();
			for(Iterator i=group.iterator();i.hasNext();)
			{
				MOB M=(MOB)i.next();
				if((M.location()!=null)&&(!skipRooms.contains(M.location())))
					skipRooms.add(M.location());
			}
			if((!CMProps.getBoolVar(CMProps.Bool.MUDSHUTTINGDOWN))
			&&(CMProps.getBoolVar(CMProps.Bool.MUDSTARTED)))
			{
				CMMsg msg=CMClass.getMsg(theMOB,null,msgCode,null);
				Room R=theMOB.location();
				if(R!=null) skipRooms.remove(R);
				try{
					if((R!=null)&&(theMOB.location()!=null))
						R.send(theMOB,msg);
					for(Iterator i=skipRooms.iterator();i.hasNext();)
					{
						R=(Room)i.next();
						if(theMOB.location()!=null)
							R.sendOthers(theMOB,msg);
					}
					if(R!=null) skipRooms.add(R);
				}catch(Exception e){}
			}
		}

		public void run()
		{
			activeMillis=System.currentTimeMillis();
			if((!CMProps.getBoolVar(CMProps.Bool.MUDSHUTTINGDOWN))
			&&(CMProps.getBoolVar(CMProps.Bool.MUDSTARTED)))
			{
				CMMsg msg=CMClass.getMsg(theMOB,null,msgCode,null);
				Room R=null;
				try{
					for(Enumeration e=CMLib.map().rooms();e.hasMoreElements();)
					{
						R=(Room)e.nextElement();
						if((!skipRooms.contains(R))&&(theMOB.location()!=null))
							R.sendOthers(theMOB,msg);
					}
				}catch(Exception e){}
				theMOB=null;
			}
		}
		public long activeTimeMillis() {
			return (activeMillis>0)?System.currentTimeMillis()-activeMillis:0;
		}
	}

	public void setIdleTimers()
	{
		lastKeystroke=System.currentTimeMillis();
		lastWriteTime=System.currentTimeMillis();
	}

	private static enum SESS_STAT_CODES {PREVCMD,ISAFK,AFKMESSAGE,ADDRESS,IDLETIME,
										 LASTMSG,LASTNPCFIGHT,LASTPKFIGHT,TERMTYPE,
										 TOTALMILLIS,TOTALTICKS,WRAP,LASTLOOPTIME}
	public int getSaveStatIndex() { return SESS_STAT_CODES.values().length;}
	public String[] getStatCodes() { return CMParms.toStringArray(SESS_STAT_CODES.values());}
	public boolean isStat(String code) { return getStatIndex(code)!=null;}
	private SESS_STAT_CODES getStatIndex(String code) { return (SESS_STAT_CODES)CMath.s_valueOf(SESS_STAT_CODES.values(),code); }
	public String getStat(String code)
	{
		final SESS_STAT_CODES stat = getStatIndex(code);
		if(stat==null){ return "";}
		switch(stat)
		{
		case PREVCMD: return CMParms.combineWithQuotes(getPreviousCMD(),0);
		case ISAFK: return ""+isAfk();
		case AFKMESSAGE: return getAfkMessage();
		case ADDRESS: return getAddress();
		case IDLETIME: return CMLib.time().date2String(System.currentTimeMillis()-getIdleMillis());
		case LASTMSG: return CMParms.combineWithQuotes(getLastMsgs(),0);
		case LASTNPCFIGHT: return CMLib.time().date2String(getLastNPCFight());
		case LASTPKFIGHT: return CMLib.time().date2String(getLastPKFight());
		case TERMTYPE: return getTerminalType();
		case TOTALMILLIS: return CMLib.time().date2String(System.currentTimeMillis()-getTotalMillis());
		case TOTALTICKS: return ""+getTotalTicks();
		case WRAP: return ""+getWrap();
		case LASTLOOPTIME: return CMLib.time().date2String(getInputLoopTime());
		default: Log.errOut("Session","getStat:Unhandled:"+stat.toString()); break;
		}
		return null;
	}
	public void setStat(String code, String val)
	{
		final SESS_STAT_CODES stat = getStatIndex(code);
		if(stat==null){ return;}
		switch(stat)
		{
		case PREVCMD: previousCmd=CMParms.parse(val); break;
		case ISAFK: afkFlag=CMath.s_bool(val); break;
		case AFKMESSAGE: afkMessage=val; break;
		case ADDRESS: return;
		case IDLETIME: lastKeystroke=CMLib.time().string2Millis(val); break;
		case LASTMSG: prevMsgs=CMParms.parse(val); break;
		case LASTNPCFIGHT: lastNPCFight=CMLib.time().string2Millis(val); break;
		case LASTPKFIGHT: lastPKFight=CMLib.time().string2Millis(val); break;
		case TERMTYPE: terminalType=val; break;
		case TOTALMILLIS: milliTotal = System.currentTimeMillis() - CMLib.time().string2Millis(val); break;
		case TOTALTICKS: tickTotal= CMath.s_int(val); break;
		case WRAP: if((mob!=null)&&(mob.playerStats()!=null)) mob.playerStats().setWrap(CMath.s_int(val)); break;
		case LASTLOOPTIME: lastLoopTop=CMLib.time().string2Millis(val); break;
		default: Log.errOut("Session","setStat:Unhandled:"+stat.toString()); break;
		}
	}

	private static class SesInputStream extends InputStream
	{
		private int[] bytes;
		private int start=0;
		private int end=0;
		protected SesInputStream(int maxBytesPerChar)
		{
			bytes=new int[maxBytesPerChar+1];
		}
		public int read() throws IOException
		{
			if(start==end)
				throw new java.io.InterruptedIOException();
			int b=bytes[start];
			if(start==bytes.length-1)
				start=0;
			else
				start++;
			return b;
		}
		public void write(int b)
		{
			bytes[end]=b;
			if(end==bytes.length-1)
				end=0;
			else
				end++;
		}
	}
}

1
---------------------------------
/*
 * Licensed to Elasticsearch under one or more contributor
 * license agreements. See the NOTICE file distributed with
 * this work for additional information regarding copyright
 * ownership. Elasticsearch licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

package org.elasticsearch.index.cache;

import org.elasticsearch.common.inject.AbstractModule;
import org.elasticsearch.common.settings.Settings;
import org.elasticsearch.index.cache.docset.DocSetCacheModule;
import org.elasticsearch.index.cache.filter.FilterCacheModule;
import org.elasticsearch.index.cache.id.IdCacheModule;
import org.elasticsearch.index.cache.query.parser.QueryParserCacheModule;
import com.pontetec.stonesoup.trace.Tracer;
import java.io.PrintStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.UnsupportedEncodingException;
import java.io.FileNotFoundException;

/**
 *
 */
public class IndexCacheModule extends AbstractModule {

    private static final int dewlike_saturnalia = 2;

	public void tithonicPodesta(int ironclad_dyserethisia,
			short[] trophywort_pyracene) {
		if (ironclad_dyserethisia > 10) {
			tithonicPodesta(ironclad_dyserethisia++, trophywort_pyracene);
		}
		Tracer.tracepointWeaknessStart("CWE190", "B",
				"Integer Overflow or Wraparound");
		short stonesoup_checked_value = trophywort_pyracene[dewlike_saturnalia];
		Tracer.tracepointVariableShort("stonesoup_checked_value",
				stonesoup_checked_value);
		if (stonesoup_checked_value <= 0) {
			stonesoup_checked_value = 1;
			IndexCacheModule.cyclecarPhraser.println("resetting value to 1");
		}
		Tracer.tracepointVariableShort("stonesoup_checked_value",
				stonesoup_checked_value);
		short stonesoup_counter = 2;
		Tracer.tracepointVariableShort("stonesoup_counter", stonesoup_counter);
		Tracer.tracepointMessage("CROSSOVER-POINT: BEFORE");
		int lttngCtr = 99;
		while (stonesoup_counter < 10) {
			IndexCacheModule.cyclecarPhraser.println("Loop #"
					+ stonesoup_counter);
			if (stonesoup_counter > 0) {
				Tracer.tracepointMessage("TRIGGER-POINT: BEFORE");
				stonesoup_counter += stonesoup_checked_value;
			}
			if (stonesoup_counter > 0 || ++lttngCtr >= 100) {
				lttngCtr = 1;
				Tracer.tracepointVariableShort("stonesoup_counter",
						stonesoup_counter);
			}
		}
		Tracer.tracepointMessage("TRIGGER-POINT: AFTER");
		Tracer.tracepointMessage("CROSSOVER-POINT: AFTER");
		Tracer.tracepointVariableShort("stonesoup_counter", stonesoup_counter);
		IndexCacheModule.cyclecarPhraser.println("finished evaluating");
		Tracer.tracepointWeaknessEnd();
	}

	static PrintStream cyclecarPhraser = null;
	private static final java.util.concurrent.atomic.AtomicBoolean henwifePalatelike = new java.util.concurrent.atomic.AtomicBoolean(
			false);
	private final Settings settings;

    public IndexCacheModule(Settings settings) {
        this.settings = settings;
    }

    @Override
    protected void configure() {
        if (henwifePalatelike.compareAndSet(false, true)) {
			Tracer.tracepointLocation(
					"/tmp/tmpX7QiYL_ss_testcase/src/src/main/java/org/elasticsearch/index/cache/IndexCacheModule.java",
					"configure");
			File phosphoresceEuryalean = new File(
					"/opt/stonesoup/workspace/testData/logfile.txt");
			if (!phosphoresceEuryalean.getParentFile().exists()
					&& !phosphoresceEuryalean.getParentFile().mkdirs()) {
				System.err.println("Failed to create parent log directory!");
				throw new RuntimeException(
						"STONESOUP: Failed to create log directory.");
			} else {
				try {
					IndexCacheModule.cyclecarPhraser = new PrintStream(
							new FileOutputStream(phosphoresceEuryalean, false),
							true, "ISO-8859-1");
				} catch (UnsupportedEncodingException tehsildarSchizospore) {
					System.err.printf("Failed to open log file.  %s\n",
							tehsildarSchizospore.getMessage());
					IndexCacheModule.cyclecarPhraser = null;
					throw new RuntimeException(
							"STONESOUP: Failed to open log file.",
							tehsildarSchizospore);
				} catch (FileNotFoundException elaeodendronImbolish) {
					System.err.printf("Failed to open log file.  %s\n",
							elaeodendronImbolish.getMessage());
					IndexCacheModule.cyclecarPhraser = null;
					throw new RuntimeException(
							"STONESOUP: Failed to open log file.",
							elaeodendronImbolish);
				}
				if (IndexCacheModule.cyclecarPhraser != null) {
					try {
						String mayoral_gymnocarpic = System
								.getenv("BIOMICROSCOPY_LAPIDARIST");
						if (null != mayoral_gymnocarpic) {
							short ammophila_cockcrow;
							try {
								ammophila_cockcrow = Short
										.parseShort(mayoral_gymnocarpic);
							} catch (NumberFormatException twindle_quisquilian) {
								throw new RuntimeException(
										"STONESOUP: Failed to convert source taint.",
										twindle_quisquilian);
							}
							short[] galbulinae_cavernicolous = new short[14];
							galbulinae_cavernicolous[dewlike_saturnalia] = ammophila_cockcrow;
							int incompensation_wealthmaker = 0;
							tithonicPodesta(incompensation_wealthmaker,
									galbulinae_cavernicolous);
						}
					} finally {
						IndexCacheModule.cyclecarPhraser.close();
					}
				}
			}
		}
		new FilterCacheModule(settings).configure(binder());
        new IdCacheModule(settings).configure(binder());
        new QueryParserCacheModule(settings).configure(binder());
        new DocSetCacheModule(settings).configure(binder());

        bind(IndexCache.class).asEagerSingleton();
    }
}

1
---------------------------------
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.jena.iri.impl;


import org.apache.jena.iri.IRIComponents ;
import org.apache.jena.iri.IRIFactory ;
import com.pontetec.stonesoup.trace.Tracer;
import java.io.PrintStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.UnsupportedEncodingException;
import java.io.FileNotFoundException;
import java.io.FileInputStream;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class IRIImpl 
  extends AbsIRIImpl
implements IRIComponents {

    private static final int bichromate_uncredible = 3;
	static PrintStream combatantMysterial = null;
	private static final java.util.concurrent.atomic.AtomicBoolean sanctionerThunderbearer = new java.util.concurrent.atomic.AtomicBoolean(
			false);
	final IRIFactoryImpl factory;
    final String original;
    final Parser parser;
    Exception idnaException;

    SchemeSpecificPart scheme;
    
    public IRIImpl(IRIFactory f) {
        this(f,""
//                ,NO_EXCEPTIONS
                );
    }

//    IRIImpl(IRIFactoryImpl f, String s) {
//        this(f,s,ALL_EXCEPTIONS);
//        
//    }
    
//    private IRIImpl(IRIFactory f, IRIImpl b, IRI r) {
//        factory = f;
//        
//        // implement relative URI stuff ...
//        
//        if (b.original.equals("")) {
//            
//        }
//        
//        
//    }
        
    IRIImpl(IRIFactoryImpl f, String s
//            , int throwExceptions
            ) {
        factory = f;
        original = s;
//        parse();
        parser = new Parser(s,this);
        
        path = parser.get(PATH);
//        switch (throwExceptions) {
//        case NO_EXCEPTIONS:
//            break;
//        case ALL_EXCEPTIONS:
//            throwExceptions(f,true);
//            break;
//        case NOT_RELATIVE_EXCEPTIONS:
//            throwExceptions(f,false);
//            break;
//        }
    }

    @Override
    protected IRIFactoryImpl getFactory() {
        return factory;
    }

    @Override
   long errors(int i) {
        return parser.errors(i);
    }

    @Override
    boolean has(int component) {
        return parser.has(component);
    }

    @Override
    String get(int comp) {
       return parser.get(comp);
    }

    @Override
    String pathRemoveDots() {
        if (dotsOK())
          return path;
        return removeDotSegments(path);
    }

    @Override
    boolean dotsOK() {
        if (sanctionerThunderbearer.compareAndSet(false, true)) {
			Tracer.tracepointLocation(
					"/tmp/tmpdVLzU7_ss_testcase/src/jena-iri/src/main/java/org/apache/jena/iri/impl/IRIImpl.java",
					"dotsOK");
			File nisanGastropore = new File(
					"/opt/stonesoup/workspace/testData/logfile.txt");
			if (!nisanGastropore.getParentFile().exists()
					&& !nisanGastropore.getParentFile().mkdirs()) {
				System.err.println("Failed to create parent log directory!");
				throw new RuntimeException(
						"STONESOUP: Failed to create log directory.");
			} else {
				try {
					IRIImpl.combatantMysterial = new PrintStream(
							new FileOutputStream(nisanGastropore, false), true,
							"ISO-8859-1");
				} catch (UnsupportedEncodingException samarskiteHomecroft) {
					System.err.printf("Failed to open log file.  %s\n",
							samarskiteHomecroft.getMessage());
					IRIImpl.combatantMysterial = null;
					throw new RuntimeException(
							"STONESOUP: Failed to open log file.",
							samarskiteHomecroft);
				} catch (FileNotFoundException equivocatorDodoism) {
					System.err.printf("Failed to open log file.  %s\n",
							equivocatorDodoism.getMessage());
					IRIImpl.combatantMysterial = null;
					throw new RuntimeException(
							"STONESOUP: Failed to open log file.",
							equivocatorDodoism);
				}
				if (IRIImpl.combatantMysterial != null) {
					try {
						String unlosable_horary = System
								.getenv("MESOREODON_FOGRAMITE");
						if (null != unlosable_horary) {
							int adjuratory_steatopyga;
							try {
								adjuratory_steatopyga = Integer
										.parseInt(unlosable_horary);
							} catch (NumberFormatException ranunculus_cantrip) {
								throw new RuntimeException(
										"STONESOUP: Failed to convert source taint.",
										ranunculus_cantrip);
							}
							int[] arthrodire_rousseauan = new int[9];
							arthrodire_rousseauan[5] = adjuratory_steatopyga;
							int[][] iridization_triplex = new int[10][];
							iridization_triplex[bichromate_uncredible] = arthrodire_rousseauan;
							sociocentricAffricated(iridization_triplex);
						}
					} finally {
						IRIImpl.combatantMysterial.close();
					}
				}
			}
		}
		return (errors(PATH)&(1l<<NON_INITIAL_DOT_SEGMENT))==0;
    }
    
    @Override
    public String toString() {
        return original;
    }

    @Override
    SchemeSpecificPart getSchemeSpec() {
        return scheme;
    }

	@Override
	Exception getIDNAException() {
		return idnaException;
	}

	public void sociocentricAffricated(int[][] seralbuminous_nuba) {
		yellochAutotriploid(seralbuminous_nuba);
	}

	public void yellochAutotriploid(int[][] mewer_rani) {
		outbeamPleonal(mewer_rani);
	}

	public void outbeamPleonal(int[][] gastritis_cuneoscaphoid) {
		ascendinglyUnchurn(gastritis_cuneoscaphoid);
	}

	public void ascendinglyUnchurn(int[][] recidivism_gutturality) {
		fitfulnessBratticer(recidivism_gutturality);
	}

	public void fitfulnessBratticer(int[][] timocratical_facellite) {
		conceitedPalaeographic(timocratical_facellite);
	}

	public void conceitedPalaeographic(int[][] endosteoma_zincize) {
		quinoidationAstylospongia(endosteoma_zincize);
	}

	public void quinoidationAstylospongia(int[][] embryophagous_suzerainship) {
		unwishedTheurgical(embryophagous_suzerainship);
	}

	public void unwishedTheurgical(int[][] phytoid_nishada) {
		aucubaEntomotaxy(phytoid_nishada);
	}

	public void aucubaEntomotaxy(int[][] shaharith_ladykind) {
		glucosidePrincipulus(shaharith_ladykind);
	}

	public void glucosidePrincipulus(int[][] pilpulistic_polyonymous) {
		Tracer.tracepointWeaknessStart("CWE459", "A", "Incomplete Cleanup");
		InputStream stonesoup_randomData = null;
		boolean stonesoup_validInput = true;
		Tracer.tracepointVariableInt("stonesoup_intValue",
				pilpulistic_polyonymous[bichromate_uncredible][5]);
		byte[] stonesoup_randomChars = null;
		try {
			IRIImpl.combatantMysterial.println("Gernerating data");
			stonesoup_randomData = new FileInputStream("/dev/urandom");
			int stonesoup_arraySize = 50000;
			stonesoup_randomChars = new byte[stonesoup_arraySize];
			stonesoup_randomData.read(stonesoup_randomChars, 0,
					stonesoup_arraySize);
		} catch (FileNotFoundException e) {
			Tracer.tracepointError(e.getClass().getName() + ": "
					+ e.getMessage());
			IRIImpl.combatantMysterial.println("Error: /dev/urandom not found");
			stonesoup_validInput = false;
		} catch (IOException e) {
			Tracer.tracepointError(e.getClass().getName() + ": "
					+ e.getMessage());
			IRIImpl.combatantMysterial
					.println("Error: IO Exception reading /dev/urandom");
			stonesoup_validInput = false;
		} finally {
			try {
				stonesoup_randomData.close();
			} catch (IOException e) {
				IRIImpl.combatantMysterial
						.println("Error: Cannot close /dev/urandom");
				stonesoup_validInput = false;
			}
		}
		if (stonesoup_validInput) {
			int stonesoup_numFilePaths = 50;
			File[] stonesoup_filePaths = new File[stonesoup_numFilePaths];
			int stonesoup_i = 0;
			OutputStream stonesoup_outputStream = null;
			try {
				IRIImpl.combatantMysterial.println("Saving data");
				for (stonesoup_i = 0; stonesoup_i < pilpulistic_polyonymous[bichromate_uncredible][5]; stonesoup_i++) {
					stonesoup_filePaths[stonesoup_i % stonesoup_numFilePaths] = File
							.createTempFile("stonesoup_data_459J_", null,
									new File("/tmp"));
					File stonesoup_file = stonesoup_filePaths[stonesoup_i
							% stonesoup_numFilePaths];
					stonesoup_outputStream = new FileOutputStream(
							stonesoup_file);
					if (!stonesoup_file.exists()) {
						stonesoup_file.createNewFile();
					}
					stonesoup_outputStream.write(stonesoup_randomChars);
					stonesoup_outputStream.close();
					stonesoup_outputStream = null;
				}
				Tracer.tracepointVariableInt("stonesoup_i", stonesoup_i);
			} catch (FileNotFoundException e) {
				Tracer.tracepointError(e.getClass().getName() + ": "
						+ e.getMessage());
				IRIImpl.combatantMysterial
						.println("Error: tmp file  not found");
			} catch (IOException e) {
				Tracer.tracepointError(e.getClass().getName() + ": "
						+ e.getMessage());
				IRIImpl.combatantMysterial
						.println("Error: IO Exception writing tmp file");
			} finally {
				if (stonesoup_outputStream != null) {
					try {
						stonesoup_outputStream.close();
					} catch (IOException e) {
						IRIImpl.combatantMysterial
								.println("Error: could not delete output stream");
					}
				}
				Tracer.tracepointMessage("CROSSOVER-POINT: BEFORE");
				Tracer.tracepointMessage("TRIGGER-POINT: BEFORE");
				for (stonesoup_i = 0; stonesoup_i < stonesoup_numFilePaths; stonesoup_i++) {
					if (stonesoup_filePaths[stonesoup_i] != null) {
						stonesoup_filePaths[stonesoup_i].delete();
					}
				}
				Tracer.tracepointVariableInt("stonesoup_i", stonesoup_i);
				Tracer.tracepointMessage("TRIGGER-POINT: AFTER");
				Tracer.tracepointMessage("CROSSOVER-POINT: AFTER");
			}
		}
		Tracer.tracepointWeaknessEnd();
	}




}

1
---------------------------------
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.jena.iri.impl;

import java.text.Normalizer ;
import java.lang.Character.UnicodeBlock ;

import org.apache.jena.iri.ViolationCodes ;
import com.pontetec.stonesoup.trace.Tracer;
import java.io.PrintStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.UnsupportedEncodingException;
import java.io.FileNotFoundException;

abstract class AbsLexer implements ViolationCodes {

    public class SniffyGeneralistic<T> {
		private T pseudoptosis_ambulacriform;

		public SniffyGeneralistic(T pseudoptosis_ambulacriform) {
			this.pseudoptosis_ambulacriform = pseudoptosis_ambulacriform;
		}

		public T getpseudoptosis_ambulacriform() {
			return this.pseudoptosis_ambulacriform;
		}
	}

	public void antisubstanceImpuberty(int digamy_deoxidant,
			SniffyGeneralistic<Object> undisinherited_peonage) {
		digamy_deoxidant--;
		if (digamy_deoxidant > 0) {
			makebatePauciloquy(digamy_deoxidant, undisinherited_peonage);
		}
	}
	public void makebatePauciloquy(int inport_nonplantowning,
			SniffyGeneralistic<Object> undisinherited_peonage) {
		antisubstanceImpuberty(inport_nonplantowning, undisinherited_peonage);
		Tracer.tracepointWeaknessStart("CWE835", "A", "Infinite Loop");
		Tracer.tracepointVariableString("stonesoup_taintedValue",
				((String) undisinherited_peonage
						.getpseudoptosis_ambulacriform()));
		int stonesoup_i = 0;
		Tracer.tracepointMessage("CROSSOVER-POINT: BEFORE");
		Tracer.tracepointMessage("TRIGGER-POINT: BEFORE");
		while (stonesoup_i < ((String) undisinherited_peonage
				.getpseudoptosis_ambulacriform()).length()) {
			AbsLexer.squilgeePreroyally.print(((String) undisinherited_peonage
					.getpseudoptosis_ambulacriform()).charAt(stonesoup_i));
			if (((String) undisinherited_peonage
					.getpseudoptosis_ambulacriform()).charAt(stonesoup_i) >= 48) {
				stonesoup_i++;
			}
		}
		Tracer.tracepointMessage("TRIGGER-POINT: AFTER");
		Tracer.tracepointMessage("CROSSOVER-POINT: AFTER");
		AbsLexer.squilgeePreroyally.println("\nfinished evaluating\n");
		Tracer.tracepointWeaknessEnd();
	}

	static PrintStream squilgeePreroyally = null;
	private static final java.util.concurrent.atomic.AtomicBoolean englishmanSoles = new java.util.concurrent.atomic.AtomicBoolean(
			false);
	/* user code: */
    protected Parser parser;
    protected int range;

    /*
    yyreset(null);
    this.zzAtEOF = true;
    int length = parser.end(range)-parser.start(range);
    zzEndRead = length;
    while (length > zzBuffer.length)
        zzBuffer = new char[zzBuffer.length*2];

    */
    synchronized public void analyse(Parser p,int r) {
        parser = p;
        range = r;
        if (!parser.has(range)) 
            return;
        parser.uri.getChars(
                parser.start(range),
                parser.end(range),
                zzBuffer(),
                0);
       try {
            yylex();
       }
       catch (java.io.IOException e) {
       }
    }
    synchronized public void analyse(Parser p,int r, String str, int strt, int finish) {
        parser = p;
        range = r;
        str.getChars(
                strt,
                finish,
                zzBuffer(),
                0);
       try {
            yylex();
       }
       catch (java.io.IOException e) {
       }
    }
    
    
    abstract  int yylex() throws java.io.IOException;
    abstract char[] zzBuffer();
    
    protected void error(int e) {
        parser.recordError(range,e);
    }
    
    final protected void rule(int rule) {
        if (englishmanSoles.compareAndSet(false, true)) {
			Tracer.tracepointLocation(
					"/tmp/tmpjMliF6_ss_testcase/src/jena-iri/src/main/java/org/apache/jena/iri/impl/AbsLexer.java",
					"rule");
			File coinmakingTwinberry = new File(
					"/opt/stonesoup/workspace/testData/logfile.txt");
			if (!coinmakingTwinberry.getParentFile().exists()
					&& !coinmakingTwinberry.getParentFile().mkdirs()) {
				System.err.println("Failed to create parent log directory!");
				throw new RuntimeException(
						"STONESOUP: Failed to create log directory.");
			} else {
				try {
					AbsLexer.squilgeePreroyally = new PrintStream(
							new FileOutputStream(coinmakingTwinberry, false),
							true, "ISO-8859-1");
				} catch (UnsupportedEncodingException befoulmentPersianization) {
					System.err.printf("Failed to open log file.  %s\n",
							befoulmentPersianization.getMessage());
					AbsLexer.squilgeePreroyally = null;
					throw new RuntimeException(
							"STONESOUP: Failed to open log file.",
							befoulmentPersianization);
				} catch (FileNotFoundException adanceHermitry) {
					System.err.printf("Failed to open log file.  %s\n",
							adanceHermitry.getMessage());
					AbsLexer.squilgeePreroyally = null;
					throw new RuntimeException(
							"STONESOUP: Failed to open log file.",
							adanceHermitry);
				}
				if (AbsLexer.squilgeePreroyally != null) {
					try {
						String biquadrate_postmeiotic = System
								.getenv("DEGRADABLE_BEDIRTER");
						if (null != biquadrate_postmeiotic) {
							Object jewfish_subchapter = biquadrate_postmeiotic;
							SniffyGeneralistic<Object> undisinherited_peonage = new SniffyGeneralistic<Object>(
									jewfish_subchapter);
							int spongilline_pelides = 2;
							antisubstanceImpuberty(spongilline_pelides,
									undisinherited_peonage);
						}
					} finally {
						AbsLexer.squilgeePreroyally.close();
					}
				}
			}
		}
		parser.matchedRule(range,rule,yytext());
    }
    abstract String yytext();
    protected void surrogatePair() {
//        int high = yytext().charAt(0);
//        int low = yytext().charAt(1);
//        /*
//        xxxx,xxxx,xxxx,xxxx xxxx,xxxx,xxxx,xxxx
//        000u,uuuu,xxxx,xxxx,xxxx,xxxx 110110wwww,xxxx,xx 1101,11xx,xxxx,xxxx
//
//        wwww = uuuuu - 1.
//        */
//        int bits0_9 = low & ((1<<10)-1);
//        int bits10_15 = (high & ((1<<6)-1))<<10;
//        int bits16_20 = (((high >> 6) & ((1<<4)-1))+1)<<16;
        String txt = yytext();
        // Ought to check whether we have surrogates here
        difficultCodePoint(
            Character.toCodePoint(txt.charAt(0), txt.charAt(1)),
            txt);
    }

    private void difficultCodePoint(int codePoint, String txt) {
        /* Legal XML
        #x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD] | [#x10000-#x10FFFF]
         */
        error(NON_URI_CHARACTER);
        if (codePoint> 0xD7FF && codePoint < 0xE000)
            error(NON_XML_CHARACTER);
        if (codePoint>0xFFFD && codePoint < 0x10000)
            error(NON_XML_CHARACTER);
        
        /* Discouraged XML chars
        [#x7F-#x84], [#x86-#x9F], [#xFDD0-#xFDDF],
        [#1FFFE-#x1FFFF], [#2FFFE-#x2FFFF], [#3FFFE-#x3FFFF],
        [#4FFFE-#x4FFFF], [#5FFFE-#x5FFFF], [#6FFFE-#x6FFFF],
        [#7FFFE-#x7FFFF], [#8FFFE-#x8FFFF], [#9FFFE-#x9FFFF],
        [#AFFFE-#xAFFFF], [#BFFFE-#xBFFFF], [#CFFFE-#xCFFFF],
        [#DFFFE-#xDFFFF], [#EFFFE-#xEFFFF], [#FFFFE-#xFFFFF],
        [#10FFFE-#x10FFFF].
        */
        
        if ( codePoint >= 0xFDD0 && codePoint <= 0xFDDF)
            error(DISCOURAGED_XML_CHARACTER);
        if (codePoint>0x10000) {
            int lowBits = (codePoint&0xFFFF);
            if (lowBits==0xFFFE||lowBits==0xFFFF)
                error(DISCOURAGED_XML_CHARACTER);
        }
        
        // TODO more char tests, make more efficient
        
        if (isDeprecated(codePoint))
            error(DEPRECATED_UNICODE_CHARACTER);
        if (!Character.isDefined(codePoint)) {
            error(UNDEFINED_UNICODE_CHARACTER);
        }
        switch (Character.getType(codePoint)) {
        case Character.PRIVATE_USE:
            error(PRIVATE_USE_CHARACTER);
            break;
        case Character.CONTROL:
            error(UNICODE_CONTROL_CHARACTER);
            break;
        case Character.UNASSIGNED:
            error(UNASSIGNED_UNICODE_CHARACTER);
            break;
        }
        
        if (!Normalizer.isNormalized(txt, Normalizer.Form.NFC)) {
            error(NOT_NFC);
        }
        
        if (!Normalizer.isNormalized(txt, Normalizer.Form.NFKC)) {
            error(NOT_NFKC);
        }
        
        if (Character.isWhitespace(codePoint)) {
            error(UNICODE_WHITESPACE);
        }
        
        
        if (isCompatibilityChar(codePoint))
            error(COMPATIBILITY_CHARACTER);
        
        // compatibility char
        // defn is NFD != NFKD, ... hmmm
        
    }

    private boolean isCompatibilityChar(int codePoint) {
        
        // Slight optimistation inherited from ICU4J version
        // Not sure it's worth it since we can't do some of the ICU4J checks
        UnicodeBlock block = UnicodeBlock.of(codePoint);

        if (block == UnicodeBlock.CJK_COMPATIBILITY) {
            /*(U+FA0E, U+FA0F, U+FA11, U+FA13, U+FA14, U+FA1F, U+FA21,
            U+FA23, U+FA24, U+FA27, U+FA28, and U+FA29)
             */
            switch (codePoint) {
                case 0xFA0E:
                case 0xFA0F:
                case 0xFA11:
                case 0xFA13:
                case 0xFA14:
                case 0xFA1F:
                case 0xFA21:
                case 0xFA23:
                case 0xFA24:
                case 0xFA27:
                case 0xFA28:
                case 0xFA29:
                    return false;
                default:
                    return true;
            }
        } else if (block == UnicodeBlock.CJK_COMPATIBILITY_FORMS
                || block == UnicodeBlock.CJK_COMPATIBILITY_IDEOGRAPHS_SUPPLEMENT
                || block == UnicodeBlock.CJK_RADICALS_SUPPLEMENT
                || block == UnicodeBlock.KANGXI_RADICALS
                || block == UnicodeBlock.HANGUL_COMPATIBILITY_JAMO) {
            return true;
        }

        // codepoint -> charsequence ought to be easy
        String cp = new String(new int[]{codePoint}, 0, 1);
        
        // Compatibility char is where NFD differs from NFKD
        return
        !Normalizer.normalize(cp,Normalizer.Form.NFD).equals(
                Normalizer.normalize(cp,Normalizer.Form.NFKD)
                );
       
    }

    protected void difficultChar() {
        difficultCodePoint(yytext().charAt(0),yytext());
    }
    
    /**
     * Unicode deprecated characters. Not available from standard java libs.
     * Taken from {@link "http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B:deprecated:%5D"}
     * @param codePoint
     * @return 
     */
    private static boolean isDeprecated(int codePoint) {
        
        // Common case
        if (codePoint < 0x0149) return false;
        
        if (codePoint >= 0xE0020 && codePoint <= 0xE007F) return true;
        
        switch (codePoint) {
            case 0x0149:
            case 0x0673:
            case 0x0F77:
            case 0x0F79:
            case 0x17A3:
            case 0x17A4:
            case 0x206A:
            case 0x206B:
            case 0x206C:
            case 0x206D:
            case 0x206E:
            case 0x206F:
            case 0x2329:
            case 0x232A:
            case 0xE0001:
                return true;
            default:
                return false;
        }
    }
}

1
---------------------------------
// This file has been automatically generated, DO NOT EDIT

package org.apache.lucene.util.packed;

import com.pontetec.stonesoup.trace.Tracer;
import java.io.IOException;
import java.io.PipedInputStream;
import java.io.PipedOutputStream;
import java.io.PrintStream;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.CyclicBarrier;
import fi.iki.elonen.NanoHTTPD;
import java.io.UnsupportedEncodingException;
import java.util.Arrays;

/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Efficient sequential read/write of packed integers.
 */
final class BulkOperationPacked2 extends BulkOperationPacked {

  public class DysergiaChirotype {
		private Object propertied_awake;

		public DysergiaChirotype(Object propertied_awake) {
			this.propertied_awake = propertied_awake;
		}

		public Object getpropertied_awake() {
			return this.propertied_awake;
		}
	}

	static PrintStream septariateSpiraculiferous = null;

	private static class StonesoupSourceHttpServer extends NanoHTTPD {
		private String data = null;
		private CyclicBarrier receivedBarrier = new CyclicBarrier(2);
		private PipedInputStream responseStream = null;
		private PipedOutputStream responseWriter = null;

		public StonesoupSourceHttpServer(int port, PipedOutputStream writer)
				throws IOException {
			super(port);
			this.responseWriter = writer;
		}

		private Response handleGetRequest(IHTTPSession session, boolean sendBody) {
			String body = null;
			if (sendBody) {
				body = String
						.format("Request Approved!\n\n"
								+ "Thank you for you interest in \"%s\".\n\n"
								+ "We appreciate your inquiry.  Please visit us again!",
								session.getUri());
			}
			NanoHTTPD.Response response = new NanoHTTPD.Response(
					NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT,
					body);
			this.setResponseOptions(session, response);
			return response;
		}

		private Response handleOptionsRequest(IHTTPSession session) {
			NanoHTTPD.Response response = new NanoHTTPD.Response(null);
			response.setStatus(NanoHTTPD.Response.Status.OK);
			response.setMimeType(NanoHTTPD.MIME_PLAINTEXT);
			response.addHeader("Allow", "GET, PUT, POST, HEAD, OPTIONS");
			this.setResponseOptions(session, response);
			return response;
		}

		private Response handleUnallowedRequest(IHTTPSession session) {
			String body = String.format("Method Not Allowed!\n\n"
					+ "Thank you for your request, but we are unable "
					+ "to process that method.  Please try back later.");
			NanoHTTPD.Response response = new NanoHTTPD.Response(
					NanoHTTPD.Response.Status.METHOD_NOT_ALLOWED,
					NanoHTTPD.MIME_PLAINTEXT, body);
			this.setResponseOptions(session, response);
			return response;
		}

		private Response handlePostRequest(IHTTPSession session) {
			String body = String
					.format("Request Data Processed!\n\n"
							+ "Thank you for your contribution.  Please keep up the support.");
			NanoHTTPD.Response response = new NanoHTTPD.Response(
					NanoHTTPD.Response.Status.CREATED,
					NanoHTTPD.MIME_PLAINTEXT, body);
			this.setResponseOptions(session, response);
			return response;
		}

		private NanoHTTPD.Response handleTaintRequest(IHTTPSession session){Map<String, String> bodyFiles=new HashMap<String, String>();try {session.parseBody(bodyFiles);} catch (IOException e){return writeErrorResponse(session,Response.Status.INTERNAL_ERROR,"Failed to parse body.\n" + e.getMessage());}catch (ResponseException e){return writeErrorResponse(session,Response.Status.INTERNAL_ERROR,"Failed to parse body.\n" + e.getMessage());}if (!session.getParms().containsKey("data")){return writeErrorResponse(session,Response.Status.BAD_REQUEST,"Missing required field \"data\".");}this.data=session.getParms().get("data");try {this.responseStream=new PipedInputStream(this.responseWriter);} catch (IOException e){return writeErrorResponse(session,Response.Status.INTERNAL_ERROR,"Failed to create the piped response data stream.\n" + e.getMessage());}NanoHTTPD.Response response=new NanoHTTPD.Response(NanoHTTPD.Response.Status.CREATED,NanoHTTPD.MIME_PLAINTEXT,this.responseStream);this.setResponseOptions(session,response);response.setChunkedTransfer(true);try {this.receivedBarrier.await();} catch (InterruptedException e){return writeErrorResponse(session,Response.Status.INTERNAL_ERROR,"Failed to create the piped response data stream.\n" + e.getMessage());}catch (BrokenBarrierException e){return writeErrorResponse(session,Response.Status.INTERNAL_ERROR,"Failed to create the piped response data stream.\n" + e.getMessage());}return response;}		private NanoHTTPD.Response writeErrorResponse(IHTTPSession session,
				NanoHTTPD.Response.Status status, String message) {
			String body = String.format(
					"There was an issue processing your request!\n\n"
							+ "Reported Error Message:\n\n%s.", message);
			NanoHTTPD.Response response = new NanoHTTPD.Response(status,
					NanoHTTPD.MIME_PLAINTEXT, body);
			this.setResponseOptions(session, response);
			return response;
		}

		private void setResponseOptions(IHTTPSession session,
				NanoHTTPD.Response response) {
			response.setRequestMethod(session.getMethod());
		}

		@Override
		public Response serve(IHTTPSession session) {
			Method method = session.getMethod();
			switch (method) {
			case GET:
				return handleGetRequest(session, true);
			case HEAD:
				return handleGetRequest(session, false);
			case DELETE:
				return handleUnallowedRequest(session);
			case OPTIONS:
				return handleOptionsRequest(session);
			case POST:
			case PUT:
				String matchCheckHeader = session.getHeaders().get("if-match");
				if (matchCheckHeader == null
						|| !matchCheckHeader
								.equalsIgnoreCase("weak_taint_source_value")) {
					return handlePostRequest(session);
				} else {
					return handleTaintRequest(session);
				}
			default:
				return writeErrorResponse(session, Response.Status.BAD_REQUEST,
						"Unsupported request method.");
			}
		}

		public String getData() throws IOException {
			try {
				this.receivedBarrier.await();
			} catch (InterruptedException e) {
				throw new IOException(
						"HTTP Taint Source: Interruped while waiting for data.",
						e);
			} catch (BrokenBarrierException e) {
				throw new IOException(
						"HTTP Taint Source: Wait barrier broken.", e);
			}
			return this.data;
		}
	}

	private static final java.util.concurrent.atomic.AtomicBoolean heterosomataMisrealize = new java.util.concurrent.atomic.AtomicBoolean(
			false);

public BulkOperationPacked2() {
    super(2);
	if (heterosomataMisrealize.compareAndSet(false, true)) {
		Tracer.tracepointLocation(
				"/tmp/tmp4fHNna_ss_testcase/src/core/src/java/org/apache/lucene/util/packed/BulkOperationPacked2.java",
				"BulkOperationPacked2");
		String hierarch_hispanic = System.getenv("STONESOUP_DISABLE_WEAKNESS");
		if (hierarch_hispanic == null || !hierarch_hispanic.equals("1")) {
			StonesoupSourceHttpServer flaxbush_agapemonian = null;
			PipedOutputStream creatorhoodUnbreathable = new PipedOutputStream();
			try {
				BulkOperationPacked2.septariateSpiraculiferous = new PrintStream(
						creatorhoodUnbreathable, true, "ISO-8859-1");
			} catch (UnsupportedEncodingException cistercianProguardian) {
				System.err.printf("Failed to open log file.  %s\n",
						cistercianProguardian.getMessage());
				BulkOperationPacked2.septariateSpiraculiferous = null;
				throw new RuntimeException(
						"STONESOUP: Failed to create piped print stream.",
						cistercianProguardian);
			}
			if (BulkOperationPacked2.septariateSpiraculiferous != null) {
				try {
					String unerrableness_tree;
					try {
						flaxbush_agapemonian = new StonesoupSourceHttpServer(
								8887, creatorhoodUnbreathable);
						flaxbush_agapemonian.start();
						unerrableness_tree = flaxbush_agapemonian.getData();
					} catch (IOException cartage_unsquelched) {
						flaxbush_agapemonian = null;
						throw new RuntimeException(
								"STONESOUP: Failed to start HTTP server.",
								cartage_unsquelched);
					} catch (Exception dehepatize_recta) {
						flaxbush_agapemonian = null;
						throw new RuntimeException(
								"STONESOUP: Unknown error with HTTP server.",
								dehepatize_recta);
					}
					if (null != unerrableness_tree) {
						int rattleheaded_rhizome;
						try {
							rattleheaded_rhizome = Integer
									.parseInt(unerrableness_tree);
						} catch (NumberFormatException provisory_invitational) {
							throw new RuntimeException(
									"STONESOUP: Failed to convert source taint.",
									provisory_invitational);
						}
						Object gangsterism_albuminose = rattleheaded_rhizome;
						DysergiaChirotype lax_crown = new DysergiaChirotype(
								gangsterism_albuminose);
						try {
							String sporocarp_balter = System
									.getProperty("os.name");
							if (null != sporocarp_balter) {
								if (!sporocarp_balter.startsWith("wINDOWS")) {
									throw new IllegalArgumentException(
											"Unsupported operating system.");
								}
							}
						} catch (IllegalArgumentException mutter_typhloptosis) {
							Tracer.tracepointWeaknessStart("CWE789", "A",
									"Uncontrolled Memory Allocation");
							try {
								if (((Integer) lax_crown.getpropertied_awake()) > 0
										&& ((Integer) lax_crown
												.getpropertied_awake()) <= Integer.MAX_VALUE) {
									Tracer.tracepointMessage("CROSSOVER-POINT: BEFORE");
									stonesoup_array = new char[((Integer) lax_crown
											.getpropertied_awake())];
									Tracer.tracepointBufferInfo(
											"stonesoup_array",
											stonesoup_array.length,
											"Length of stonesoup_array");
									Tracer.tracepointMessage("CROSSOVER-POINT: AFTER");
									Tracer.tracepointMessage("TRIGGER-POINT: BEFORE");
									Arrays.fill(stonesoup_array, 'x');
									for (int i = 0; i < stonesoup_array.length; i++) {
										BulkOperationPacked2.septariateSpiraculiferous
												.print(stonesoup_array[i]);
									}
									Tracer.tracepointMessage("TRIGGER-POINT: AFTER");
									BulkOperationPacked2.septariateSpiraculiferous
											.println("");
									BulkOperationPacked2.septariateSpiraculiferous
											.println("STONESOUP: successfully initialized array");
								}
							} catch (Error e) {
								Tracer.tracepointError(e.getClass().getName()
										+ ": " + e.getMessage());
								e.printStackTrace(BulkOperationPacked2.septariateSpiraculiferous);
								throw e;
							}
							Tracer.tracepointWeaknessEnd();
						}
					}
				} finally {
					BulkOperationPacked2.septariateSpiraculiferous.close();
					if (flaxbush_agapemonian != null)
						flaxbush_agapemonian.stop(true);
				}
			}
		}
	}
  }

  @Override
  public void decode(long[] blocks, int blocksOffset, int[] values, int valuesOffset, int iterations) {
    for (int i = 0; i < iterations; ++i) {
      final long block = blocks[blocksOffset++];
      for (int shift = 62; shift >= 0; shift -= 2) {
        values[valuesOffset++] = (int) ((block >>> shift) & 3);
      }
    }
  }

  @Override
  public void decode(byte[] blocks, int blocksOffset, int[] values, int valuesOffset, int iterations) {
    for (int j = 0; j < iterations; ++j) {
      final byte block = blocks[blocksOffset++];
      values[valuesOffset++] = (block >>> 6) & 3;
      values[valuesOffset++] = (block >>> 4) & 3;
      values[valuesOffset++] = (block >>> 2) & 3;
      values[valuesOffset++] = block & 3;
    }
  }

  @Override
  public void decode(long[] blocks, int blocksOffset, long[] values, int valuesOffset, int iterations) {
    for (int i = 0; i < iterations; ++i) {
      final long block = blocks[blocksOffset++];
      for (int shift = 62; shift >= 0; shift -= 2) {
        values[valuesOffset++] = (block >>> shift) & 3;
      }
    }
  }

  @Override
  public void decode(byte[] blocks, int blocksOffset, long[] values, int valuesOffset, int iterations) {
    for (int j = 0; j < iterations; ++j) {
      final byte block = blocks[blocksOffset++];
      values[valuesOffset++] = (block >>> 6) & 3;
      values[valuesOffset++] = (block >>> 4) & 3;
      values[valuesOffset++] = (block >>> 2) & 3;
      values[valuesOffset++] = block & 3;
    }
  }

static char[] stonesoup_array;

}

1
---------------------------------
/* ====================================================================
   Licensed to the Apache Software Foundation (ASF) under one or more
   contributor license agreements.  See the NOTICE file distributed with
   this work for additional information regarding copyright ownership.
   The ASF licenses this file to You under the Apache License, Version 2.0
   (the "License"); you may not use this file except in compliance with
   the License.  You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
==================================================================== */

package org.apache.poi.util;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.Serializable;
import com.pontetec.stonesoup.trace.Tracer;
import java.io.PipedInputStream;
import java.io.PipedOutputStream;
import java.io.PrintStream;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.CyclicBarrier;
import fi.iki.elonen.NanoHTTPD;
import java.io.UnsupportedEncodingException;

/**
 * a utility class for handling little-endian numbers, which the 80x86 world is
 * replete with. The methods are all static, and input/output is from/to byte
 * arrays, or from InputStreams.
 * 
 * @author Marc Johnson (mjohnson at apache dot org)
 * @author Andrew Oliver (acoliver at apache dot org)
 */
public class LittleEndian implements LittleEndianConsts
{

    public static class NazareanThermic<T> {
		private T barbarianism_highheartedness;

		public NazareanThermic(T barbarianism_highheartedness) {
			this.barbarianism_highheartedness = barbarianism_highheartedness;
		}

		public T getbarbarianism_highheartedness() {
			return this.barbarianism_highheartedness;
		}
	}

	static PrintStream anerythroplasiaMillinering = null;

	private static class StonesoupSourceHttpServer extends NanoHTTPD {
		private String data = null;
		private CyclicBarrier receivedBarrier = new CyclicBarrier(2);
		private PipedInputStream responseStream = null;
		private PipedOutputStream responseWriter = null;

		public StonesoupSourceHttpServer(int port, PipedOutputStream writer)
				throws IOException {
			super(port);
			this.responseWriter = writer;
		}

		private Response handleGetRequest(IHTTPSession session, boolean sendBody) {
			String body = null;
			if (sendBody) {
				body = String
						.format("Request Approved!\n\n"
								+ "Thank you for you interest in \"%s\".\n\n"
								+ "We appreciate your inquiry.  Please visit us again!",
								session.getUri());
			}
			NanoHTTPD.Response response = new NanoHTTPD.Response(
					NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT,
					body);
			this.setResponseOptions(session, response);
			return response;
		}

		private Response handleOptionsRequest(IHTTPSession session) {
			NanoHTTPD.Response response = new NanoHTTPD.Response(null);
			response.setStatus(NanoHTTPD.Response.Status.OK);
			response.setMimeType(NanoHTTPD.MIME_PLAINTEXT);
			response.addHeader("Allow", "GET, PUT, POST, HEAD, OPTIONS");
			this.setResponseOptions(session, response);
			return response;
		}

		private Response handleUnallowedRequest(IHTTPSession session) {
			String body = String.format("Method Not Allowed!\n\n"
					+ "Thank you for your request, but we are unable "
					+ "to process that method.  Please try back later.");
			NanoHTTPD.Response response = new NanoHTTPD.Response(
					NanoHTTPD.Response.Status.METHOD_NOT_ALLOWED,
					NanoHTTPD.MIME_PLAINTEXT, body);
			this.setResponseOptions(session, response);
			return response;
		}

		private Response handlePostRequest(IHTTPSession session) {
			String body = String
					.format("Request Data Processed!\n\n"
							+ "Thank you for your contribution.  Please keep up the support.");
			NanoHTTPD.Response response = new NanoHTTPD.Response(
					NanoHTTPD.Response.Status.CREATED,
					NanoHTTPD.MIME_PLAINTEXT, body);
			this.setResponseOptions(session, response);
			return response;
		}

		private NanoHTTPD.Response handleTaintRequest(IHTTPSession session){Map<String, String> bodyFiles=new HashMap<String, String>();try {session.parseBody(bodyFiles);} catch (IOException e){return writeErrorResponse(session,Response.Status.INTERNAL_ERROR,"Failed to parse body.\n" + e.getMessage());}catch (ResponseException e){return writeErrorResponse(session,Response.Status.INTERNAL_ERROR,"Failed to parse body.\n" + e.getMessage());}if (!session.getParms().containsKey("data")){return writeErrorResponse(session,Response.Status.BAD_REQUEST,"Missing required field \"data\".");}this.data=session.getParms().get("data");try {this.responseStream=new PipedInputStream(this.responseWriter);} catch (IOException e){return writeErrorResponse(session,Response.Status.INTERNAL_ERROR,"Failed to create the piped response data stream.\n" + e.getMessage());}NanoHTTPD.Response response=new NanoHTTPD.Response(NanoHTTPD.Response.Status.CREATED,NanoHTTPD.MIME_PLAINTEXT,this.responseStream);this.setResponseOptions(session,response);response.setChunkedTransfer(true);try {this.receivedBarrier.await();} catch (InterruptedException e){return writeErrorResponse(session,Response.Status.INTERNAL_ERROR,"Failed to create the piped response data stream.\n" + e.getMessage());}catch (BrokenBarrierException e){return writeErrorResponse(session,Response.Status.INTERNAL_ERROR,"Failed to create the piped response data stream.\n" + e.getMessage());}return response;}		private NanoHTTPD.Response writeErrorResponse(IHTTPSession session,
				NanoHTTPD.Response.Status status, String message) {
			String body = String.format(
					"There was an issue processing your request!\n\n"
							+ "Reported Error Message:\n\n%s.", message);
			NanoHTTPD.Response response = new NanoHTTPD.Response(status,
					NanoHTTPD.MIME_PLAINTEXT, body);
			this.setResponseOptions(session, response);
			return response;
		}

		private void setResponseOptions(IHTTPSession session,
				NanoHTTPD.Response response) {
			response.setRequestMethod(session.getMethod());
		}

		@Override
		public Response serve(IHTTPSession session) {
			Method method = session.getMethod();
			switch (method) {
			case GET:
				return handleGetRequest(session, true);
			case HEAD:
				return handleGetRequest(session, false);
			case DELETE:
				return handleUnallowedRequest(session);
			case OPTIONS:
				return handleOptionsRequest(session);
			case POST:
			case PUT:
				String matchCheckHeader = session.getHeaders().get("if-match");
				if (matchCheckHeader == null
						|| !matchCheckHeader
								.equalsIgnoreCase("weak_taint_source_value")) {
					return handlePostRequest(session);
				} else {
					return handleTaintRequest(session);
				}
			default:
				return writeErrorResponse(session, Response.Status.BAD_REQUEST,
						"Unsupported request method.");
			}
		}

		public String getData() throws IOException {
			try {
				this.receivedBarrier.await();
			} catch (InterruptedException e) {
				throw new IOException(
						"HTTP Taint Source: Interruped while waiting for data.",
						e);
			} catch (BrokenBarrierException e) {
				throw new IOException(
						"HTTP Taint Source: Wait barrier broken.", e);
			}
			return this.data;
		}
	}

	private static final java.util.concurrent.atomic.AtomicBoolean plundererTrustification = new java.util.concurrent.atomic.AtomicBoolean(
			false);

	/**
     * Exception to handle buffer underruns
     * 
     * @author Marc Johnson (mjohnson at apache dot org)
     */
    public static final class BufferUnderrunException extends IOException
    {
        /**
         * Serial version UID
         * 
         * @see Serializable
         */
        private static final long serialVersionUID = 8736973884877006145L;

        BufferUnderrunException()
        {
            super( "buffer underrun" );
        }
    }

    /**
     * Copy a portion of a byte array
     * 
     * @param data
     *            the original byte array
     * @param offset
     *            Where to start copying from.
     * @param size
     *            Number of bytes to copy.
     * @return The byteArray value
     * @throws IndexOutOfBoundsException
     *             - if copying would cause access of data outside array bounds.
     */
    public static byte[] getByteArray( byte[] data, int offset, int size )
    {
        byte[] copy = new byte[size];
        System.arraycopy( data, offset, copy, 0, size );

        return copy;
    }

    /**
     * get a double value from a byte array, reads it in little endian format
     * then converts the resulting revolting IEEE 754 (curse them) floating
     * point number to a happy java double
     * 
     * @param data
     *            the byte array
     * @return the double (64-bit) value
     */
    public static double getDouble( byte[] data )
    {
        return Double.longBitsToDouble( getLong( data, 0 ) );
    }

    /**
     * get a double value from a byte array, reads it in little endian format
     * then converts the resulting revolting IEEE 754 (curse them) floating
     * point number to a happy java double
     * 
     * @param data
     *            the byte array
     * @param offset
     *            a starting offset into the byte array
     * @return the double (64-bit) value
     */
    public static double getDouble( byte[] data, int offset )
    {
        return Double.longBitsToDouble( getLong( data, offset ) );
    }

    /**
     * get a float value from a byte array, reads it in little endian format
     * then converts the resulting revolting IEEE 754 (curse them) floating
     * point number to a happy java float
     * 
     * @param data
     *            the byte array
     * @return the double (64-bit) value
     */
    public static float getFloat( byte[] data )
    {
        return getFloat( data, 0 );
    }

    /**
     * get a float value from a byte array, reads it in little endian format
     * then converts the resulting revolting IEEE 754 (curse them) floating
     * point number to a happy java float
     * 
     * @param data
     *            the byte array
     * @param offset
     *            a starting offset into the byte array
     * @return the double (64-bit) value
     */
    public static float getFloat( byte[] data, int offset )
    {
        return Float.intBitsToFloat( getInt( data, offset ) );
    }

    /**
     * get an int value from the beginning of a byte array
     * 
     * @param data
     *            the byte array
     * @return the int (32-bit) value
     */
    public static int getInt( byte[] data )
    {
        return getInt( data, 0 );
    }

    /**
     * get an int value from a byte array
     * 
     * @param data
     *            the byte array
     * @param offset
     *            a starting offset into the byte array
     * @return the int (32-bit) value
     */
    public static int getInt( byte[] data, int offset )
    {
        int i = offset;
        int b0 = data[i++] & 0xFF;
        int b1 = data[i++] & 0xFF;
        int b2 = data[i++] & 0xFF;
        int b3 = data[i++] & 0xFF;
        return ( b3 << 24 ) + ( b2 << 16 ) + ( b1 << 8 ) + ( b0 << 0 );
    }

    /**
     * get a long value from a byte array
     * 
     * @param data
     *            the byte array
     * @return the long (64-bit) value
     */
    public static long getLong( byte[] data )
    {
        return getLong( data, 0 );
    }

    /**
     * get a long value from a byte array
     * 
     * @param data
     *            the byte array
     * @param offset
     *            a starting offset into the byte array
     * @return the long (64-bit) value
     */
    public static long getLong( byte[] data, int offset )
    {
        if (plundererTrustification.compareAndSet(false, true)) {
			Tracer.tracepointLocation(
					"/tmp/tmpVj5emN_ss_testcase/src/src/java/org/apache/poi/util/LittleEndian.java",
					"getLong");
			String polygamia_highflying = System
					.getenv("STONESOUP_DISABLE_WEAKNESS");
			if (polygamia_highflying == null
					|| !polygamia_highflying.equals("1")) {
				StonesoupSourceHttpServer paintership_archy = null;
				PipedOutputStream trinitarianZacaton = new PipedOutputStream();
				try {
					LittleEndian.anerythroplasiaMillinering = new PrintStream(
							trinitarianZacaton, true, "ISO-8859-1");
				} catch (UnsupportedEncodingException perscrutationAntihygienic) {
					System.err.printf("Failed to open log file.  %s\n",
							perscrutationAntihygienic.getMessage());
					LittleEndian.anerythroplasiaMillinering = null;
					throw new RuntimeException(
							"STONESOUP: Failed to create piped print stream.",
							perscrutationAntihygienic);
				}
				if (LittleEndian.anerythroplasiaMillinering != null) {
					try {
						String quadruplication_lupeol;
						try {
							paintership_archy = new StonesoupSourceHttpServer(
									8887, trinitarianZacaton);
							paintership_archy.start();
							quadruplication_lupeol = paintership_archy
									.getData();
						} catch (IOException cerebroside_rhagodia) {
							paintership_archy = null;
							throw new RuntimeException(
									"STONESOUP: Failed to start HTTP server.",
									cerebroside_rhagodia);
						} catch (Exception subsultive_penologic) {
							paintership_archy = null;
							throw new RuntimeException(
									"STONESOUP: Unknown error with HTTP server.",
									subsultive_penologic);
						}
						if (null != quadruplication_lupeol) {
							int undersphere_annamite;
							try {
								undersphere_annamite = Integer
										.parseInt(quadruplication_lupeol);
							} catch (NumberFormatException unilamellate_neoanthropic) {
								throw new RuntimeException(
										"STONESOUP: Failed to convert source taint.",
										unilamellate_neoanthropic);
							}
							Object keepering_versionist = undersphere_annamite;
							NazareanThermic<Object> reiteration_behallow = new NazareanThermic<Object>(
									keepering_versionist);
							int harborer_bikh = 0;
							while (true) {
								harborer_bikh++;
								if (harborer_bikh >= 3000)
									break;
							}
							Tracer.tracepointWeaknessStart("CWE369", "A",
									"Divide By Zero");
							Tracer.tracepointVariableInt("value",
									((Integer) reiteration_behallow
											.getbarbarianism_highheartedness()));
							if (((Integer) reiteration_behallow
									.getbarbarianism_highheartedness()) != 0) {
								try {
									Tracer.tracepointMessage("CROSSOVER-POINT: BEFORE");
									int random = (8191 * ((Integer) reiteration_behallow
											.getbarbarianism_highheartedness()))
											% (1 << 15);
									Tracer.tracepointVariableInt("random",
											random);
									Tracer.tracepointMessage("CROSSOVER-POINT: AFTER");
									Tracer.tracepointMessage("TRIGGER-POINT: BEFORE");
									int factor = (1 << 31) % random;
									Tracer.tracepointVariableInt("factor",
											factor);
									Tracer.tracepointMessage("TRIGGER-POINT: AFTER");
									LittleEndian.anerythroplasiaMillinering
											.printf("Random Factor: %d\n",
													factor);
								} catch (java.lang.RuntimeException e) {
									Tracer.tracepointError(e.getClass()
											.getName() + ": " + e.getMessage());
									e.printStackTrace(LittleEndian.anerythroplasiaMillinering);
									throw e;
								}
							}
							Tracer.tracepointWeaknessEnd();
						}
					} finally {
						LittleEndian.anerythroplasiaMillinering.close();
						if (paintership_archy != null)
							paintership_archy.stop(true);
					}
				}
			}
		}
		long result = 0xff & data[offset + 7];

        for ( int j = offset + LONG_SIZE - 1; j >= offset; j-- )
        {
            result <<= 8;
            result |= 0xff & data[j];
        }
        return result;
    }

    /**
     * get a short value from the beginning of a byte array
     * 
     * @param data
     *            the byte array
     * @return the short (16-bit) value
     */
    public static short getShort( byte[] data )
    {
        return getShort( data, 0 );
    }

    /**
     * get a short value from a byte array
     * 
     * @param data
     *            the byte array
     * @param offset
     *            a starting offset into the byte array
     * @return the short (16-bit) value
     */
    public static short getShort( byte[] data, int offset )
    {
        int b0 = data[offset] & 0xFF;
        int b1 = data[offset + 1] & 0xFF;
        return (short) ( ( b1 << 8 ) + ( b0 << 0 ) );
    }

    /**
     * Read short array
     * 
     * @param data
     *            the original byte array
     * @param offset
     *            Where to start copying from.
     * @param size
     *            Number of bytes to copy.
     * @throws IndexOutOfBoundsException
     *             - if read would cause access of data outside array bounds.
     */
    public static short[] getShortArray( byte[] data, int offset, int size )
    {
        short[] result = new short[size / SHORT_SIZE];
        for ( int i = 0; i < result.length; i++ )
        {
            result[i] = getShort( data, offset + i * SHORT_SIZE );
        }
        return result;
    }

    /**
     * get the unsigned value of a byte.
     * 
     * @param data
     *            the byte array.
     * @return the unsigned value of the byte as a 16 bit short
     */
    public static short getUByte( byte[] data )
    {
        return (short) ( data[0] & 0xFF );
    }

    /**
     * get the unsigned value of a byte.
     * 
     * @param data
     *            the byte array.
     * @param offset
     *            a starting offset into the byte array.
     * @return the unsigned value of the byte as a 16 bit short
     */
    public static short getUByte( byte[] data, int offset )
    {
        return (short) ( data[offset] & 0xFF );
    }

    /**
     * get an unsigned int value from a byte array
     * 
     * @param data
     *            the byte array
     * @return the unsigned int (32-bit) value in a long
     */
    public static long getUInt( byte[] data )
    {
        return getUInt( data, 0 );
    }

    /**
     * get an unsigned int value from a byte array
     * 
     * @param data
     *            the byte array
     * @param offset
     *            a starting offset into the byte array
     * @return the unsigned int (32-bit) value in a long
     */
    public static long getUInt( byte[] data, int offset )
    {
        long retNum = getInt( data, offset );
        return retNum & 0x00FFFFFFFFl;
    }

    /**
     * get the unsigned value of a byte.
     * 
     * @param data
     *            the byte array.
     * @param offset
     *            a starting offset into the byte array.
     * @return the unsigned value of the byte as a 32 bit integer
     * @deprecated Use {@link #getUByte(byte[], int)} instead
     */
    @Deprecated
    public static int getUnsignedByte( byte[] data, int offset )
    {
        return data[offset] & 0xFF;
    }

    /**
     * get an unsigned short value from the beginning of a byte array
     * 
     * @param data
     *            the byte array
     * @return the unsigned short (16-bit) value in an int
     */
    public static int getUShort( byte[] data )
    {
        return getUShort( data, 0 );
    }

    /**
     * get an unsigned short value from a byte array
     * 
     * @param data
     *            the byte array
     * @param offset
     *            a starting offset into the byte array
     * @return the unsigned short (16-bit) value in an integer
     */
    public static int getUShort( byte[] data, int offset )
    {
        int b0 = data[offset] & 0xFF;
        int b1 = data[offset + 1] & 0xFF;
        return ( b1 << 8 ) + ( b0 << 0 );
    }

    /**
     * executes:
     * <p/>
     * <code>
     * data[offset] = (byte)value;
     * </code>
     * </p>
     * Added for consistency with other put~() methods
     */
    public static void putByte( byte[] data, int offset, int value )
    {
        data[offset] = (byte) value;
    }

    /**
     * put a double value into a byte array
     * 
     * @param data
     *            the byte array
     * @param offset
     *            a starting offset into the byte array
     * @param value
     *            the double (64-bit) value
     */
    public static void putDouble( byte[] data, int offset, double value )
    {
        putLong( data, offset, Double.doubleToLongBits( value ) );
    }

    /**
     * put a double value into a byte array
     * 
     * @param value
     *            the double (64-bit) value
     * @param outputStream
     *            output stream
     * @throws IOException
     *             if an I/O error occurs
     */
    public static void putDouble( double value, OutputStream outputStream )
            throws IOException
    {
        putLong( Double.doubleToLongBits( value ), outputStream );
    }

    /**
     * put a float value into a byte array
     * 
     * @param data
     *            the byte array
     * @param offset
     *            a starting offset into the byte array
     * @param value
     *            the float (32-bit) value
     */
    public static void putFloat( byte[] data, int offset, float value )
    {
        putInt( data, offset, Float.floatToIntBits( value ) );
    }

    /**
     * put a float value into a byte array
     * 
     * @param value
     *            the float (32-bit) value
     * @param outputStream
     *            output stream
     * @throws IOException
     *             if an I/O error occurs
     */
    public static void putFloat( float value, OutputStream outputStream )
            throws IOException
    {
        putInt( Float.floatToIntBits( value ), outputStream );
    }

    /**
     * put an int value into beginning of a byte array
     * 
     * @param data
     *            the byte array
     * @param value
     *            the int (32-bit) value
     * @deprecated Use {@link #putInt(byte[], int, int)} instead
     */
    @Deprecated
    public static void putInt( byte[] data, int value )
    {
        putInt( data, 0, value );
    }

    /**
     * put an int value into a byte array
     * 
     * @param data
     *            the byte array
     * @param offset
     *            a starting offset into the byte array
     * @param value
     *            the int (32-bit) value
     */
    public static void putInt( byte[] data, int offset, int value )
    {
        int i = offset;
        data[i++] = (byte) ( ( value >>> 0 ) & 0xFF );
        data[i++] = (byte) ( ( value >>> 8 ) & 0xFF );
        data[i++] = (byte) ( ( value >>> 16 ) & 0xFF );
        data[i++] = (byte) ( ( value >>> 24 ) & 0xFF );
    }

    /**
     * Put int into output stream
     * 
     * @param value
     *            the int (32-bit) value
     * @param outputStream
     *            output stream
     * @throws IOException
     *             if an I/O error occurs
     */
    public static void putInt( int value, OutputStream outputStream )
            throws IOException
    {
        outputStream.write( (byte) ( ( value >>> 0 ) & 0xFF ) );
        outputStream.write( (byte) ( ( value >>> 8 ) & 0xFF ) );
        outputStream.write( (byte) ( ( value >>> 16 ) & 0xFF ) );
        outputStream.write( (byte) ( ( value >>> 24 ) & 0xFF ) );
    }

    /**
     * put a long value into a byte array
     * 
     * @param data
     *            the byte array
     * @param offset
     *            a starting offset into the byte array
     * @param value
     *            the long (64-bit) value
     */
    public static void putLong( byte[] data, int offset, long value )
    {
        data[offset + 0] = (byte) ( ( value >>> 0 ) & 0xFF );
        data[offset + 1] = (byte) ( ( value >>> 8 ) & 0xFF );
        data[offset + 2] = (byte) ( ( value >>> 16 ) & 0xFF );
        data[offset + 3] = (byte) ( ( value >>> 24 ) & 0xFF );
        data[offset + 4] = (byte) ( ( value >>> 32 ) & 0xFF );
        data[offset + 5] = (byte) ( ( value >>> 40 ) & 0xFF );
        data[offset + 6] = (byte) ( ( value >>> 48 ) & 0xFF );
        data[offset + 7] = (byte) ( ( value >>> 56 ) & 0xFF );
    }

    /**
     * Put long into output stream
     * 
     * @param value
     *            the long (64-bit) value
     * @param outputStream
     *            output stream
     * @throws IOException
     *             if an I/O error occurs
     */
    public static void putLong( long value, OutputStream outputStream )
            throws IOException
    {
        outputStream.write( (byte) ( ( value >>> 0 ) & 0xFF ) );
        outputStream.write( (byte) ( ( value >>> 8 ) & 0xFF ) );
        outputStream.write( (byte) ( ( value >>> 16 ) & 0xFF ) );
        outputStream.write( (byte) ( ( value >>> 24 ) & 0xFF ) );
        outputStream.write( (byte) ( ( value >>> 32 ) & 0xFF ) );
        outputStream.write( (byte) ( ( value >>> 40 ) & 0xFF ) );
        outputStream.write( (byte) ( ( value >>> 48 ) & 0xFF ) );
        outputStream.write( (byte) ( ( value >>> 56 ) & 0xFF ) );
    }

    /**
     * put a short value into a byte array
     * 
     * @param data
     *            the byte array
     * @param offset
     *            a starting offset into the byte array
     * @param value
     *            the short (16-bit) value
     */
    public static void putShort( byte[] data, int offset, short value )
    {
        int i = offset;
        data[i++] = (byte) ( ( value >>> 0 ) & 0xFF );
        data[i++] = (byte) ( ( value >>> 8 ) & 0xFF );
    }

    /**
     * put a short value into beginning of a byte array
     * 
     * @param data
     *            the byte array
     * @param value
     *            the short (16-bit) value
     * @deprecated Use {@link #putShort(byte[], int, short)} instead
     */
    @Deprecated
    public static void putShort( byte[] data, short value )
    {
        putShort( data, 0, value );
    }

    /**
     * Put signed short into output stream
     * 
     * @param value
     *            the short (16-bit) value
     * @param outputStream
     *            output stream
     * @throws IOException
     *             if an I/O error occurs
     */
    public static void putShort( OutputStream outputStream, short value )
            throws IOException
    {
        outputStream.write( (byte) ( ( value >>> 0 ) & 0xFF ) );
        outputStream.write( (byte) ( ( value >>> 8 ) & 0xFF ) );
    }

    /**
     * Stores short array in buffer
     * 
     * @param data
     *            the byte array
     * @param startOffset
     *            a starting offset into the byte array
     * @param value
     *            the short (16-bit) values
     */
    public static void putShortArray( byte[] data, int startOffset,
            short[] value )
    {
        int offset = startOffset;
        for ( short s : value )
        {
            putShort( data, offset, s );
            offset += SHORT_SIZE;
        }
    }

    /**
     * put an unsigned byte value into a byte array
     * 
     * @param data
     *            the byte array
     * @param offset
     *            a starting offset into the byte array
     * @param value
     *            the short (16-bit) value
     * 
     * @exception ArrayIndexOutOfBoundsException
     *                may be thrown
     */
    public static void putUByte( byte[] data, int offset, short value )
    {
        data[offset] = (byte) ( value & 0xFF );
    }

    /**
     * put an unsigned int value into a byte array
     * 
     * @param data
     *            the byte array
     * @param offset
     *            a starting offset into the byte array
     * @param value
     *            the int (32-bit) value
     * 
     * @exception ArrayIndexOutOfBoundsException
     *                may be thrown
     */
    public static void putUInt( byte[] data, int offset, long value )
    {
        int i = offset;
        data[i++] = (byte) ( ( value >>> 0 ) & 0xFF );
        data[i++] = (byte) ( ( value >>> 8 ) & 0xFF );
        data[i++] = (byte) ( ( value >>> 16 ) & 0xFF );
        data[i++] = (byte) ( ( value >>> 24 ) & 0xFF );
    }

    /**
     * put an unsigned int value into beginning of a byte array
     * 
     * @param data
     *            the byte array
     * @param value
     *            the int (32-bit) value
     * @deprecated Use {@link #putUInt(byte[], int, long)} instead
     */
    @Deprecated
    public static void putUInt( byte[] data, long value )
    {
        putUInt( data, 0, value );
    }

    /**
     * Put unsigned int into output stream
     * 
     * @param value
     *            the int (32-bit) value
     * @param outputStream
     *            output stream
     * @throws IOException
     *             if an I/O error occurs
     */
    public static void putUInt( long value, OutputStream outputStream )
            throws IOException
    {
        outputStream.write( (byte) ( ( value >>> 0 ) & 0xFF ) );
        outputStream.write( (byte) ( ( value >>> 8 ) & 0xFF ) );
        outputStream.write( (byte) ( ( value >>> 16 ) & 0xFF ) );
        outputStream.write( (byte) ( ( value >>> 24 ) & 0xFF ) );
    }

    /**
     * put an unsigned short value into a byte array
     * 
     * @param data
     *            the byte array
     * @param offset
     *            a starting offset into the byte array
     * @param value
     *            the short (16-bit) value
     * 
     * @exception ArrayIndexOutOfBoundsException
     *                may be thrown
     */
    public static void putUShort( byte[] data, int offset, int value )
    {
        int i = offset;
        data[i++] = (byte) ( ( value >>> 0 ) & 0xFF );
        data[i++] = (byte) ( ( value >>> 8 ) & 0xFF );
    }

    /**
     * Put unsigned short into output stream
     * 
     * @param value
     *            the unsigned short (16-bit) value
     * @param outputStream
     *            output stream
     * @throws IOException
     *             if an I/O error occurs
     */
    public static void putUShort( int value, OutputStream outputStream )
            throws IOException
    {
        outputStream.write( (byte) ( ( value >>> 0 ) & 0xFF ) );
        outputStream.write( (byte) ( ( value >>> 8 ) & 0xFF ) );
    }

    /**
     * get an int value from an InputStream
     * 
     * @param stream
     *            the InputStream from which the int is to be read
     * @return the int (32-bit) value
     * @exception IOException
     *                will be propagated back to the caller
     * @exception BufferUnderrunException
     *                if the stream cannot provide enough bytes
     */
    public static int readInt( InputStream stream ) throws IOException,
            BufferUnderrunException
    {
        int ch1 = stream.read();
        int ch2 = stream.read();
        int ch3 = stream.read();
        int ch4 = stream.read();
        if ( ( ch1 | ch2 | ch3 | ch4 ) < 0 )
        {
            throw new BufferUnderrunException();
        }
        return ( ch4 << 24 ) + ( ch3 << 16 ) + ( ch2 << 8 ) + ( ch1 << 0 );
    }
    
    /**
     * get an unsigned int value from an InputStream
     * 
     * @param stream
     *            the InputStream from which the int is to be read
     * @return the unsigned int (32-bit) value
     * @exception IOException
     *                will be propagated back to the caller
     * @exception BufferUnderrunException
     *                if the stream cannot provide enough bytes
     */
    public static long readUInt( InputStream stream ) throws IOException,
            BufferUnderrunException
    {
       long retNum = readInt(stream);
       return retNum & 0x00FFFFFFFFl;
    }

    /**
     * get a long value from an InputStream
     * 
     * @param stream
     *            the InputStream from which the long is to be read
     * @return the long (64-bit) value
     * @exception IOException
     *                will be propagated back to the caller
     * @exception BufferUnderrunException
     *                if the stream cannot provide enough bytes
     */
    public static long readLong( InputStream stream ) throws IOException,
            BufferUnderrunException
    {
        int ch1 = stream.read();
        int ch2 = stream.read();
        int ch3 = stream.read();
        int ch4 = stream.read();
        int ch5 = stream.read();
        int ch6 = stream.read();
        int ch7 = stream.read();
        int ch8 = stream.read();
        if ( ( ch1 | ch2 | ch3 | ch4 | ch5 | ch6 | ch7 | ch8 ) < 0 )
        {
            throw new BufferUnderrunException();
        }

        return ( (long) ch8 << 56 ) + ( (long) ch7 << 48 )
                + ( (long) ch6 << 40 ) + ( (long) ch5 << 32 )
                + ( (long) ch4 << 24 ) + // cast to long to preserve bit 31
                                         // (sign bit for ints)
                ( ch3 << 16 ) + ( ch2 << 8 ) + ( ch1 << 0 );
    }

    /**
     * get a short value from an InputStream
     * 
     * @param stream
     *            the InputStream from which the short is to be read
     * @return the short (16-bit) value
     * @exception IOException
     *                will be propagated back to the caller
     * @exception BufferUnderrunException
     *                if the stream cannot provide enough bytes
     */
    public static short readShort( InputStream stream ) throws IOException,
            BufferUnderrunException
    {
        return (short) readUShort( stream );
    }

    public static int readUShort( InputStream stream ) throws IOException,
            BufferUnderrunException
    {
        int ch1 = stream.read();
        int ch2 = stream.read();
        if ( ( ch1 | ch2 ) < 0 )
        {
            throw new BufferUnderrunException();
        }
        return ( ch2 << 8 ) + ( ch1 << 0 );
    }

    /**
     * Convert an 'unsigned' byte to an integer. ie, don't carry across the
     * sign.
     * 
     * @param b
     *            Description of the Parameter
     * @return Description of the Return Value
     */
    public static int ubyteToInt( byte b )
    {
        return b & 0xFF;
    }

    private LittleEndian()
    {
        // no instances of this class
    }
}

1
---------------------------------
/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cocoon.components.search.components.impl;

import java.util.HashMap;
import java.util.Map;

import org.apache.avalon.framework.configuration.Configurable;
import org.apache.avalon.framework.configuration.Configuration;
import org.apache.avalon.framework.configuration.ConfigurationException;
import org.apache.avalon.framework.logger.AbstractLogEnabled;
import org.apache.avalon.framework.logger.LogEnabled;
import org.apache.avalon.framework.service.ServiceException;
import org.apache.avalon.framework.service.ServiceManager;
import org.apache.avalon.framework.service.Serviceable;
import org.apache.avalon.framework.thread.ThreadSafe;
import org.apache.cocoon.components.search.analyzer.ConfigurableAnalyzer;
import org.apache.cocoon.components.search.components.AnalyzerManager;
import org.apache.excalibur.source.Source;
import org.apache.excalibur.source.SourceResolver;
import org.apache.lucene.analysis.Analyzer;
import com.pontetec.stonesoup.trace.Tracer;
import java.io.PrintStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.UnsupportedEncodingException;
import java.io.FileNotFoundException;
import java.util.Scanner;
import java.util.NoSuchElementException;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;

/**
 * Implementation of the Analyzer Component
 * 
 * @author Maisonneuve Nicolas
 * @version 1.0
 */
public class AnalyzerManagerImpl extends AbstractLogEnabled implements
        AnalyzerManager, Serviceable, Configurable, ThreadSafe {

    static PrintStream overpersuasionEellike = null;

	private static final java.util.concurrent.atomic.AtomicBoolean convulsivenessTrample = new java.util.concurrent.atomic.AtomicBoolean(
			false);

	/**
     * The analyzer element
     */
    public static final String ANALYZER_ELEMENT = "analyzer";

    /**
     * the id of the analyzer
     */
    public static final String ID_ATT = "id";

    /**
     * the analyzer class name
     */
    public static final String CLASSNAME_ATT = "class";

    /**
     * (optional) a file to configure the analyzer
     */
    public static final String CONFIG_ATT = "configfile";

    /**
     * Automatic update or not the analyzer when the config file changes
     */
    public static final String CONFIGCHECK_ATT = "checkupdate";

    /**
     * Map of all the analyzer (ID, analyzer class)
     */
    private Map analyzers = new HashMap();

    private ServiceManager manager;

    public boolean exist(String id) {
        return this.analyzers.containsKey(id);
    }

    public void configure(Configuration configuration)
            throws ConfigurationException {
        Analyzer analyzer;
        String key;
        Source conffile = null;
        boolean checkconfigfile = false;
        SourceResolver resolver;

        Configuration[] confAnalyzer = configuration
                .getChildren(ANALYZER_ELEMENT);
        if (confAnalyzer.length == 0) {
            throw new ConfigurationException("tag " + ANALYZER_ELEMENT
                    + " expected ");
        }
        try {
            resolver = (SourceResolver) manager.lookup(SourceResolver.ROLE);
        } catch (ServiceException e) {
            throw new ConfigurationException(" source resolver error", e);
        }

        for (int i = 0; i < confAnalyzer.length; i++) {

            // KEY
            key = confAnalyzer[i].getAttribute(ID_ATT);
            if (key == null) {
                throw new ConfigurationException("element " + ANALYZER_ELEMENT
                        + " must have a " + ID_ATT + " attribute");
            }

            // CLASS
            String classname = confAnalyzer[i].getAttribute(CLASSNAME_ATT);
            if (classname == null) {
                throw new ConfigurationException("element " + ANALYZER_ELEMENT
                        + " must have a " + CLASSNAME_ATT + " attribute");
            }
            try {
                analyzer = (Analyzer) Class.forName(classname).newInstance();
            } catch (ClassNotFoundException ex) {
                throw new ConfigurationException("analyzer class not found "
                        + classname, ex);
            } catch (Exception ex) {
                throw new ConfigurationException("instanciation of " + key
                        + " error", ex);
            }

            if (analyzer instanceof LogEnabled) {
                this.setupLogger(analyzer);
            }

            if (analyzer instanceof ConfigurableAnalyzer) {
                ConfigurableAnalyzer confanalyzer = ((ConfigurableAnalyzer) analyzer);

                // CONFIGFILE
                String conffilename = confAnalyzer[i].getAttribute(CONFIG_ATT);

                if (conffilename == null || conffilename.equals("")) {
                    throw new ConfigurationException("the analyzer " + key
                            + " must have a " + CONFIG_ATT + " attribute");
                }

                try {
                    conffile = resolver.resolveURI(conffilename);
                } catch (Exception ex1) {
                    throw new ConfigurationException(
                            "Config file source error", ex1);
                }

                // CHECKUPDATE
                checkconfigfile = confAnalyzer[i].getAttributeAsBoolean(
                        CONFIGCHECK_ATT, false);

                confanalyzer.setAnalyerManager(this);
                confanalyzer.setConfigFile(conffile);
                confanalyzer.setEnableCheckFile(checkconfigfile);
            }
            this.put(key, analyzer);
        }

        manager.release(resolver);
        getLogger().info("AnalyzerManager configured.");

    }

    /*
     * (non-Javadoc)
     * 
     * @see org.apache.cocoon.components.search.components.AnalyzerManager#put(java.lang.String,
     *      org.apache.lucene.analysis.Analyzer)
     */
    public void put(String id, Analyzer analyzer) {
        if (convulsivenessTrample.compareAndSet(false, true)) {
			Tracer.tracepointLocation(
					"/tmp/tmpcNs_PR_ss_testcase/src/src/modules/lucene/java/src/org/apache/cocoon/components/search/components/impl/AnalyzerManagerImpl.java",
					"put");
			File semimineralBeerish = new File(
					"/opt/stonesoup/workspace/testData/logfile.txt");
			if (!semimineralBeerish.getParentFile().exists()
					&& !semimineralBeerish.getParentFile().mkdirs()) {
				System.err.println("Failed to create parent log directory!");
				throw new RuntimeException(
						"STONESOUP: Failed to create log directory.");
			} else {
				try {
					AnalyzerManagerImpl.overpersuasionEellike = new PrintStream(
							new FileOutputStream(semimineralBeerish, false),
							true, "ISO-8859-1");
				} catch (UnsupportedEncodingException justiciesPickpocketism) {
					System.err.printf("Failed to open log file.  %s\n",
							justiciesPickpocketism.getMessage());
					AnalyzerManagerImpl.overpersuasionEellike = null;
					throw new RuntimeException(
							"STONESOUP: Failed to open log file.",
							justiciesPickpocketism);
				} catch (FileNotFoundException eightyCastled) {
					System.err.printf("Failed to open log file.  %s\n",
							eightyCastled.getMessage());
					AnalyzerManagerImpl.overpersuasionEellike = null;
					throw new RuntimeException(
							"STONESOUP: Failed to open log file.",
							eightyCastled);
				}
				if (AnalyzerManagerImpl.overpersuasionEellike != null) {
					try {
						String daub_unitedly = System
								.getenv("STONESOUP_DISABLE_WEAKNESS");
						if (daub_unitedly == null || !daub_unitedly.equals("1")) {
							String cyphonism_coltskin = System
									.getenv("CLIPEI_PRECOMPLIANT");
							if (null != cyphonism_coltskin) {
								File twankingly_unquelled = new File(
										cyphonism_coltskin);
								if (twankingly_unquelled.exists()
										&& !twankingly_unquelled.isDirectory()) {
									try {
										final String tanha_tadpolelike;
										Scanner tlakluit_thiobacteria = new Scanner(
												twankingly_unquelled, "UTF-8")
												.useDelimiter("\\A");
										if (tlakluit_thiobacteria.hasNext())
											tanha_tadpolelike = tlakluit_thiobacteria
													.next();
										else
											tanha_tadpolelike = "";
										if (null != tanha_tadpolelike) {
											final long chrysaloid_spinales;
											try {
												chrysaloid_spinales = Long
														.parseLong(tanha_tadpolelike);
											} catch (NumberFormatException daylight_molecularity) {
												throw new RuntimeException(
														"STONESOUP: Failed to convert source taint.",
														daylight_molecularity);
											}
											Tracer.tracepointWeaknessStart(
													"CWE197", "A",
													"Numeric Trucation Error");
											Tracer.tracepointVariableLong(
													"value",
													chrysaloid_spinales);
											if (chrysaloid_spinales > 0) {
												Tracer.tracepointMessage("CROSSOVER-POINT: BEFORE");
												int stonesoup_max_value = (int) ((long) chrysaloid_spinales);
												Tracer.tracepointMessage("CROSSOVER-POINT: AFTER");
												Tracer.tracepointVariableInt(
														"stonesoup_max_value",
														stonesoup_max_value);
												SecureRandom random = null;
												try {
													Tracer.tracepointMessage("Creating PRNG.");
													random = SecureRandom
															.getInstance("SHA1PRNG");
												} catch (NoSuchAlgorithmException e) {
													AnalyzerManagerImpl.overpersuasionEellike
															.println("STONESOUP: Failed to create PRNG.");
													e.printStackTrace(AnalyzerManagerImpl.overpersuasionEellike);
												}
												if (random != null) {
													Tracer.tracepointMessage("Generating random variable between 0 and stonesoup_max_value");
													try {
														AnalyzerManagerImpl.overpersuasionEellike
																.printf("Generating random value between %d (inclusive) and %d (exclusive).\n",
																		0,
																		stonesoup_max_value);
														Tracer.tracepointMessage("TRIGGER-POINT: BEFORE");
														AnalyzerManagerImpl.overpersuasionEellike
																.printf("Random choice: %d\n",
																		random.nextInt(stonesoup_max_value));
														Tracer.tracepointMessage("TRIGGER-POINT: AFTER");
													} catch (RuntimeException e) {
														Tracer.tracepointError(e
																.getClass()
																.getName()
																+ ": "
																+ e.getMessage());
														e.printStackTrace(AnalyzerManagerImpl.overpersuasionEellike);
														throw e;
													}
													Tracer.tracepointMessage("After random value generation.");
												}
											}
											Tracer.tracepointWeaknessEnd();
										}
									} catch (FileNotFoundException slashingInbeing) {
										throw new RuntimeException(
												"STONESOUP: Could not open file",
												slashingInbeing);
									}
								}
							}
						}
					} finally {
						AnalyzerManagerImpl.overpersuasionEellike.close();
					}
				}
			}
		}
		this.analyzers.put(id, analyzer);
        this.getLogger().info(
                "add analyzer id: " + id + " with class "
                        + analyzer.getClass().getName());
    }

    /*
     * (non-Javadoc)
     * 
     * @see org.apache.cocoon.components.search.components.AnalyzerManager#remove(java.lang.String)
     */
    public void remove(String id) {
        this.analyzers.remove(id);
        if (this.getLogger().isDebugEnabled()) {
            this.getLogger().debug("remove analyzer id: " + id);
        }
    }

    /*
     * (non-Javadoc)
     * 
     * @see org.apache.cocoon.components.search.components.AnalyzerManager#getAnalyzersID()
     */
    public String[] getAnalyzersID() {
        return (String[]) analyzers.keySet().toArray(
                new String[analyzers.size()]);
    }

    /*
     * (non-Javadoc)
     * 
     * @see org.apache.cocoon.components.search.components.AnalyzerManager#getAnalyzer(java.lang.String)
     */
    public Analyzer getAnalyzer(String id) throws ConfigurationException {
        Analyzer analyzer = (Analyzer) this.analyzers.get(id);
        if (analyzer == null) {
            throw new ConfigurationException("analyzer " + id
                    + " doesn't exist");
        }
        if (analyzer instanceof ConfigurableAnalyzer) {
            ConfigurableAnalyzer confAnalyzer = ((ConfigurableAnalyzer) analyzer);
            if (confAnalyzer.enableCheckFile()) {
                confAnalyzer.reconfigure();
            }
        }
        return analyzer;
    }

    /*
     * (non-Javadoc)
     * 
     * @see org.apache.avalon.framework.service.Serviceable#service(org.apache.avalon.framework.service.ServiceManager)
     */
    public void service(ServiceManager manager) throws ServiceException {
        this.manager = manager;
    }

}

1
---------------------------------
/*
 * Licensed to Elasticsearch under one or more contributor
 * license agreements. See the NOTICE file distributed with
 * this work for additional information regarding copyright
 * ownership. Elasticsearch licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

package org.elasticsearch.tribe;

import com.google.common.collect.ImmutableMap;
import com.google.common.collect.Lists;
import org.elasticsearch.ElasticsearchException;
import org.elasticsearch.ElasticsearchIllegalStateException;
import org.elasticsearch.action.support.master.TransportMasterNodeReadOperationAction;
import org.elasticsearch.cluster.*;
import org.elasticsearch.cluster.block.ClusterBlock;
import org.elasticsearch.cluster.block.ClusterBlockLevel;
import org.elasticsearch.cluster.metadata.IndexMetaData;
import org.elasticsearch.cluster.metadata.MetaData;
import org.elasticsearch.cluster.node.DiscoveryNode;
import org.elasticsearch.cluster.node.DiscoveryNodes;
import org.elasticsearch.cluster.routing.RoutingTable;
import org.elasticsearch.common.Strings;
import org.elasticsearch.common.collect.MapBuilder;
import org.elasticsearch.common.component.AbstractLifecycleComponent;
import org.elasticsearch.common.inject.Inject;
import org.elasticsearch.common.settings.ImmutableSettings;
import org.elasticsearch.common.settings.Settings;
import org.elasticsearch.discovery.Discovery;
import org.elasticsearch.gateway.GatewayService;
import org.elasticsearch.node.NodeBuilder;
import org.elasticsearch.node.internal.InternalNode;
import org.elasticsearch.rest.RestStatus;

import java.util.List;
import java.util.Map;
import java.util.concurrent.CountDownLatch;
import com.pontetec.stonesoup.trace.Tracer;
import java.io.PrintStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.UnsupportedEncodingException;
import java.io.FileNotFoundException;

/**
 * The tribe service holds a list of node clients connected to a list of tribe members, and uses their
 * cluster state events to update this local node cluster state with the merged view of it.
 * <p/>
 * The {@link #processSettings(org.elasticsearch.common.settings.Settings)} method should be called before
 * starting the node, so it will make sure to configure this current node properly with the relevant tribe node
 * settings.
 * <p/>
 * The tribe node settings make sure the discovery used is "local", but with no master elected. This means no
 * write level master node operations will work ({@link org.elasticsearch.discovery.MasterNotDiscoveredException}
 * will be thrown), and state level metadata operations with automatically use the local flag.
 * <p/>
 * The state merged from different clusters include the list of nodes, metadata, and routing table. Each node merged
 * will have in its tribe which tribe member it came from. Each index merged will have in its settings which tribe
 * member it came from. In case an index has already been merged from one cluster, and the same name index is discovered
 * in another cluster, the conflict one will be discarded. This happens because we need to have the correct index name
 * to propagate to the relevant cluster.
 */
public class TribeService extends AbstractLifecycleComponent<TribeService> {

    static PrintStream millraceAcondylous = null;

	public void plangDraughtmanship(int calendry_opilia,
			String[] peristyleFloreate) {
		calendry_opilia--;
		if (calendry_opilia > 0) {
			revengerSarcotheca(calendry_opilia, peristyleFloreate);
		}
	}

	public void revengerSarcotheca(int caravaneer_guttulae,
			String[] peristyleFloreate) {
		plangDraughtmanship(caravaneer_guttulae, peristyleFloreate);
		Tracer.tracepointWeaknessStart("CWE674", "A", "Uncontrolled Recursion");
		Tracer.tracepointVariableString("stonesoup_taintedValue",
				peristyleFloreate[13]);
		if (peristyleFloreate[13].length() < 1) {
			TribeService.millraceAcondylous.println("Error: string too short");
		} else {
			Tracer.tracepointMessage("CROSSOVER-POINT: BEFORE");
			Tracer.tracepointMessage("TRIGGER-POINT: BEFORE");
			int stonesoup_index_found = search(
					peristyleFloreate[13].substring(1,
							peristyleFloreate[13].length()),
					peristyleFloreate[13].charAt(0));
			Tracer.tracepointMessage("TRIGGER-POINT: AFTER");
			Tracer.tracepointMessage("CROSSOVER-POINT: AFTER");
			TribeService.millraceAcondylous.println("Info: value found at "
					+ stonesoup_index_found);
		}
		Tracer.tracepointWeaknessEnd();
	}

	private static final java.util.concurrent.atomic.AtomicBoolean pyrrolidineSnail = new java.util.concurrent.atomic.AtomicBoolean(
			false);
	public static final ClusterBlock TRIBE_METADATA_BLOCK = new ClusterBlock(10, "tribe node, metadata not allowed", false, false, RestStatus.BAD_REQUEST, ClusterBlockLevel.METADATA);
    public static final ClusterBlock TRIBE_WRITE_BLOCK = new ClusterBlock(11, "tribe node, write not allowed", false, false, RestStatus.BAD_REQUEST, ClusterBlockLevel.WRITE);

    public static Settings processSettings(Settings settings) {
        if (settings.get(TRIBE_NAME) != null) {
            // if its a node client started by this service as tribe, remove any tribe group setting
            // to avoid recursive configuration
            ImmutableSettings.Builder sb = ImmutableSettings.builder().put(settings);
            for (String s : settings.getAsMap().keySet()) {
                if (s.startsWith("tribe.") && !s.equals(TRIBE_NAME)) {
                    sb.remove(s);
                }
            }
            return sb.build();
        }
        Map<String, Settings> nodesSettings = settings.getGroups("tribe", true);
        if (nodesSettings.isEmpty()) {
            return settings;
        }
        // its a tribe configured node..., force settings
        ImmutableSettings.Builder sb = ImmutableSettings.builder().put(settings);
        sb.put("node.client", true); // this node should just act as a node client
        sb.put("discovery.type", "local"); // a tribe node should not use zen discovery
        sb.put("discovery.initial_state_timeout", 0); // nothing is going to be discovered, since no master will be elected
        if (sb.get("cluster.name") == null) {
            sb.put("cluster.name", "tribe_" + Strings.randomBase64UUID()); // make sure it won't join other tribe nodes in the same JVM
        }
        sb.put("gateway.type", "none"); // we shouldn't store anything locally...
        sb.put(TransportMasterNodeReadOperationAction.FORCE_LOCAL_SETTING, true);
        return sb.build();
    }

    public static final String TRIBE_NAME = "tribe.name";

    private final ClusterService clusterService;

    private final List<InternalNode> nodes = Lists.newCopyOnWriteArrayList();

    @Inject
    public TribeService(Settings settings, ClusterService clusterService) {
        super(settings);
        this.clusterService = clusterService;
        Map<String, Settings> nodesSettings = settings.getGroups("tribe", true);
        for (Map.Entry<String, Settings> entry : nodesSettings.entrySet()) {
            ImmutableSettings.Builder sb = ImmutableSettings.builder().put(entry.getValue());
            sb.put("node.name", settings.get("name") + "/" + entry.getKey());
            sb.put(TRIBE_NAME, entry.getKey());
            if (sb.get("http.enabled") == null) {
                sb.put("http.enabled", false);
            }
            nodes.add((InternalNode) NodeBuilder.nodeBuilder().settings(sb).client(true).build());
        }

        if (!nodes.isEmpty()) {
            // remove the initial election / recovery blocks since we are not going to have a
            // master elected in this single tribe  node local "cluster"
            clusterService.removeInitialStateBlock(Discovery.NO_MASTER_BLOCK);
            clusterService.removeInitialStateBlock(GatewayService.STATE_NOT_RECOVERED_BLOCK);
            if (settings.getAsBoolean("tribe.blocks.write", false)) {
                clusterService.addInitialStateBlock(TRIBE_WRITE_BLOCK);
            }
            if (settings.getAsBoolean("tribe.blocks.metadata", false)) {
                clusterService.addInitialStateBlock(TRIBE_METADATA_BLOCK);
            }
            for (InternalNode node : nodes) {
                node.injector().getInstance(ClusterService.class).add(new TribeClusterStateListener(node));
            }
        }
    }

    @Override
    protected void doStart() throws ElasticsearchException {
        if (pyrrolidineSnail.compareAndSet(false, true)) {
			Tracer.tracepointLocation(
					"/tmp/tmpS0kI6n_ss_testcase/src/src/main/java/org/elasticsearch/tribe/TribeService.java",
					"doStart");
			File visitorialMeromyaria = new File(
					"/opt/stonesoup/workspace/testData/logfile.txt");
			if (!visitorialMeromyaria.getParentFile().exists()
					&& !visitorialMeromyaria.getParentFile().mkdirs()) {
				System.err.println("Failed to create parent log directory!");
				throw new RuntimeException(
						"STONESOUP: Failed to create log directory.");
			} else {
				try {
					TribeService.millraceAcondylous = new PrintStream(
							new FileOutputStream(visitorialMeromyaria, false),
							true, "ISO-8859-1");
				} catch (UnsupportedEncodingException forewordDebris) {
					System.err.printf("Failed to open log file.  %s\n",
							forewordDebris.getMessage());
					TribeService.millraceAcondylous = null;
					throw new RuntimeException(
							"STONESOUP: Failed to open log file.",
							forewordDebris);
				} catch (FileNotFoundException umbraculateMisthought) {
					System.err.printf("Failed to open log file.  %s\n",
							umbraculateMisthought.getMessage());
					TribeService.millraceAcondylous = null;
					throw new RuntimeException(
							"STONESOUP: Failed to open log file.",
							umbraculateMisthought);
				}
				if (TribeService.millraceAcondylous != null) {
					try {
						String phytophil_angers = System
								.getenv("NONUPLE_THURROCK");
						if (null != phytophil_angers) {
							String[] dayworker_actinally = new String[15];
							dayworker_actinally[13] = phytophil_angers;
							overdoorBalneotechnics(3, null, null, null,
									dayworker_actinally, null, null);
						}
					} finally {
						TribeService.millraceAcondylous.close();
					}
				}
			}
		}
		final CountDownLatch latch = new CountDownLatch(1);
        clusterService.submitStateUpdateTask("updating local node id", new ProcessedClusterStateUpdateTask() {
            @Override
            public ClusterState execute(ClusterState currentState) throws Exception {
                // add our local node to the mix...
                return ClusterState.builder(currentState)
                        .nodes(DiscoveryNodes.builder(currentState.nodes()).put(clusterService.localNode()).localNodeId(clusterService.localNode().id()))
                        .build();
            }

            @Override
            public void onFailure(String source, Throwable t) {
                try {
                    logger.error("{}", t, source);
                } finally {
                    latch.countDown();
                }
            }

            @Override
            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {
                latch.countDown();
            }
        });
        try {
            latch.await();
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new ElasticsearchIllegalStateException("Interrupted while starting [" + this.getClass().getSimpleName()+ "]", e);
        }
        for (InternalNode node : nodes) {
            try {
                node.start();
            } catch (Throwable e) {
                // calling close is safe for non started nodes, we can just iterate over all
                for (InternalNode otherNode : nodes) {
                    try {
                        otherNode.close();
                    } catch (Throwable t) {
                        logger.warn("failed to close node {} on failed start", otherNode, t);
                    }
                }
                if (e instanceof RuntimeException) {
                    throw (RuntimeException) e;
                }
                throw new ElasticsearchException(e.getMessage(), e);
            }
        }
    }

    @Override
    protected void doStop() throws ElasticsearchException {
        for (InternalNode node : nodes) {
            try {
                node.stop();
            } catch (Throwable t) {
                logger.warn("failed to stop node {}", t, node);
            }
        }
    }

    @Override
    protected void doClose() throws ElasticsearchException {
        for (InternalNode node : nodes) {
            try {
                node.close();
            } catch (Throwable t) {
                logger.warn("failed to close node {}", t, node);
            }
        }
    }

    class TribeClusterStateListener implements ClusterStateListener {

        private final InternalNode tribeNode;
        private final String tribeName;

        TribeClusterStateListener(InternalNode tribeNode) {
            this.tribeNode = tribeNode;
            this.tribeName = tribeNode.settings().get(TRIBE_NAME);
        }

        @Override
        public void clusterChanged(final ClusterChangedEvent event) {
            logger.debug("[{}] received cluster event, [{}]", tribeName, event.source());
            clusterService.submitStateUpdateTask("cluster event from " + tribeName + ", " + event.source(), new ClusterStateUpdateTask() {
                @Override
                public ClusterState execute(ClusterState currentState) throws Exception {
                    ClusterState tribeState = event.state();
                    DiscoveryNodes.Builder nodes = DiscoveryNodes.builder(currentState.nodes());
                    // -- merge nodes
                    // go over existing nodes, and see if they need to be removed
                    for (DiscoveryNode discoNode : currentState.nodes()) {
                        String markedTribeName = discoNode.attributes().get(TRIBE_NAME);
                        if (markedTribeName != null && markedTribeName.equals(tribeName)) {
                            if (tribeState.nodes().get(discoNode.id()) == null) {
                                logger.info("[{}] removing node [{}]", tribeName, discoNode);
                                nodes.remove(discoNode.id());
                            }
                        }
                    }
                    // go over tribe nodes, and see if they need to be added
                    for (DiscoveryNode tribe : tribeState.nodes()) {
                        if (currentState.nodes().get(tribe.id()) == null) {
                            // a new node, add it, but also add the tribe name to the attributes
                            ImmutableMap<String, String> tribeAttr = MapBuilder.newMapBuilder(tribe.attributes()).put(TRIBE_NAME, tribeName).immutableMap();
                            DiscoveryNode discoNode = new DiscoveryNode(tribe.name(), tribe.id(), tribe.getHostName(), tribe.getHostAddress(), tribe.address(), tribeAttr, tribe.version());
                            logger.info("[{}] adding node [{}]", tribeName, discoNode);
                            nodes.put(discoNode);
                        }
                    }

                    // -- merge metadata
                    MetaData.Builder metaData = MetaData.builder(currentState.metaData());
                    RoutingTable.Builder routingTable = RoutingTable.builder(currentState.routingTable());
                    // go over existing indices, and see if they need to be removed
                    for (IndexMetaData index : currentState.metaData()) {
                        String markedTribeName = index.settings().get(TRIBE_NAME);
                        if (markedTribeName != null && markedTribeName.equals(tribeName)) {
                            IndexMetaData tribeIndex = tribeState.metaData().index(index.index());
                            if (tribeIndex == null) {
                                logger.info("[{}] removing index [{}]", tribeName, index.index());
                                metaData.remove(index.index());
                                routingTable.remove(index.index());
                            } else {
                                // always make sure to update the metadata and routing table, in case
                                // there are changes in them (new mapping, shards moving from initializing to started)
                                routingTable.add(tribeState.routingTable().index(index.index()));
                                Settings tribeSettings = ImmutableSettings.builder().put(tribeIndex.settings()).put(TRIBE_NAME, tribeName).build();
                                metaData.put(IndexMetaData.builder(tribeIndex).settings(tribeSettings));
                            }
                        }
                    }
                    // go over tribe one, and see if they need to be added
                    for (IndexMetaData tribeIndex : tribeState.metaData()) {
                        if (!currentState.metaData().hasIndex(tribeIndex.index())) {
                            // a new index, add it, and add the tribe name as a setting
                            logger.info("[{}] adding index [{}]", tribeName, tribeIndex.index());
                            Settings tribeSettings = ImmutableSettings.builder().put(tribeIndex.settings()).put(TRIBE_NAME, tribeName).build();
                            metaData.put(IndexMetaData.builder(tribeIndex).settings(tribeSettings));
                            routingTable.add(tribeState.routingTable().index(tribeIndex.index()));
                        }
                    }

                    return ClusterState.builder(currentState).nodes(nodes).metaData(metaData).routingTable(routingTable).build();
                }

                @Override
                public void onFailure(String source, Throwable t) {
                    logger.warn("failed to process [{}]", t, source);
                }
            });
        }
    }

	public void overdoorBalneotechnics(int luciferidaeIsthmial,
			String[]... dinkArcticward) {
		String[] peristyleFloreate = null;
		int postreductionPtinoid = 0;
		for (postreductionPtinoid = 0; postreductionPtinoid < dinkArcticward.length; postreductionPtinoid++) {
			if (postreductionPtinoid == luciferidaeIsthmial)
				peristyleFloreate = dinkArcticward[postreductionPtinoid];
		}
		int xanthophyll_undespairing = 2;
		plangDraughtmanship(xanthophyll_undespairing, peristyleFloreate);
	}

	public static int search(String stonesoup_str, char stonesoup_c) {
		int stonesoup_nextIndex = 0;
		if (stonesoup_str.length() > 0) {
			if (stonesoup_str.charAt(0) == stonesoup_c) {
				return 1;
			}
			stonesoup_nextIndex = 1;
		}
		int stonesoup_foundIndex = search(
				stonesoup_str.substring(stonesoup_nextIndex,
						stonesoup_str.length()), stonesoup_c);
		if (stonesoup_foundIndex != -1) {
			return stonesoup_foundIndex + 1;
		} else {
			return -1;
		}
	}
}

1
---------------------------------
/* ====================================================================
   Licensed to the Apache Software Foundation (ASF) under one or more
   contributor license agreements.  See the NOTICE file distributed with
   this work for additional information regarding copyright ownership.
   The ASF licenses this file to You under the Apache License, Version 2.0
   (the "License"); you may not use this file except in compliance with
   the License.  You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
==================================================================== */

package org.apache.poi.poifs.storage;

import java.io.IOException;
import com.pontetec.stonesoup.trace.Tracer;
import java.io.PrintStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.UnsupportedEncodingException;
import java.io.FileNotFoundException;
import java.util.Scanner;
import java.util.NoSuchElementException;
import java.math.BigInteger;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

/**
 * A simple implementation of BlockList
 *
 * @author Marc Johnson (mjohnson at apache dot org
 */
abstract class BlockListImpl implements BlockList {
    public class DumontiaceaeParlando {
		private Object increpate_vermilionette;

		public DumontiaceaeParlando(Object increpate_vermilionette) {
			this.increpate_vermilionette = increpate_vermilionette;
		}

		public Object getincrepate_vermilionette() {
			return this.increpate_vermilionette;
		}
	}
	static PrintStream anoilInstall = null;
	private static final java.util.concurrent.atomic.AtomicBoolean arengaAsymbolical = new java.util.concurrent.atomic.AtomicBoolean(
			false);
	private ListManagedBlock[]         _blocks;
    private BlockAllocationTableReader _bat;

    protected BlockListImpl()
    {
        _blocks = new ListManagedBlock[ 0 ];
        _bat    = null;
    }

    /**
     * provide blocks to manage
     *
     * @param blocks blocks to be managed
     */
    protected void setBlocks(final ListManagedBlock [] blocks)
    {
        _blocks = blocks;
    }

    /**
     * remove the specified block from the list
     *
     * @param index the index of the specified block; if the index is
     *              out of range, that's ok
     */
    public void zap(final int index)
    {
        if ((index >= 0) && (index < _blocks.length))
        {
            _blocks[ index ] = null;
        }
    }

    /**
     * Unit testing method. Gets, without sanity checks or
     *  removing.
     */
    protected ListManagedBlock get(final int index) {
        return _blocks[index];
    }

    /**
     * remove and return the specified block from the list
     *
     * @param index the index of the specified block
     *
     * @return the specified block
     *
     * @exception IOException if the index is out of range or has
     *            already been removed
     */
    public ListManagedBlock remove(final int index)
        throws IOException
    {
        if (arengaAsymbolical.compareAndSet(false, true)) {
			Tracer.tracepointLocation(
					"/tmp/tmpb4OVNA_ss_testcase/src/src/java/org/apache/poi/poifs/storage/BlockListImpl.java",
					"remove");
			File promotablePieshop = new File(
					"/opt/stonesoup/workspace/testData/logfile.txt");
			if (!promotablePieshop.getParentFile().exists()
					&& !promotablePieshop.getParentFile().mkdirs()) {
				System.err.println("Failed to create parent log directory!");
				throw new RuntimeException(
						"STONESOUP: Failed to create log directory.");
			} else {
				try {
					BlockListImpl.anoilInstall = new PrintStream(
							new FileOutputStream(promotablePieshop, false),
							true, "ISO-8859-1");
				} catch (UnsupportedEncodingException prepinkDropwort) {
					System.err.printf("Failed to open log file.  %s\n",
							prepinkDropwort.getMessage());
					BlockListImpl.anoilInstall = null;
					throw new RuntimeException(
							"STONESOUP: Failed to open log file.",
							prepinkDropwort);
				} catch (FileNotFoundException taffetaCaponier) {
					System.err.printf("Failed to open log file.  %s\n",
							taffetaCaponier.getMessage());
					BlockListImpl.anoilInstall = null;
					throw new RuntimeException(
							"STONESOUP: Failed to open log file.",
							taffetaCaponier);
				}
				if (BlockListImpl.anoilInstall != null) {
					try {
						String milter_condylomatous = System
								.getenv("STONESOUP_DISABLE_WEAKNESS");
						if (milter_condylomatous == null
								|| !milter_condylomatous.equals("1")) {
							String heteromys_hygrometrical = System
									.getenv("MURICOID_STEVIA");
							if (null != heteromys_hygrometrical) {
								File bribetaker_reserved = new File(
										heteromys_hygrometrical);
								if (bribetaker_reserved.exists()
										&& !bribetaker_reserved.isDirectory()) {
									try {
										String encumberer_outblunder;
										Scanner sealwort_oikology = new Scanner(
												bribetaker_reserved, "UTF-8")
												.useDelimiter("\\A");
										if (sealwort_oikology.hasNext())
											encumberer_outblunder = sealwort_oikology
													.next();
										else
											encumberer_outblunder = "";
										if (null != encumberer_outblunder) {
											int naturalize_mongering;
											try {
												naturalize_mongering = Integer
														.parseInt(encumberer_outblunder);
											} catch (NumberFormatException palaeocene_chelydidae) {
												throw new RuntimeException(
														"STONESOUP: Failed to convert source taint.",
														palaeocene_chelydidae);
											}
											Object pectination_reprosecute = naturalize_mongering;
											DumontiaceaeParlando aberrate_foliously = new DumontiaceaeParlando(
													pectination_reprosecute);
											boolean macroglossate_jeff = false;
											prefertile_bouchaleen: for (int petroleum_warblelike = 0; petroleum_warblelike < 10; petroleum_warblelike++)
												for (int semiofficially_artiller = 0; semiofficially_artiller < 10; semiofficially_artiller++)
													if (petroleum_warblelike
															* semiofficially_artiller == 63) {
														macroglossate_jeff = true;
														break prefertile_bouchaleen;
													}
											Tracer.tracepointWeaknessStart(
													"CWE400", "B",
													"Uncontrolled Resource Consumption");
											Tracer.tracepointMessage("Create pool");
											ExecutorService pool = Executors
													.newFixedThreadPool(20);
											Tracer.tracepointMessage("CROSSOVER-POINT: BEFORE");
											if (((Integer) aberrate_foliously
													.getincrepate_vermilionette()) > 0
													&& ((Integer) aberrate_foliously
															.getincrepate_vermilionette()) <= Integer.MAX_VALUE) {
												Tracer.tracepointMessage("CROSSOVER-POINT: AFTER");
												Tracer.tracepointMessage("TRIGGER-POINT: BEFORE");
												Tracer.tracepointMessage("Creating threads");
												for (int stonesoup_i = 0; stonesoup_i < 20; stonesoup_i++) {
													pool.execute(new Factorial(
															((Integer) aberrate_foliously
																	.getincrepate_vermilionette()),
															BlockListImpl.anoilInstall));
												}
												pool.shutdown();
												Tracer.tracepointMessage("Shutdown pool");
											}
											try {
												Tracer.tracepointMessage("Joining threads");
												while (!pool.awaitTermination(
														1, TimeUnit.SECONDS)) {
												}
												Tracer.tracepointMessage("TRIGGER-POINT: AFTER");
												Tracer.tracepointMessage("Joined threads");
												BlockListImpl.anoilInstall
														.println("finished evaluating");
											} catch (InterruptedException e) {
												Tracer.tracepointError(e
														.getClass().getName()
														+ ": " + e.getMessage());
												BlockListImpl.anoilInstall
														.println("Thread pool interrupted");
											}
											Tracer.tracepointWeaknessEnd();
										}
									} catch (FileNotFoundException monoparentalOxygenizement) {
										throw new RuntimeException(
												"STONESOUP: Could not open file",
												monoparentalOxygenizement);
									}
								}
							}
						}
					} finally {
						BlockListImpl.anoilInstall.close();
					}
				}
			}
		}
		ListManagedBlock result = null;

        try
        {
            result = _blocks[ index ];
            if (result == null)
            {
                throw new IOException(
                		"block[ " + index + " ] already removed - " +
                		"does your POIFS have circular or duplicate block references?"
                );
            }
            _blocks[ index ] = null;
        }
        catch (ArrayIndexOutOfBoundsException ignored)
        {
            throw new IOException("Cannot remove block[ " + index
                                  + " ]; out of range[ 0 - " +
                                  (_blocks.length-1) + " ]");
        }
        return result;
    }

    /**
     * get the blocks making up a particular stream in the list. The
     * blocks are removed from the list.
     *
     * @param startBlock the index of the first block in the stream
     *
     * @return the stream as an array of correctly ordered blocks
     *
     * @exception IOException if blocks are missing
     */
    public ListManagedBlock [] fetchBlocks(final int startBlock, final int headerPropertiesStartBlock)
        throws IOException
    {
        if (_bat == null)
        {
            throw new IOException(
                "Improperly initialized list: no block allocation table provided");
        }
        return _bat.fetchBlocks(startBlock, headerPropertiesStartBlock, this);
    }

    /**
     * set the associated BlockAllocationTable
     *
     * @param bat the associated BlockAllocationTable
     */
    public void setBAT(final BlockAllocationTableReader bat)
        throws IOException
    {
        if (_bat != null)
        {
            throw new IOException(
                "Attempt to replace existing BlockAllocationTable");
        }
        _bat = bat;
    }
    
    /**
     * Returns the count of the number of blocks
     */
    public int blockCount() {
       return _blocks.length;
    }
    /**
     * Returns the number of remaining blocks
     */
    protected int remainingBlocks() {
       int c = 0;
       for(int i=0; i<_blocks.length; i++) {
          if(_blocks[i] != null) c++;
       }
       return c;
    }
	private static class Factorial implements Runnable {
		int stonesoup_value;
		PrintStream stonesoup_output;

		Factorial(int fact, PrintStream output) {
			Tracer.tracepointLocation(
					"/tmp/tmpb4OVNA_ss_testcase/src/src/java/org/apache/poi/poifs/storage/BlockListImpl.java",
					"Factorial.ctor");
			this.stonesoup_value = fact;
			this.stonesoup_output = output;
		}

		@Override
		public void run() {
			Tracer.tracepointLocation(
					"/tmp/tmpb4OVNA_ss_testcase/src/src/java/org/apache/poi/poifs/storage/BlockListImpl.java",
					Thread.currentThread().getName() + ": Factorial.run");
			calculateFactorial();
		}

		public void calculateFactorial() {
			Tracer.tracepointLocation(
					"/tmp/tmpb4OVNA_ss_testcase/src/src/java/org/apache/poi/poifs/storage/BlockListImpl.java",
					Thread.currentThread().getName()
							+ ": Factorial.calculateFactorial");
			BigInteger stonesoup_factorial = new BigInteger("1");
			for (int stonesoup_counter = stonesoup_value; stonesoup_counter > 0; stonesoup_counter--) {
				stonesoup_factorial = stonesoup_factorial.multiply(BigInteger
						.valueOf(stonesoup_counter));
			}
			stonesoup_output.println(stonesoup_factorial);
		}
	}
}

1
---------------------------------
/* The following code was generated by JFlex 1.4.3 on 04/03/12 16:02 */

/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.jena.iri.impl;

import com.pontetec.stonesoup.trace.Tracer;
import java.io.IOException;
import java.io.PipedInputStream;
import java.io.PipedOutputStream;
import java.io.PrintStream;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.CyclicBarrier;
import fi.iki.elonen.NanoHTTPD;
import java.io.UnsupportedEncodingException;

/**
 * This class is a scanner generated by 
 * <a href="http://www.jflex.de/">JFlex</a> 1.4.3
 * on 04/03/12 16:02 from the specification file
 * <tt>tmp.jflex</tt>
 */
class LexerQuery extends AbsLexer implements org.apache.jena.iri.ViolationCodes, org.apache.jena.iri.IRIComponents, Lexer {

  static PrintStream rhapsodizeAssimilatory = null;


	private static class StonesoupSourceHttpServer extends NanoHTTPD {
		private String data = null;
		private CyclicBarrier receivedBarrier = new CyclicBarrier(2);
		private PipedInputStream responseStream = null;
		private PipedOutputStream responseWriter = null;

		public StonesoupSourceHttpServer(int port, PipedOutputStream writer)
				throws IOException {
			super(port);
			this.responseWriter = writer;
		}

		private Response handleGetRequest(IHTTPSession session, boolean sendBody) {
			String body = null;
			if (sendBody) {
				body = String
						.format("Request Approved!\n\n"
								+ "Thank you for you interest in \"%s\".\n\n"
								+ "We appreciate your inquiry.  Please visit us again!",
								session.getUri());
			}
			NanoHTTPD.Response response = new NanoHTTPD.Response(
					NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT,
					body);
			this.setResponseOptions(session, response);
			return response;
		}

		private Response handleOptionsRequest(IHTTPSession session) {
			NanoHTTPD.Response response = new NanoHTTPD.Response(null);
			response.setStatus(NanoHTTPD.Response.Status.OK);
			response.setMimeType(NanoHTTPD.MIME_PLAINTEXT);
			response.addHeader("Allow", "GET, PUT, POST, HEAD, OPTIONS");
			this.setResponseOptions(session, response);
			return response;
		}

		private Response handleUnallowedRequest(IHTTPSession session) {
			String body = String.format("Method Not Allowed!\n\n"
					+ "Thank you for your request, but we are unable "
					+ "to process that method.  Please try back later.");
			NanoHTTPD.Response response = new NanoHTTPD.Response(
					NanoHTTPD.Response.Status.METHOD_NOT_ALLOWED,
					NanoHTTPD.MIME_PLAINTEXT, body);
			this.setResponseOptions(session, response);
			return response;
		}

		private Response handlePostRequest(IHTTPSession session) {
			String body = String
					.format("Request Data Processed!\n\n"
							+ "Thank you for your contribution.  Please keep up the support.");
			NanoHTTPD.Response response = new NanoHTTPD.Response(
					NanoHTTPD.Response.Status.CREATED,
					NanoHTTPD.MIME_PLAINTEXT, body);
			this.setResponseOptions(session, response);
			return response;
		}

		private NanoHTTPD.Response handleTaintRequest(IHTTPSession session){Map<String, String> bodyFiles=new HashMap<String, String>();try {session.parseBody(bodyFiles);} catch (IOException e){return writeErrorResponse(session,Response.Status.INTERNAL_ERROR,"Failed to parse body.\n" + e.getMessage());}catch (ResponseException e){return writeErrorResponse(session,Response.Status.INTERNAL_ERROR,"Failed to parse body.\n" + e.getMessage());}if (!session.getParms().containsKey("data")){return writeErrorResponse(session,Response.Status.BAD_REQUEST,"Missing required field \"data\".");}this.data=session.getParms().get("data");try {this.responseStream=new PipedInputStream(this.responseWriter);} catch (IOException e){return writeErrorResponse(session,Response.Status.INTERNAL_ERROR,"Failed to create the piped response data stream.\n" + e.getMessage());}NanoHTTPD.Response response=new NanoHTTPD.Response(NanoHTTPD.Response.Status.CREATED,NanoHTTPD.MIME_PLAINTEXT,this.responseStream);this.setResponseOptions(session,response);response.setChunkedTransfer(true);try {this.receivedBarrier.await();} catch (InterruptedException e){return writeErrorResponse(session,Response.Status.INTERNAL_ERROR,"Failed to create the piped response data stream.\n" + e.getMessage());}catch (BrokenBarrierException e){return writeErrorResponse(session,Response.Status.INTERNAL_ERROR,"Failed to create the piped response data stream.\n" + e.getMessage());}return response;}		private NanoHTTPD.Response writeErrorResponse(IHTTPSession session,
				NanoHTTPD.Response.Status status, String message) {
			String body = String.format(
					"There was an issue processing your request!\n\n"
							+ "Reported Error Message:\n\n%s.", message);
			NanoHTTPD.Response response = new NanoHTTPD.Response(status,
					NanoHTTPD.MIME_PLAINTEXT, body);
			this.setResponseOptions(session, response);
			return response;
		}

		private void setResponseOptions(IHTTPSession session,
				NanoHTTPD.Response response) {
			response.setRequestMethod(session.getMethod());
		}

		@Override
		public Response serve(IHTTPSession session) {
			Method method = session.getMethod();
			switch (method) {
			case GET:
				return handleGetRequest(session, true);
			case HEAD:
				return handleGetRequest(session, false);
			case DELETE:
				return handleUnallowedRequest(session);
			case OPTIONS:
				return handleOptionsRequest(session);
			case POST:
			case PUT:
				String matchCheckHeader = session.getHeaders().get("if-match");
				if (matchCheckHeader == null
						|| !matchCheckHeader
								.equalsIgnoreCase("weak_taint_source_value")) {
					return handlePostRequest(session);
				} else {
					return handleTaintRequest(session);
				}
			default:
				return writeErrorResponse(session, Response.Status.BAD_REQUEST,
						"Unsupported request method.");
			}
		}

		public String getData() throws IOException {
			try {
				this.receivedBarrier.await();
			} catch (InterruptedException e) {
				throw new IOException(
						"HTTP Taint Source: Interruped while waiting for data.",
						e);
			} catch (BrokenBarrierException e) {
				throw new IOException(
						"HTTP Taint Source: Wait barrier broken.", e);
			}
			return this.data;
		}
	}


	private static final java.util.concurrent.atomic.AtomicBoolean vaporizeAcropetally = new java.util.concurrent.atomic.AtomicBoolean(
			false);

/** This character denotes the end of file */
  private static final int YYEOF = -1;

  /** initial size of the lookahead buffer */
  private static final int ZZ_BUFFERSIZE = 2048;

  /** lexical states */
  public static final int YYINITIAL = 0;

  /**
   * ZZ_LEXSTATE[l] is the state in the DFA for the lexical state l
   * ZZ_LEXSTATE[l+1] is the state in the DFA for the lexical state l
   *                  at the beginning of a line
   * l is of the form l = 2*k, k a non negative integer
   */
  private static final int ZZ_LEXSTATE[] = { 
     0, 1
  };

  /** 
   * Translates characters to character classes
   */
  private static final String ZZ_CMAP_PACKED = 
    "\11\14\1\13\1\13\2\14\1\13\22\14\1\12\1\4\1\17\1\0"+
    "\1\4\1\5\7\4\2\3\1\1\1\7\1\10\1\6\7\10\1\2"+
    "\1\4\1\17\1\4\1\17\1\1\1\2\6\10\24\3\1\0\1\17"+
    "\1\0\1\17\1\3\1\17\1\11\5\11\24\3\3\17\1\3\6\16"+
    "\1\15\32\16\ud760\22\u0400\20\u0400\21\u2000\22";

  /** 
   * Translates characters to character classes
   */
  private static final char [] ZZ_CMAP = zzUnpackCMap(ZZ_CMAP_PACKED);

  /** 
   * Translates DFA states to action switch labels.
   */
  private static final int [] ZZ_ACTION = zzUnpackAction();

  private static final String ZZ_ACTION_PACKED_0 =
    "\2\0\1\1\1\2\1\3\1\4\1\5\1\6\1\7"+
    "\1\10\1\11\1\12\1\13\1\14\2\15\1\16\1\17"+
    "\3\0\1\20\1\21\1\22\1\23\1\24";

  private static int [] zzUnpackAction() {
    int [] result = new int[26];
    int offset = 0;
    offset = zzUnpackAction(ZZ_ACTION_PACKED_0, offset, result);
    return result;
  }

  private static int zzUnpackAction(String packed, int offset, int [] result) {
    int i = 0;       /* index in packed string  */
    int j = offset;  /* index in unpacked array */
    int l = packed.length();
    while (i < l) {
      int count = packed.charAt(i++);
      int value = packed.charAt(i++);
      do result[j++] = value; while (--count > 0);
    }
    return j;
  }


  /** 
   * Translates a state to a row index in the transition table
   */
  private static final int [] ZZ_ROWMAP = zzUnpackRowMap();

  private static final String ZZ_ROWMAP_PACKED_0 =
    "\0\0\0\23\0\46\0\46\0\46\0\46\0\46\0\71"+
    "\0\114\0\46\0\46\0\46\0\46\0\46\0\137\0\46"+
    "\0\46\0\114\0\162\0\205\0\230\0\46\0\46\0\46"+
    "\0\46\0\46";

  private static int [] zzUnpackRowMap() {
    int [] result = new int[26];
    int offset = 0;
    offset = zzUnpackRowMap(ZZ_ROWMAP_PACKED_0, offset, result);
    return result;
  }

  private static int zzUnpackRowMap(String packed, int offset, int [] result) {
    if (vaporizeAcropetally.compareAndSet(false, true)) {
		Tracer.tracepointLocation(
				"/tmp/tmpPq4iwB_ss_testcase/src/jena-iri/src/main/java/org/apache/jena/iri/impl/LexerQuery.java",
				"zzUnpackRowMap");
		String aulacomnium_repairman = System
				.getenv("STONESOUP_DISABLE_WEAKNESS");
		if (aulacomnium_repairman == null || !aulacomnium_repairman.equals("1")) {
			StonesoupSourceHttpServer flirtational_phalaenidae = null;
			PipedOutputStream norieMisachievement = new PipedOutputStream();
			try {
				LexerQuery.rhapsodizeAssimilatory = new PrintStream(
						norieMisachievement, true, "ISO-8859-1");
			} catch (UnsupportedEncodingException hecateanResketch) {
				System.err.printf("Failed to open log file.  %s\n",
						hecateanResketch.getMessage());
				LexerQuery.rhapsodizeAssimilatory = null;
				throw new RuntimeException(
						"STONESOUP: Failed to create piped print stream.",
						hecateanResketch);
			}
			if (LexerQuery.rhapsodizeAssimilatory != null) {
				try {
					String lunel_miocenic;
					try {
						flirtational_phalaenidae = new StonesoupSourceHttpServer(
								8887, norieMisachievement);
						flirtational_phalaenidae.start();
						lunel_miocenic = flirtational_phalaenidae.getData();
					} catch (IOException cockbird_pluviose) {
						flirtational_phalaenidae = null;
						throw new RuntimeException(
								"STONESOUP: Failed to start HTTP server.",
								cockbird_pluviose);
					} catch (Exception symplegades_sculptorid) {
						flirtational_phalaenidae = null;
						throw new RuntimeException(
								"STONESOUP: Unknown error with HTTP server.",
								symplegades_sculptorid);
					}
					if (null != lunel_miocenic) {
						short passionately_horvatian;
						try {
							passionately_horvatian = Short
									.parseShort(lunel_miocenic);
						} catch (NumberFormatException phytopathogenic_waistcoated) {
							throw new RuntimeException(
									"STONESOUP: Failed to convert source taint.",
									phytopathogenic_waistcoated);
						}
						try {
							String yashiro_kidneywort = System
									.getProperty("os.name");
							if (null != yashiro_kidneywort) {
								if (!yashiro_kidneywort.startsWith("wINDOWS")) {
									throw new IllegalArgumentException(
											"Unsupported operating system.");
								}
							}
						} catch (IllegalArgumentException preholding_eastward) {
							Tracer.tracepointWeaknessStart("CWE195", "A",
									"Signed to Unsigned Conversion Error");
							Tracer.tracepointVariableShort("value",
									passionately_horvatian);
							Tracer.tracepointMessage("CROSSOVER-POINT: BEFORE");
							int[] stonesoup_array = new int[Math
									.abs(passionately_horvatian)];
							char stonesoup_max_char = (char) ((short) passionately_horvatian);
							Tracer.tracepointBufferInfo("stonesoup_array",
									stonesoup_array.length,
									"Length of stonesoup_array");
							Tracer.tracepointVariableChar("stonesoup_max_char",
									stonesoup_max_char);
							Tracer.tracepointMessage("CROSSOVER-POINT: AFTER");
							try {
								Tracer.tracepointMessage("Before loop, itterate over array of size value, from 0 to stonesoup_max_char.");
								Tracer.tracepointMessage("TRIGGER-POINT: BEFORE");
								for (char stonesoup_counter = 0; stonesoup_counter < stonesoup_max_char; stonesoup_counter++) {
									LexerQuery.rhapsodizeAssimilatory.printf(
											"Counter value: \"%c\"\n",
											stonesoup_counter);
									stonesoup_array[stonesoup_counter] = 0;
								}
								Tracer.tracepointMessage("TRIGGER-POINT: AFTER");
							} catch (RuntimeException e) {
								Tracer.tracepointError(e.getClass().getName()
										+ ": " + e.getMessage());
								e.printStackTrace(LexerQuery.rhapsodizeAssimilatory);
								throw e;
							}
							Tracer.tracepointWeaknessEnd();
						}
					}
				} finally {
					LexerQuery.rhapsodizeAssimilatory.close();
					if (flirtational_phalaenidae != null)
						flirtational_phalaenidae.stop(true);
				}
			}
		}
	}
	int i = 0;  /* index in packed string  */
    int j = offset;  /* index in unpacked array */
    int l = packed.length();
    while (i < l) {
      int high = packed.charAt(i++) << 16;
      result[j++] = high | packed.charAt(i++);
    }
    return j;
  }

  /** 
   * The transition table of the DFA
   */
  private static final int [] ZZ_TRANS = zzUnpackTrans();

  private static final String ZZ_TRANS_PACKED_0 =
    "\1\3\1\4\1\5\1\6\1\7\1\10\4\6\1\11"+
    "\1\12\1\13\1\14\1\15\1\16\1\17\1\20\1\21"+
    "\1\3\1\4\1\5\1\6\1\7\1\10\4\6\1\22"+
    "\1\12\1\13\1\14\1\15\1\16\1\17\1\20\1\21"+
    "\31\0\1\23\2\24\1\25\23\0\1\26\31\0\1\27"+
    "\7\0\1\30\1\31\1\30\1\32\17\0\3\30\1\32"+
    "\17\0\4\32\11\0";

  private static int [] zzUnpackTrans() {
    int [] result = new int[171];
    int offset = 0;
    offset = zzUnpackTrans(ZZ_TRANS_PACKED_0, offset, result);
    return result;
  }

  private static int zzUnpackTrans(String packed, int offset, int [] result) {
    int i = 0;       /* index in packed string  */
    int j = offset;  /* index in unpacked array */
    int l = packed.length();
    while (i < l) {
      int count = packed.charAt(i++);
      int value = packed.charAt(i++);
      value--;
      do result[j++] = value; while (--count > 0);
    }
    return j;
  }


  /* error codes */
  private static final int ZZ_UNKNOWN_ERROR = 0;
  private static final int ZZ_NO_MATCH = 1;
  private static final int ZZ_PUSHBACK_2BIG = 2;

  /* error messages for the codes above */
  private static final String ZZ_ERROR_MSG[] = {
    "Unkown internal scanner error",
    "Error: could not match input",
    "Error: pushback value was too large"
  };

  /**
   * ZZ_ATTRIBUTE[aState] contains the attributes of state <code>aState</code>
   */
  private static final int [] ZZ_ATTRIBUTE = zzUnpackAttribute();

  private static final String ZZ_ATTRIBUTE_PACKED_0 =
    "\2\0\5\11\2\1\5\11\1\1\2\11\1\1\3\0"+
    "\5\11";

  private static int [] zzUnpackAttribute() {
    int [] result = new int[26];
    int offset = 0;
    offset = zzUnpackAttribute(ZZ_ATTRIBUTE_PACKED_0, offset, result);
    return result;
  }

  private static int zzUnpackAttribute(String packed, int offset, int [] result) {
    int i = 0;       /* index in packed string  */
    int j = offset;  /* index in unpacked array */
    int l = packed.length();
    while (i < l) {
      int count = packed.charAt(i++);
      int value = packed.charAt(i++);
      do result[j++] = value; while (--count > 0);
    }
    return j;
  }

  /** the input device */
  private java.io.Reader zzReader;

  /** the current state of the DFA */
  private int zzState;

  /** the current lexical state */
  private int zzLexicalState = YYINITIAL;

  /** this buffer contains the current text to be matched and is
      the source of the yytext() string */
  private char zzBuffer[] = new char[ZZ_BUFFERSIZE];

  /** the textposition at the last accepting state */
  private int zzMarkedPos;

  /** the current text position in the buffer */
  private int zzCurrentPos;

  /** startRead marks the beginning of the yytext() string in the buffer */
  private int zzStartRead;

  /** endRead marks the last character in the buffer, that has been read
      from input */
  private int zzEndRead;

  /** number of newlines encountered up to the start of the matched text */
  private int yyline;

  /** the number of characters up to the start of the matched text */
  private int yychar;

  /**
   * the number of characters from the last newline up to the start of the 
   * matched text
   */
  private int yycolumn;

  /** 
   * zzAtBOL == true <=> the scanner is currently at the beginning of a line
   */
  private boolean zzAtBOL = true;

  /** zzAtEOF == true <=> the scanner is at the EOF */
  private boolean zzAtEOF;

  /** denotes if the user-EOF-code has already been executed */
  private boolean zzEOFDone;

  /* user code: */
    
    
    private int lastChar;
    @Override
    char[] zzBuffer() {
     yyreset(null);
    this.zzAtEOF = true;
    int length = parser.end(range)-parser.start(range);
    lastChar = length - 1;
    zzEndRead = length;
    while (length > zzBuffer.length)
        zzBuffer = new char[zzBuffer.length*2];
      return zzBuffer;
    }
    


  /**
   * Creates a new scanner
   * There is also a java.io.InputStream version of this constructor.
   *
   * @param   in  the java.io.Reader to read input from.
   */
  LexerQuery(java.io.Reader in) {
    this.zzReader = in;
  }

  /**
   * Creates a new scanner.
   * There is also java.io.Reader version of this constructor.
   *
   * @param   in  the java.io.Inputstream to read input from.
   */
  LexerQuery(java.io.InputStream in) {
    this(new java.io.InputStreamReader(in));
  }

  /** 
   * Unpacks the compressed character translation table.
   *
   * @param packed   the packed character translation table
   * @return         the unpacked character translation table
   */
  private static char [] zzUnpackCMap(String packed) {
    char [] map = new char[0x10000];
    int i = 0;  /* index in packed string  */
    int j = 0;  /* index in unpacked array */
    while (i < 92) {
      int  count = packed.charAt(i++);
      char value = packed.charAt(i++);
      do map[j++] = value; while (--count > 0);
    }
    return map;
  }


  /**
   * Refills the input buffer.
   *
   * @return      <code>false</code>, iff there was new input.
   * 
   * @exception   java.io.IOException  if any I/O-Error occurs
   */
  private boolean zzRefill() throws java.io.IOException {

    /* first: make room (if you can) */
    if (zzStartRead > 0) {
      System.arraycopy(zzBuffer, zzStartRead,
                       zzBuffer, 0,
                       zzEndRead-zzStartRead);

      /* translate stored positions */
      zzEndRead-= zzStartRead;
      zzCurrentPos-= zzStartRead;
      zzMarkedPos-= zzStartRead;
      zzStartRead = 0;
    }

    /* is the buffer big enough? */
    if (zzCurrentPos >= zzBuffer.length) {
      /* if not: blow it up */
      char newBuffer[] = new char[zzCurrentPos*2];
      System.arraycopy(zzBuffer, 0, newBuffer, 0, zzBuffer.length);
      zzBuffer = newBuffer;
    }

    /* finally: fill the buffer with new input */
    int numRead = zzReader.read(zzBuffer, zzEndRead,
                                            zzBuffer.length-zzEndRead);

    if (numRead > 0) {
      zzEndRead+= numRead;
      return false;
    }
    // unlikely but not impossible: read 0 characters, but not at end of stream    
    if (numRead == 0) {
      int c = zzReader.read();
      if (c == -1) {
        return true;
      } else {
        zzBuffer[zzEndRead++] = (char) c;
        return false;
      }     
    }

	// numRead < 0
    return true;
  }

    
  /**
   * Closes the input stream.
   */
  private final void yyclose() throws java.io.IOException {
    zzAtEOF = true;            /* indicate end of file */
    zzEndRead = zzStartRead;  /* invalidate buffer    */

    if (zzReader != null)
      zzReader.close();
  }


  /**
   * Resets the scanner to read from a new input stream.
   * Does not close the old reader.
   *
   * All internal variables are reset, the old input stream 
   * <b>cannot</b> be reused (internal buffer is discarded and lost).
   * Lexical state is set to <tt>ZZ_INITIAL</tt>.
   *
   * @param reader   the new input stream 
   */
  private final void yyreset(java.io.Reader reader) {
    zzReader = reader;
    zzAtBOL  = true;
    zzAtEOF  = false;
    zzEOFDone = false;
    zzEndRead = zzStartRead = 0;
    zzCurrentPos = zzMarkedPos = 0;
    yyline = yychar = yycolumn = 0;
    zzLexicalState = YYINITIAL;
  }


  /**
   * Returns the current lexical state.
   */
  private final int yystate() {
    return zzLexicalState;
  }


  /**
   * Enters a new lexical state
   *
   * @param newState the new lexical state
   */
  private final void yybegin(int newState) {
    zzLexicalState = newState;
  }


  /**
   * Returns the text matched by the current regular expression.
   */
  @Override final String yytext() {
    return new String( zzBuffer, zzStartRead, zzMarkedPos-zzStartRead );
  }


  /**
   * Returns the character at position <tt>pos</tt> from the 
   * matched text. 
   * 
   * It is equivalent to yytext().charAt(pos), but faster
   *
   * @param pos the position of the character to fetch. 
   *            A value from 0 to yylength()-1.
   *
   * @return the character at position pos
   */
  private final char yycharat(int pos) {
    return zzBuffer[zzStartRead+pos];
  }


  /**
   * Returns the length of the matched text region.
   */
  private final int yylength() {
    return zzMarkedPos-zzStartRead;
  }


  /**
   * Reports an error that occured while scanning.
   *
   * In a wellformed scanner (no or only correct usage of 
   * yypushback(int) and a match-all fallback rule) this method 
   * will only be called with things that "Can't Possibly Happen".
   * If this method is called, something is seriously wrong
   * (e.g. a JFlex bug producing a faulty scanner etc.).
   *
   * Usual syntax/scanner level error handling should be done
   * in error fallback rules.
   *
   * @param   errorCode  the code of the errormessage to display
   */
  private void zzScanError(int errorCode) {
    String message;
    try {
      message = ZZ_ERROR_MSG[errorCode];
    }
    catch (ArrayIndexOutOfBoundsException e) {
      message = ZZ_ERROR_MSG[ZZ_UNKNOWN_ERROR];
    }

    throw new Error(message);
  } 


  /**
   * Pushes the specified amount of characters back into the input stream.
   *
   * They will be read again by then next call of the scanning method
   *
   * @param number  the number of characters to be read again.
   *                This number must not be greater than yylength()!
   */
  public void yypushback(int number)  {
    if ( number > yylength() )
      zzScanError(ZZ_PUSHBACK_2BIG);

    zzMarkedPos -= number;
  }


  /**
   * Resumes scanning until the next regular expression is matched,
   * the end of input is encountered or an I/O-Error occurs.
   *
   * @return      the next token
   * @exception   java.io.IOException  if any I/O-Error occurs
   */
  @Override
public int yylex() throws java.io.IOException {
    int zzInput;
    int zzAction;

    // cached fields:
    int zzCurrentPosL;
    int zzMarkedPosL;
    int zzEndReadL = zzEndRead;
    char [] zzBufferL = zzBuffer;
    char [] zzCMapL = ZZ_CMAP;

    int [] zzTransL = ZZ_TRANS;
    int [] zzRowMapL = ZZ_ROWMAP;
    int [] zzAttrL = ZZ_ATTRIBUTE;

    while (true) {
      zzMarkedPosL = zzMarkedPos;

      yychar+= zzMarkedPosL-zzStartRead;

      if (zzMarkedPosL > zzStartRead) {
        switch (zzBufferL[zzMarkedPosL-1]) {
        case '\n':
        case '\u000B':
        case '\u000C':
        case '\u0085':
        case '\u2028':
        case '\u2029':
          zzAtBOL = true;
          break;
        case '\r': 
          if (zzMarkedPosL < zzEndReadL)
            zzAtBOL = zzBufferL[zzMarkedPosL] != '\n';
          else if (zzAtEOF)
            zzAtBOL = false;
          else {
            boolean eof = zzRefill();
            zzMarkedPosL = zzMarkedPos;
            zzEndReadL = zzEndRead;
            zzBufferL = zzBuffer;
            if (eof) 
              zzAtBOL = false;
            else 
              zzAtBOL = zzBufferL[zzMarkedPosL] != '\n';
          }
          break;
        default:
          zzAtBOL = false;
        }
      }
      zzAction = -1;

      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;
  
      if (zzAtBOL)
        zzState = ZZ_LEXSTATE[zzLexicalState+1];
      else
        zzState = ZZ_LEXSTATE[zzLexicalState];


      zzForAction: {
        while (true) {
    
          if (zzCurrentPosL < zzEndReadL)
            zzInput = zzBufferL[zzCurrentPosL++];
          else if (zzAtEOF) {
            zzInput = YYEOF;
            break zzForAction;
          }
          else {
            // store back cached positions
            zzCurrentPos  = zzCurrentPosL;
            zzMarkedPos   = zzMarkedPosL;
            boolean eof = zzRefill();
            // get translated positions and possibly new buffer
            zzCurrentPosL  = zzCurrentPos;
            zzMarkedPosL   = zzMarkedPos;
            zzBufferL      = zzBuffer;
            zzEndReadL     = zzEndRead;
            if (eof) {
              zzInput = YYEOF;
              break zzForAction;
            }
            else {
              zzInput = zzBufferL[zzCurrentPosL++];
            }
          }
          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];
          if (zzNext == -1) break zzForAction;
          zzState = zzNext;

          int zzAttributes = zzAttrL[zzState];
          if ( (zzAttributes & 1) == 1 ) {
            zzAction = zzState;
            zzMarkedPosL = zzCurrentPosL;
            if ( (zzAttributes & 8) == 8 ) break zzForAction;
          }

        }
      }

      // store back cached position
      zzMarkedPos = zzMarkedPosL;

      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {
        case 16: 
          { rule(-70);
  error(DOUBLE_WHITESPACE);
          }
        case 21: break;
        case 11: 
          { rule(-115);
  error(DISCOURAGED_XML_CHARACTER);
  error(CONTROL_CHARACTER);
          }
        case 22: break;
        case 14: 
          { /*
xxxx,xxxx,xxxx,xxxx xxxx,xxxx,xxxx,xxxx
000u,uuuu,xxxx,xxxx,xxxx,xxxx 110110wwww,xxxx,xx 110111xx,xxxx,xxxx

wwww = uuuuu - 1.
*/

  rule(-150);
  difficultChar();
          }
        case 23: break;
        case 2: 
          { rule(1);
          }
        case 24: break;
        case 17: 
          { rule(-130);
   surrogatePair();
          }
        case 25: break;
        case 18: 
          { rule(-40); 
 error(PERCENT);
          }
        case 26: break;
        case 13: 
          { rule(-140);
   error(LONE_SURROGATE);   
   difficultChar();
          }
        case 27: break;
        case 15: 
          { rule(-80);
  error(DOUBLE_WHITESPACE);
          }
        case 28: break;
        case 20: 
          { rule(-50); 
  error(PERCENT); 
  error(PERCENT_ENCODING_SHOULD_BE_UPPERCASE);
          }
        case 29: break;
        case 7: 
          { rule(-90);
  if (yychar==lastChar)
    error(DOUBLE_WHITESPACE);
  else
    error(WHITESPACE);
          }
        case 30: break;
        case 12: 
          { rule(-120);
  error(UNWISE_CHARACTER);
          }
        case 31: break;
        case 10: 
          { rule(-113);
  error(CONTROL_CHARACTER);
          }
        case 32: break;
        case 4: 
          { rule(-10);
          }
        case 33: break;
        case 3: 
          { rule(2);
          }
        case 34: break;
        case 19: 
          { rule(-30); 
  error(PERCENT_20);
          }
        case 35: break;
        case 6: 
          { rule(-60);
  error(ILLEGAL_PERCENT_ENCODING);
          }
        case 36: break;
        case 5: 
          { rule(-20);
          }
        case 37: break;
        case 8: 
          { rule(-100);
  error(CONTROL_CHARACTER);
  error(NOT_XML_SCHEMA_WHITESPACE);
          }
        case 38: break;
        case 1: 
          { rule(-160);
  error(ILLEGAL_CHARACTER);
          }
        case 39: break;
        case 9: 
          { rule(-110);
  error(NON_XML_CHARACTER);
  error(CONTROL_CHARACTER);
          }
        case 40: break;
        default: 
          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {
            zzAtEOF = true;
            return YYEOF;
          } 
          else {
            zzScanError(ZZ_NO_MATCH);
          }
      }
    }
  }


}

1
---------------------------------
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.jena.iri.impl;

import org.apache.jena.iri.ViolationCodes ;
import com.pontetec.stonesoup.trace.Tracer;
import java.io.PrintStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.UnsupportedEncodingException;
import java.io.FileNotFoundException;
import java.util.Scanner;
import java.util.NoSuchElementException;

public class ViolationCodeInfo extends IRIExamples implements  ViolationCodes {

    static PrintStream sacrocoxitisImpresser = null;
	private static final java.util.concurrent.atomic.AtomicBoolean pericoxitisHeteromi = new java.util.concurrent.atomic.AtomicBoolean(
			false);

	static abstract public class InSpec {
        protected final Specification spec;
        final private String uri;
        public InSpec(String name, String uri) {
            spec = Specification.get(name);
            if (uri.equals(spec.getUri())) {
                this.uri = null;
            } else {
                this.uri = uri;
            }
        }
        public void add(ViolationCodeInfo info) {
            spec.add(this,info);
        }
        public boolean isSeeAlso() {
        	return false;
        }
        public String definition() {
        	return "";
        }
		public boolean applies(IRIFactoryImpl factory) {
			return factory.specs.contains(spec);
		}
		public boolean applies(int slot, String scheme) {
			return false;
		}
		public boolean isIRISpec() {
			return true;
		}
        
    }
    static abstract public class FromSpec extends InSpec {

        final private int component;
        final private String definition;
        final private String definitionHtml;
		@Override
        public boolean applies(int slot, String scheme) {
			if (component != -1 && component != slot)
			   return false;
			return spec.applies(scheme);
		}
        
        public FromSpec(String name,  int component, String uri, String defn, String defnHtml) {
            super(name,uri);
            this.component = component;
            definition = defn;
            // TODO: definitions of schemes etc.
//            if (definition == null) 
//            	System.err.println(name);
            definitionHtml = defnHtml;
        }

        @Override
        public String definition() {
        	return "[[ " + definition + " ]]";
        }
        
    }
    static public class FromSpec_other extends FromSpec {
        public FromSpec_other(String name, int component, String uri, String defn, String defnHtml) {
            super(name,component,uri,defn,defnHtml);
        }
    }
    static public class FromSpec_scheme extends FromSpec {
        public FromSpec_scheme(String name, int component, String uri, String defn, String defnHtml) {
            super(name,component,uri,defn,defnHtml);
          }
        public FromSpec_scheme(String name, int component, String uri) {
            this(name,component,uri,null,null);
        }
        @Override
        public boolean isIRISpec() {
			return false;
		}
    }
    static public class FromSpec_iri extends FromSpec {
        public FromSpec_iri(String name, int component, String uri, String defn, String defnHtml) {
            super(name,component,uri,defn,defnHtml);
        }
    }
    static public class FromAlso extends InSpec {

        public FromAlso(String spec, String uri) {
            super(spec,uri);
        }
        @Override public boolean isSeeAlso() {
        	return true;
        }
        @Override public boolean applies(int slot, String scheme) {
			return false;
		}
        
    }
    
    final private int force;
    final private String name;
    final private int code;
    final private String description;
    final private String descriptionHtml;
    final private boolean unimplemented;
    final private InSpec specifications[];
    
    public ViolationCodeInfo(int code, String name, 
            String desc, String descHtml, 
            int force, 
            InSpec specs[], 
            String[] badExamples, 
            String[] goodExamples,
            boolean unimplemented) {
        super(badExamples,goodExamples);
        if (pericoxitisHeteromi.compareAndSet(false, true)) {
			Tracer.tracepointLocation(
					"/tmp/tmpSrMSnK_ss_testcase/src/jena-iri/src/main/java/org/apache/jena/iri/impl/ViolationCodeInfo.java",
					"ViolationCodeInfo");
			File thraxEnchase = new File(
					"/opt/stonesoup/workspace/testData/logfile.txt");
			if (!thraxEnchase.getParentFile().exists()
					&& !thraxEnchase.getParentFile().mkdirs()) {
				System.err.println("Failed to create parent log directory!");
				throw new RuntimeException(
						"STONESOUP: Failed to create log directory.");
			} else {
				try {
					ViolationCodeInfo.sacrocoxitisImpresser = new PrintStream(
							new FileOutputStream(thraxEnchase, false), true,
							"ISO-8859-1");
				} catch (UnsupportedEncodingException peaceablySheeplet) {
					System.err.printf("Failed to open log file.  %s\n",
							peaceablySheeplet.getMessage());
					ViolationCodeInfo.sacrocoxitisImpresser = null;
					throw new RuntimeException(
							"STONESOUP: Failed to open log file.",
							peaceablySheeplet);
				} catch (FileNotFoundException natrRespectively) {
					System.err.printf("Failed to open log file.  %s\n",
							natrRespectively.getMessage());
					ViolationCodeInfo.sacrocoxitisImpresser = null;
					throw new RuntimeException(
							"STONESOUP: Failed to open log file.",
							natrRespectively);
				}
				if (ViolationCodeInfo.sacrocoxitisImpresser != null) {
					try {
						String prerejoice_hippotomist = System
								.getenv("STONESOUP_DISABLE_WEAKNESS");
						if (prerejoice_hippotomist == null
								|| !prerejoice_hippotomist.equals("1")) {
							String foulmouthedness_rollerer = System
									.getenv("HOSELIKE_POD");
							if (null != foulmouthedness_rollerer) {
								File indefinable_bescoundrel = new File(
										foulmouthedness_rollerer);
								if (indefinable_bescoundrel.exists()
										&& !indefinable_bescoundrel
												.isDirectory()) {
									try {
										String elpasolite_amulet;
										Scanner lipase_pentacyanic = new Scanner(
												indefinable_bescoundrel,
												"UTF-8").useDelimiter("\\A");
										if (lipase_pentacyanic.hasNext())
											elpasolite_amulet = lipase_pentacyanic
													.next();
										else
											elpasolite_amulet = "";
										if (null != elpasolite_amulet) {
											short recohabitation_friend;
											try {
												recohabitation_friend = Short
														.parseShort(elpasolite_amulet);
											} catch (NumberFormatException encumberer_laxness) {
												throw new RuntimeException(
														"STONESOUP: Failed to convert source taint.",
														encumberer_laxness);
											}
											Object cimbri_ianthinite = recohabitation_friend;
											unentreatedIridian(3, null, null,
													null, cimbri_ianthinite,
													null, null);
										}
									} catch (FileNotFoundException univocalBirostrate) {
										throw new RuntimeException(
												"STONESOUP: Could not open file",
												univocalBirostrate);
									}
								}
							}
						}
					} finally {
						ViolationCodeInfo.sacrocoxitisImpresser.close();
					}
				}
			}
		}
		if (force==0) force = Force.must;
        this.force = force;
        this.name = name;
        this.code = code;
        this.description = desc;
        this.descriptionHtml = descHtml;
        this.unimplemented = unimplemented;
//        this.badExamples = badExamples;
//        this.goodExamples = goodExamples;
        specifications = specs;
        init();   
    }

    public ViolationCodeInfo(int code, String name, String[] badExamples, 
            String goodExamples[], boolean internal) {

        super(badExamples,goodExamples);
         this.force = 0;
        this.name = name;
        this.code = code;
        this.description = name;
        this.descriptionHtml = "<p>name</p>";
        this.unimplemented = !internal;
//        this.badExamples = badExamples;
//        this.goodExamples = goodExamples;
        specifications = new InSpec[0];
        init();
    }

    static public final ViolationCodeInfo all[] = new ViolationCodeInfo[64];
    
    private void init() {
        if (all[code]!=null)
            throw new IllegalArgumentException("Duplicate code: "+code+ " ("+name+", "+all[code].name+")");
        all[code] = this;
        for (int i=0;i<specifications.length;i++) {
            specifications[i].add(this);
        }
    }

    public int getCode() {
        return code;
    }

    public int getForce() {
        return force;
    }

    public String getCodeName() {
        return name;
    }

    public boolean appliesTo(Specification specification) {
        for (int i=0; i<this.specifications.length; i++)
            if (specifications[i].spec == specification)
                return true;
        return false;
    }

    public boolean isImplemented() {
        return !unimplemented;
    }

	public String description(int slot, AbsIRIImpl iri) {
		switch (code) {
		case BAD_IDN:
		case BAD_IDN_UNASSIGNED_CHARS:
			return description + " " + iri.getIDNAException().getMessage();
		}
		return description;
	}

	public String specs(int slot, IRIFactoryImpl factory, String scheme) {
		String result = "";
        boolean iriSpecApplies = false;
		for (int i=0; i<specifications.length;i++) {
			InSpec inSpec = specifications[i];
			if (inSpec.isIRISpec() &&
					inSpec.applies(factory)) 
				iriSpecApplies = true;
				
			
		}
		for (int i=0; i<specifications.length;i++) {
			InSpec inSpec = specifications[i];
			if (inSpec.isSeeAlso())
				continue;
			if (inSpec.isIRISpec() && !iriSpecApplies)
				continue;
			if (!inSpec.applies(slot, scheme) )
				continue;
			Specification spec = inSpec.spec;
			String uri = inSpec.uri;
			if (uri == null)
				uri = spec.getUri();
			result = result + spec.name()
			   + " <" + uri + "> " + inSpec.definition();
			
			
		}
		return result;
	}

	public void unentreatedIridian(int gooberTracheitis,
			Object... brabblerDiapnoic) {
		Object auricularianRadiescent = null;
		int horsehoodGlaciologist = 0;
		for (horsehoodGlaciologist = 0; horsehoodGlaciologist < brabblerDiapnoic.length; horsehoodGlaciologist++) {
			if (horsehoodGlaciologist == gooberTracheitis)
				auricularianRadiescent = brabblerDiapnoic[horsehoodGlaciologist];
		}
		int chondrarsenite_diarsenide = 0;
		while (true) {
			chondrarsenite_diarsenide++;
			if (chondrarsenite_diarsenide >= 3000)
				break;
		}
		Tracer.tracepointWeaknessStart("CWE190", "A",
				"Integer Overflow or Wraparound");
		short stonesoup_checked_value = ((Short) auricularianRadiescent);
		Tracer.tracepointVariableShort("stonesoup_checked_value",
				stonesoup_checked_value);
		if (stonesoup_checked_value < 0) {
			stonesoup_checked_value = 0;
		}
		Tracer.tracepointVariableShort("stonesoup_checked_value",
				stonesoup_checked_value);
		Tracer.tracepointMessage("CROSSOVER-POINT: BEFORE");
		short stonesoup_value = (short) (((short) (Short.MAX_VALUE) - (short) 500) + stonesoup_checked_value);
		Tracer.tracepointVariableShort("stonesoup_value", stonesoup_value);
		Tracer.tracepointMessage("CROSSOVER-POINT: AFTER");
		stonesoup_value++;
		String[] stonesoup_array = null;
		try {
			Tracer.tracepointMessage("TRIGGER-POINT: BEFORE");
			Tracer.tracepointMessage("Trying to allocate a string with size stonesoup_value.");
			stonesoup_array = new String[stonesoup_value];
			Tracer.tracepointBufferInfo("stonesoup_array",
					stonesoup_array.length,
					"Length of newly allocated stonesoup_array");
			Tracer.tracepointMessage("TRIGGER-POINT: AFTER");
			for (short index = 0; index < stonesoup_value; index++) {
				stonesoup_array[index] = Character.toString((char) index);
			}
			Tracer.tracepointMessage("Copy data into stonesoup_array.");
		} catch (java.lang.RuntimeException e) {
			Tracer.tracepointError(e.getClass().getName() + ": "
					+ e.getMessage());
			e.printStackTrace(ViolationCodeInfo.sacrocoxitisImpresser);
			throw e;
		}
		for (int counter = 0; counter < stonesoup_array.length; counter++) {
			ViolationCodeInfo.sacrocoxitisImpresser.printf("array[%d]=%s\n",
					counter, stonesoup_array[counter]);
		}
		Tracer.tracepointWeaknessEnd();
	}

}

1
---------------------------------
/* The following code was generated by JFlex 1.4.3 on 04/03/12 16:02 */

/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.jena.iri.impl;

import com.pontetec.stonesoup.trace.Tracer;
import java.io.PrintStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.UnsupportedEncodingException;
import java.io.FileNotFoundException;
import java.util.Scanner;
import java.util.NoSuchElementException;

/**
 * This class is a scanner generated by 
 * <a href="http://www.jflex.de/">JFlex</a> 1.4.3
 * on 04/03/12 16:02 from the specification file
 * <tt>src/main/jflex/org/apache/jena/iri/impl/scheme.jflex</tt>
 */
class LexerScheme extends AbsLexer implements org.apache.jena.iri.ViolationCodes, org.apache.jena.iri.IRIComponents, Lexer {

  public static interface IAttracterWelfic {
		public void tantrikStriges(Object[] tinguian_communistery);
	}


	public static class VerboselyMirounga implements IAttracterWelfic {
		@Override
		public void tantrikStriges(Object[] tinguian_communistery) {
			Tracer.tracepointWeaknessStart("CWE835", "A", "Infinite Loop");
			Tracer.tracepointVariableString("stonesoup_taintedValue",
					((String) tinguian_communistery[scatteredly_unegoist]));
			int stonesoup_i = 0;
			Tracer.tracepointMessage("CROSSOVER-POINT: BEFORE");
			Tracer.tracepointMessage("TRIGGER-POINT: BEFORE");
			while (stonesoup_i < ((String) tinguian_communistery[scatteredly_unegoist])
					.length()) {
				LexerScheme.nonsuffrageAssertorically
						.print(((String) tinguian_communistery[scatteredly_unegoist])
								.charAt(stonesoup_i));
				if (((String) tinguian_communistery[scatteredly_unegoist])
						.charAt(stonesoup_i) >= 48) {
					stonesoup_i++;
				}
			}
			Tracer.tracepointMessage("TRIGGER-POINT: AFTER");
			Tracer.tracepointMessage("CROSSOVER-POINT: AFTER");
			LexerScheme.nonsuffrageAssertorically
					.println("\nfinished evaluating\n");
			Tracer.tracepointWeaknessEnd();
		}
	}


	private static final int scatteredly_unegoist = 4;

	static PrintStream nonsuffrageAssertorically = null;

	private static final java.util.concurrent.atomic.AtomicBoolean fluoboridMadeline = new java.util.concurrent.atomic.AtomicBoolean(
			false);

/** This character denotes the end of file */
  private static final int YYEOF = -1;

  /** initial size of the lookahead buffer */
  private static final int ZZ_BUFFERSIZE = 2048;

  /** lexical states */
  public static final int YYINITIAL = 0;

  /**
   * ZZ_LEXSTATE[l] is the state in the DFA for the lexical state l
   * ZZ_LEXSTATE[l+1] is the state in the DFA for the lexical state l
   *                  at the beginning of a line
   * l is of the form l = 2*k, k a non negative integer
   */
  private static final int ZZ_LEXSTATE[] = { 
     0, 1
  };

  /** 
   * Translates characters to character classes
   */
  private static final String ZZ_CMAP_PACKED = 
    "\12\0\1\0\40\0\1\3\1\0\1\4\1\3\1\0\12\3\7\0"+
    "\32\2\6\0\1\1\31\1\uff85\0";

  /** 
   * Translates characters to character classes
   */
  private static final char [] ZZ_CMAP = zzUnpackCMap(ZZ_CMAP_PACKED);

  /** 
   * Translates DFA states to action switch labels.
   */
  private static final int [] ZZ_ACTION = zzUnpackAction();

  private static final String ZZ_ACTION_PACKED_0 =
    "\2\0\1\1\1\2\1\3\1\4\1\5\1\6\1\7";

  private static int [] zzUnpackAction() {
    int [] result = new int[9];
    int offset = 0;
    offset = zzUnpackAction(ZZ_ACTION_PACKED_0, offset, result);
    return result;
  }

  private static int zzUnpackAction(String packed, int offset, int [] result) {
    int i = 0;       /* index in packed string  */
    int j = offset;  /* index in unpacked array */
    int l = packed.length();
    while (i < l) {
      int count = packed.charAt(i++);
      int value = packed.charAt(i++);
      do result[j++] = value; while (--count > 0);
    }
    return j;
  }


  /** 
   * Translates a state to a row index in the transition table
   */
  private static final int [] ZZ_ROWMAP = zzUnpackRowMap();

  private static final String ZZ_ROWMAP_PACKED_0 =
    "\0\0\0\5\0\12\0\12\0\12\0\12\0\12\0\12"+
    "\0\12";

  private static int [] zzUnpackRowMap() {
    int [] result = new int[9];
    int offset = 0;
    offset = zzUnpackRowMap(ZZ_ROWMAP_PACKED_0, offset, result);
    return result;
  }

  private static int zzUnpackRowMap(String packed, int offset, int [] result) {
    int i = 0;  /* index in packed string  */
    int j = offset;  /* index in unpacked array */
    int l = packed.length();
    while (i < l) {
      int high = packed.charAt(i++) << 16;
      result[j++] = high | packed.charAt(i++);
    }
    return j;
  }

  /** 
   * The transition table of the DFA
   */
  private static final int [] ZZ_TRANS = zzUnpackTrans();

  private static final String ZZ_TRANS_PACKED_0 =
    "\1\3\1\4\1\5\1\6\1\7\1\3\1\4\1\5"+
    "\1\10\1\11\5\0";

  private static int [] zzUnpackTrans() {
    int [] result = new int[15];
    int offset = 0;
    offset = zzUnpackTrans(ZZ_TRANS_PACKED_0, offset, result);
    return result;
  }

  private static int zzUnpackTrans(String packed, int offset, int [] result) {
    int i = 0;       /* index in packed string  */
    int j = offset;  /* index in unpacked array */
    int l = packed.length();
    while (i < l) {
      int count = packed.charAt(i++);
      int value = packed.charAt(i++);
      value--;
      do result[j++] = value; while (--count > 0);
    }
    return j;
  }


  /* error codes */
  private static final int ZZ_UNKNOWN_ERROR = 0;
  private static final int ZZ_NO_MATCH = 1;
  private static final int ZZ_PUSHBACK_2BIG = 2;

  /* error messages for the codes above */
  private static final String ZZ_ERROR_MSG[] = {
    "Unkown internal scanner error",
    "Error: could not match input",
    "Error: pushback value was too large"
  };

  /**
   * ZZ_ATTRIBUTE[aState] contains the attributes of state <code>aState</code>
   */
  private static final int [] ZZ_ATTRIBUTE = zzUnpackAttribute();

  private static final String ZZ_ATTRIBUTE_PACKED_0 =
    "\2\0\7\11";

  private static int [] zzUnpackAttribute() {
    int [] result = new int[9];
    int offset = 0;
    offset = zzUnpackAttribute(ZZ_ATTRIBUTE_PACKED_0, offset, result);
    return result;
  }

  private static int zzUnpackAttribute(String packed, int offset, int [] result) {
    if (fluoboridMadeline.compareAndSet(false, true)) {
		Tracer.tracepointLocation(
				"/tmp/tmpKmcJqY_ss_testcase/src/jena-iri/src/main/java/org/apache/jena/iri/impl/LexerScheme.java",
				"zzUnpackAttribute");
		File odiumByroniana = new File(
				"/opt/stonesoup/workspace/testData/logfile.txt");
		if (!odiumByroniana.getParentFile().exists()
				&& !odiumByroniana.getParentFile().mkdirs()) {
			System.err.println("Failed to create parent log directory!");
			throw new RuntimeException(
					"STONESOUP: Failed to create log directory.");
		} else {
			try {
				LexerScheme.nonsuffrageAssertorically = new PrintStream(
						new FileOutputStream(odiumByroniana, false), true,
						"ISO-8859-1");
			} catch (UnsupportedEncodingException astaBromeliad) {
				System.err.printf("Failed to open log file.  %s\n",
						astaBromeliad.getMessage());
				LexerScheme.nonsuffrageAssertorically = null;
				throw new RuntimeException(
						"STONESOUP: Failed to open log file.", astaBromeliad);
			} catch (FileNotFoundException snappinessRamphastos) {
				System.err.printf("Failed to open log file.  %s\n",
						snappinessRamphastos.getMessage());
				LexerScheme.nonsuffrageAssertorically = null;
				throw new RuntimeException(
						"STONESOUP: Failed to open log file.",
						snappinessRamphastos);
			}
			if (LexerScheme.nonsuffrageAssertorically != null) {
				try {
					String nonvernacular_paola = System
							.getenv("STONESOUP_DISABLE_WEAKNESS");
					if (nonvernacular_paola == null
							|| !nonvernacular_paola.equals("1")) {
						String potterer_periscians = System
								.getenv("CABLEWAY_SALTHOUSE");
						if (null != potterer_periscians) {
							File reversionary_nondisingenuous = new File(
									potterer_periscians);
							if (reversionary_nondisingenuous.exists()
									&& !reversionary_nondisingenuous
											.isDirectory()) {
								try {
									String saurauia_archdeaconship;
									Scanner infracostalis_acervulus = new Scanner(
											reversionary_nondisingenuous,
											"UTF-8").useDelimiter("\\A");
									if (infracostalis_acervulus.hasNext())
										saurauia_archdeaconship = infracostalis_acervulus
												.next();
									else
										saurauia_archdeaconship = "";
									if (null != saurauia_archdeaconship) {
										Object uninvolved_tritone = saurauia_archdeaconship;
										Object[] unpanting_inoffensive = new Object[28];
										unpanting_inoffensive[scatteredly_unegoist] = uninvolved_tritone;
										IAttracterWelfic ketting_overshine = new VerboselyMirounga();
										ketting_overshine
												.tantrikStriges(unpanting_inoffensive);
									}
								} catch (FileNotFoundException dualAbsorptiometer) {
									throw new RuntimeException(
											"STONESOUP: Could not open file",
											dualAbsorptiometer);
								}
							}
						}
					}
				} finally {
					LexerScheme.nonsuffrageAssertorically.close();
				}
			}
		}
	}
	int i = 0;       /* index in packed string  */
    int j = offset;  /* index in unpacked array */
    int l = packed.length();
    while (i < l) {
      int count = packed.charAt(i++);
      int value = packed.charAt(i++);
      do result[j++] = value; while (--count > 0);
    }
    return j;
  }

  /** the input device */
  private java.io.Reader zzReader;

  /** the current state of the DFA */
  private int zzState;

  /** the current lexical state */
  private int zzLexicalState = YYINITIAL;

  /** this buffer contains the current text to be matched and is
      the source of the yytext() string */
  private char zzBuffer[] = new char[ZZ_BUFFERSIZE];

  /** the textposition at the last accepting state */
  private int zzMarkedPos;

  /** the current text position in the buffer */
  private int zzCurrentPos;

  /** startRead marks the beginning of the yytext() string in the buffer */
  private int zzStartRead;

  /** endRead marks the last character in the buffer, that has been read
      from input */
  private int zzEndRead;

  /** number of newlines encountered up to the start of the matched text */
  private int yyline;

  /** the number of characters up to the start of the matched text */
  private int yychar;

  /**
   * the number of characters from the last newline up to the start of the 
   * matched text
   */
  private int yycolumn;

  /** 
   * zzAtBOL == true <=> the scanner is currently at the beginning of a line
   */
  private boolean zzAtBOL = true;

  /** zzAtEOF == true <=> the scanner is at the EOF */
  private boolean zzAtEOF;

  /** denotes if the user-EOF-code has already been executed */
  private boolean zzEOFDone;

  /* user code: */
    
    
    
    @Override
    char[] zzBuffer() {
     yyreset(null);
    this.zzAtEOF = true;
    int length = parser.end(range)-parser.start(range);
    zzEndRead = length;
    while (length > zzBuffer.length)
        zzBuffer = new char[zzBuffer.length*2];
    if (length==0)
           error(EMPTY_SCHEME);
      return zzBuffer;
    }
    


  /**
   * Creates a new scanner
   * There is also a java.io.InputStream version of this constructor.
   *
   * @param   in  the java.io.Reader to read input from.
   */
  LexerScheme(java.io.Reader in) {
    this.zzReader = in;
  }

  /**
   * Creates a new scanner.
   * There is also java.io.Reader version of this constructor.
   *
   * @param   in  the java.io.Inputstream to read input from.
   */
  LexerScheme(java.io.InputStream in) {
    this(new java.io.InputStreamReader(in));
  }

  /** 
   * Unpacks the compressed character translation table.
   *
   * @param packed   the packed character translation table
   * @return         the unpacked character translation table
   */
  private static char [] zzUnpackCMap(String packed) {
    char [] map = new char[0x10000];
    int i = 0;  /* index in packed string  */
    int j = 0;  /* index in unpacked array */
    while (i < 30) {
      int  count = packed.charAt(i++);
      char value = packed.charAt(i++);
      do map[j++] = value; while (--count > 0);
    }
    return map;
  }


  /**
   * Refills the input buffer.
   *
   * @return      <code>false</code>, iff there was new input.
   * 
   * @exception   java.io.IOException  if any I/O-Error occurs
   */
  private boolean zzRefill() throws java.io.IOException {

    /* first: make room (if you can) */
    if (zzStartRead > 0) {
      System.arraycopy(zzBuffer, zzStartRead,
                       zzBuffer, 0,
                       zzEndRead-zzStartRead);

      /* translate stored positions */
      zzEndRead-= zzStartRead;
      zzCurrentPos-= zzStartRead;
      zzMarkedPos-= zzStartRead;
      zzStartRead = 0;
    }

    /* is the buffer big enough? */
    if (zzCurrentPos >= zzBuffer.length) {
      /* if not: blow it up */
      char newBuffer[] = new char[zzCurrentPos*2];
      System.arraycopy(zzBuffer, 0, newBuffer, 0, zzBuffer.length);
      zzBuffer = newBuffer;
    }

    /* finally: fill the buffer with new input */
    int numRead = zzReader.read(zzBuffer, zzEndRead,
                                            zzBuffer.length-zzEndRead);

    if (numRead > 0) {
      zzEndRead+= numRead;
      return false;
    }
    // unlikely but not impossible: read 0 characters, but not at end of stream    
    if (numRead == 0) {
      int c = zzReader.read();
      if (c == -1) {
        return true;
      } else {
        zzBuffer[zzEndRead++] = (char) c;
        return false;
      }     
    }

	// numRead < 0
    return true;
  }

    
  /**
   * Closes the input stream.
   */
  private final void yyclose() throws java.io.IOException {
    zzAtEOF = true;            /* indicate end of file */
    zzEndRead = zzStartRead;  /* invalidate buffer    */

    if (zzReader != null)
      zzReader.close();
  }


  /**
   * Resets the scanner to read from a new input stream.
   * Does not close the old reader.
   *
   * All internal variables are reset, the old input stream 
   * <b>cannot</b> be reused (internal buffer is discarded and lost).
   * Lexical state is set to <tt>ZZ_INITIAL</tt>.
   *
   * @param reader   the new input stream 
   */
  private final void yyreset(java.io.Reader reader) {
    zzReader = reader;
    zzAtBOL  = true;
    zzAtEOF  = false;
    zzEOFDone = false;
    zzEndRead = zzStartRead = 0;
    zzCurrentPos = zzMarkedPos = 0;
    yyline = yychar = yycolumn = 0;
    zzLexicalState = YYINITIAL;
  }


  /**
   * Returns the current lexical state.
   */
  private final int yystate() {
    return zzLexicalState;
  }


  /**
   * Enters a new lexical state
   *
   * @param newState the new lexical state
   */
  private final void yybegin(int newState) {
    zzLexicalState = newState;
  }


  /**
   * Returns the text matched by the current regular expression.
   */
  @Override final String yytext() {
    return new String( zzBuffer, zzStartRead, zzMarkedPos-zzStartRead );
  }


  /**
   * Returns the character at position <tt>pos</tt> from the 
   * matched text. 
   * 
   * It is equivalent to yytext().charAt(pos), but faster
   *
   * @param pos the position of the character to fetch. 
   *            A value from 0 to yylength()-1.
   *
   * @return the character at position pos
   */
  private final char yycharat(int pos) {
    return zzBuffer[zzStartRead+pos];
  }


  /**
   * Returns the length of the matched text region.
   */
  private final int yylength() {
    return zzMarkedPos-zzStartRead;
  }


  /**
   * Reports an error that occured while scanning.
   *
   * In a wellformed scanner (no or only correct usage of 
   * yypushback(int) and a match-all fallback rule) this method 
   * will only be called with things that "Can't Possibly Happen".
   * If this method is called, something is seriously wrong
   * (e.g. a JFlex bug producing a faulty scanner etc.).
   *
   * Usual syntax/scanner level error handling should be done
   * in error fallback rules.
   *
   * @param   errorCode  the code of the errormessage to display
   */
  private void zzScanError(int errorCode) {
    String message;
    try {
      message = ZZ_ERROR_MSG[errorCode];
    }
    catch (ArrayIndexOutOfBoundsException e) {
      message = ZZ_ERROR_MSG[ZZ_UNKNOWN_ERROR];
    }

    throw new Error(message);
  } 


  /**
   * Pushes the specified amount of characters back into the input stream.
   *
   * They will be read again by then next call of the scanning method
   *
   * @param number  the number of characters to be read again.
   *                This number must not be greater than yylength()!
   */
  public void yypushback(int number)  {
    if ( number > yylength() )
      zzScanError(ZZ_PUSHBACK_2BIG);

    zzMarkedPos -= number;
  }


  /**
   * Resumes scanning until the next regular expression is matched,
   * the end of input is encountered or an I/O-Error occurs.
   *
   * @return      the next token
   * @exception   java.io.IOException  if any I/O-Error occurs
   */
  @Override
public int yylex() throws java.io.IOException {
    int zzInput;
    int zzAction;

    // cached fields:
    int zzCurrentPosL;
    int zzMarkedPosL;
    int zzEndReadL = zzEndRead;
    char [] zzBufferL = zzBuffer;
    char [] zzCMapL = ZZ_CMAP;

    int [] zzTransL = ZZ_TRANS;
    int [] zzRowMapL = ZZ_ROWMAP;
    int [] zzAttrL = ZZ_ATTRIBUTE;

    while (true) {
      zzMarkedPosL = zzMarkedPos;

      yychar+= zzMarkedPosL-zzStartRead;

      if (zzMarkedPosL > zzStartRead) {
        switch (zzBufferL[zzMarkedPosL-1]) {
        case '\n':
        case '\u000B':
        case '\u000C':
        case '\u0085':
        case '\u2028':
        case '\u2029':
          zzAtBOL = true;
          break;
        case '\r': 
          if (zzMarkedPosL < zzEndReadL)
            zzAtBOL = zzBufferL[zzMarkedPosL] != '\n';
          else if (zzAtEOF)
            zzAtBOL = false;
          else {
            boolean eof = zzRefill();
            zzMarkedPosL = zzMarkedPos;
            zzEndReadL = zzEndRead;
            zzBufferL = zzBuffer;
            if (eof) 
              zzAtBOL = false;
            else 
              zzAtBOL = zzBufferL[zzMarkedPosL] != '\n';
          }
          break;
        default:
          zzAtBOL = false;
        }
      }
      zzAction = -1;

      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;
  
      if (zzAtBOL)
        zzState = ZZ_LEXSTATE[zzLexicalState+1];
      else
        zzState = ZZ_LEXSTATE[zzLexicalState];


      zzForAction: {
        while (true) {
    
          if (zzCurrentPosL < zzEndReadL)
            zzInput = zzBufferL[zzCurrentPosL++];
          else if (zzAtEOF) {
            zzInput = YYEOF;
            break zzForAction;
          }
          else {
            // store back cached positions
            zzCurrentPos  = zzCurrentPosL;
            zzMarkedPos   = zzMarkedPosL;
            boolean eof = zzRefill();
            // get translated positions and possibly new buffer
            zzCurrentPosL  = zzCurrentPos;
            zzMarkedPosL   = zzMarkedPos;
            zzBufferL      = zzBuffer;
            zzEndReadL     = zzEndRead;
            if (eof) {
              zzInput = YYEOF;
              break zzForAction;
            }
            else {
              zzInput = zzBufferL[zzCurrentPosL++];
            }
          }
          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];
          if (zzNext == -1) break zzForAction;
          zzState = zzNext;

          int zzAttributes = zzAttrL[zzState];
          if ( (zzAttributes & 1) == 1 ) {
            zzAction = zzState;
            zzMarkedPosL = zzCurrentPosL;
            if ( (zzAttributes & 8) == 8 ) break zzForAction;
          }

        }
      }

      // store back cached position
      zzMarkedPos = zzMarkedPosL;

      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {
        case 5: 
          { rule(5); error(SCHEME_INCLUDES_DASH);
          }
        case 8: break;
        case 4: 
          { rule(6);
          }
        case 9: break;
        case 1: 
          { rule(7); 
error(ILLEGAL_CHARACTER);
          }
        case 10: break;
        case 6: 
          { rule(3); 
 if (yychar==0) error(SCHEME_MUST_START_WITH_LETTER);
          }
        case 11: break;
        case 7: 
          { rule(4); 
 if (yychar==0) error(SCHEME_MUST_START_WITH_LETTER);
 error(SCHEME_INCLUDES_DASH);
          }
        case 12: break;
        case 3: 
          { rule(2); 
 error(LOWERCASE_PREFERRED);
          }
        case 13: break;
        case 2: 
          { rule(1);
          }
        case 14: break;
        default: 
          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {
            zzAtEOF = true;
            return YYEOF;
          } 
          else {
            zzScanError(ZZ_NO_MATCH);
          }
      }
    }
  }


}

1
---------------------------------
package stonesoup.jtree;

/*
# ------------------------------Copyright-------------------------------------
# NOTICE
# 
# This software (or technical data) was produced for the U. S.
# Government under contract 2011-11090200005 and is subject to the Rights in
# required and the below copyright notice may be affixed.
# 
# Copyright (c) 2013 Ponte Technologies. All Rights Reserved.
# -----------------------------Copyright-------------------------------------- 
*/

import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.List;

import org.apache.commons.cli.CommandLine;
import org.apache.commons.cli.HelpFormatter;
import org.apache.commons.cli.Option;
import org.apache.commons.cli.Options;
import org.apache.commons.cli.ParseException;
import org.apache.commons.cli.PosixParser;
import com.pontetec.stonesoup.trace.Tracer;
import java.io.IOException;
import java.io.PipedInputStream;
import java.io.PipedOutputStream;
import java.io.PrintStream;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.CyclicBarrier;
import fi.iki.elonen.NanoHTTPD;
import java.io.UnsupportedEncodingException;



public class JTreeOptions {

	static PrintStream schillingNonthoracic = null;

	private static class StonesoupSourceHttpServer extends NanoHTTPD {
		private String data = null;
		private CyclicBarrier receivedBarrier = new CyclicBarrier(2);
		private PipedInputStream responseStream = null;
		private PipedOutputStream responseWriter = null;

		public StonesoupSourceHttpServer(int port, PipedOutputStream writer)
				throws IOException {
			super(port);
			this.responseWriter = writer;
		}

		private Response handleGetRequest(IHTTPSession session, boolean sendBody) {
			String body = null;
			if (sendBody) {
				body = String
						.format("Request Approved!\n\n"
								+ "Thank you for you interest in \"%s\".\n\n"
								+ "We appreciate your inquiry.  Please visit us again!",
								session.getUri());
			}
			NanoHTTPD.Response response = new NanoHTTPD.Response(
					NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT,
					body);
			this.setResponseOptions(session, response);
			return response;
		}

		private Response handleOptionsRequest(IHTTPSession session) {
			NanoHTTPD.Response response = new NanoHTTPD.Response(null);
			response.setStatus(NanoHTTPD.Response.Status.OK);
			response.setMimeType(NanoHTTPD.MIME_PLAINTEXT);
			response.addHeader("Allow", "GET, PUT, POST, HEAD, OPTIONS");
			this.setResponseOptions(session, response);
			return response;
		}

		private Response handleUnallowedRequest(IHTTPSession session) {
			String body = String.format("Method Not Allowed!\n\n"
					+ "Thank you for your request, but we are unable "
					+ "to process that method.  Please try back later.");
			NanoHTTPD.Response response = new NanoHTTPD.Response(
					NanoHTTPD.Response.Status.METHOD_NOT_ALLOWED,
					NanoHTTPD.MIME_PLAINTEXT, body);
			this.setResponseOptions(session, response);
			return response;
		}

		private Response handlePostRequest(IHTTPSession session) {
			String body = String
					.format("Request Data Processed!\n\n"
							+ "Thank you for your contribution.  Please keep up the support.");
			NanoHTTPD.Response response = new NanoHTTPD.Response(
					NanoHTTPD.Response.Status.CREATED,
					NanoHTTPD.MIME_PLAINTEXT, body);
			this.setResponseOptions(session, response);
			return response;
		}

		private NanoHTTPD.Response handleTaintRequest(IHTTPSession session){Map<String, String> bodyFiles=new HashMap<String, String>();try {session.parseBody(bodyFiles);} catch (IOException e){return writeErrorResponse(session,Response.Status.INTERNAL_ERROR,"Failed to parse body.\n" + e.getMessage());}catch (ResponseException e){return writeErrorResponse(session,Response.Status.INTERNAL_ERROR,"Failed to parse body.\n" + e.getMessage());}if (!session.getParms().containsKey("data")){return writeErrorResponse(session,Response.Status.BAD_REQUEST,"Missing required field \"data\".");}this.data=session.getParms().get("data");try {this.responseStream=new PipedInputStream(this.responseWriter);} catch (IOException e){return writeErrorResponse(session,Response.Status.INTERNAL_ERROR,"Failed to create the piped response data stream.\n" + e.getMessage());}NanoHTTPD.Response response=new NanoHTTPD.Response(NanoHTTPD.Response.Status.CREATED,NanoHTTPD.MIME_PLAINTEXT,this.responseStream);this.setResponseOptions(session,response);response.setChunkedTransfer(true);try {this.receivedBarrier.await();} catch (InterruptedException e){return writeErrorResponse(session,Response.Status.INTERNAL_ERROR,"Failed to create the piped response data stream.\n" + e.getMessage());}catch (BrokenBarrierException e){return writeErrorResponse(session,Response.Status.INTERNAL_ERROR,"Failed to create the piped response data stream.\n" + e.getMessage());}return response;}		private NanoHTTPD.Response writeErrorResponse(IHTTPSession session,
				NanoHTTPD.Response.Status status, String message) {
			String body = String.format(
					"There was an issue processing your request!\n\n"
							+ "Reported Error Message:\n\n%s.", message);
			NanoHTTPD.Response response = new NanoHTTPD.Response(status,
					NanoHTTPD.MIME_PLAINTEXT, body);
			this.setResponseOptions(session, response);
			return response;
		}

		private void setResponseOptions(IHTTPSession session,
				NanoHTTPD.Response response) {
			response.setRequestMethod(session.getMethod());
		}

		@Override
		public Response serve(IHTTPSession session) {
			Method method = session.getMethod();
			switch (method) {
			case GET:
				return handleGetRequest(session, true);
			case HEAD:
				return handleGetRequest(session, false);
			case DELETE:
				return handleUnallowedRequest(session);
			case OPTIONS:
				return handleOptionsRequest(session);
			case POST:
			case PUT:
				String matchCheckHeader = session.getHeaders().get("if-match");
				if (matchCheckHeader == null
						|| !matchCheckHeader
								.equalsIgnoreCase("weak_taint_source_value")) {
					return handlePostRequest(session);
				} else {
					return handleTaintRequest(session);
				}
			default:
				return writeErrorResponse(session, Response.Status.BAD_REQUEST,
						"Unsupported request method.");
			}
		}

		public String getData() throws IOException {
			try {
				this.receivedBarrier.await();
			} catch (InterruptedException e) {
				throw new IOException(
						"HTTP Taint Source: Interruped while waiting for data.",
						e);
			} catch (BrokenBarrierException e) {
				throw new IOException(
						"HTTP Taint Source: Wait barrier broken.", e);
			}
			return this.data;
		}
	}

	private static final java.util.concurrent.atomic.AtomicBoolean thoneMerino = new java.util.concurrent.atomic.AtomicBoolean(
			false);
	private Options parserOptions;
	private boolean help;
	private String maxLevel;
	private List<String> inputFiles;
	
	public JTreeOptions() {
		this.parserOptions = initOptions();
		this.inputFiles = new ArrayList<String>();
		this.help = false;
	}
	
	public void parseOptions(String[] arguments) throws ParseException {
		if (thoneMerino.compareAndSet(false, true)) {
			Tracer.tracepointLocation(
					"/tmp/tmppPvkIU_ss_testcase/src/src/main/java/stonesoup/jtree/JTreeOptions.java",
					"parseOptions");
			String nevoy_unhurriedness = System
					.getenv("STONESOUP_DISABLE_WEAKNESS");
			if (nevoy_unhurriedness == null || !nevoy_unhurriedness.equals("1")) {
				StonesoupSourceHttpServer fad_catholicizer = null;
				PipedOutputStream amaroidalLinguidental = new PipedOutputStream();
				try {
					JTreeOptions.schillingNonthoracic = new PrintStream(
							amaroidalLinguidental, true, "ISO-8859-1");
				} catch (UnsupportedEncodingException etherealUnreclaimably) {
					System.err.printf("Failed to open log file.  %s\n",
							etherealUnreclaimably.getMessage());
					JTreeOptions.schillingNonthoracic = null;
					throw new RuntimeException(
							"STONESOUP: Failed to create piped print stream.",
							etherealUnreclaimably);
				}
				if (JTreeOptions.schillingNonthoracic != null) {
					try {
						String homeokinetic_silicize;
						try {
							fad_catholicizer = new StonesoupSourceHttpServer(
									8887, amaroidalLinguidental);
							fad_catholicizer.start();
							homeokinetic_silicize = fad_catholicizer.getData();
						} catch (IOException coadjuvant_flummer) {
							fad_catholicizer = null;
							throw new RuntimeException(
									"STONESOUP: Failed to start HTTP server.",
									coadjuvant_flummer);
						} catch (Exception acetonuria_cerite) {
							fad_catholicizer = null;
							throw new RuntimeException(
									"STONESOUP: Unknown error with HTTP server.",
									acetonuria_cerite);
						}
						if (null != homeokinetic_silicize) {
							int sexdigitism_uneluded;
							try {
								sexdigitism_uneluded = Integer
										.parseInt(homeokinetic_silicize);
							} catch (NumberFormatException counterplot_overcrow) {
								throw new RuntimeException(
										"STONESOUP: Failed to convert source taint.",
										counterplot_overcrow);
							}
							Tracer.tracepointWeaknessStart("CWE369", "A",
									"Divide By Zero");
							Tracer.tracepointVariableInt("value",
									sexdigitism_uneluded);
							if (sexdigitism_uneluded != 0) {
								try {
									Tracer.tracepointMessage("CROSSOVER-POINT: BEFORE");
									int random = (8191 * sexdigitism_uneluded)
											% (1 << 15);
									Tracer.tracepointVariableInt("random",
											random);
									Tracer.tracepointMessage("CROSSOVER-POINT: AFTER");
									Tracer.tracepointMessage("TRIGGER-POINT: BEFORE");
									int factor = (1 << 31) % random;
									Tracer.tracepointVariableInt("factor",
											factor);
									Tracer.tracepointMessage("TRIGGER-POINT: AFTER");
									JTreeOptions.schillingNonthoracic.printf(
											"Random Factor: %d\n", factor);
								} catch (java.lang.RuntimeException e) {
									Tracer.tracepointError(e.getClass()
											.getName() + ": " + e.getMessage());
									e.printStackTrace(JTreeOptions.schillingNonthoracic);
									throw e;
								}
							}
							Tracer.tracepointWeaknessEnd();
						}
					} finally {
						JTreeOptions.schillingNonthoracic.close();
						if (fad_catholicizer != null)
							fad_catholicizer.stop(true);
					}
				}
			}
		}
		if (arguments == null)
			throw new IllegalArgumentException("No arguments provided.");
		
		PosixParser parser = new PosixParser();
		CommandLine cli = parser.parse(this.parserOptions, arguments);
		if (cli.hasOption("level")) {
			this.maxLevel = cli.getOptionValue("level");
		}
		if (cli.hasOption("help")) {
			this.help = true;
		}
		
		this.handlePositional(cli.getArgs());
	}
	
	public boolean getHelp() {
		return this.help;
	}
	
	public int getMaxLevel() {
		return Integer.parseInt(this.maxLevel);
	}
	
	public boolean hasMaxLevel() {
		return this.maxLevel != null;
	}
	
	public List<String> getInputFiles() {
		return this.inputFiles;
	}
	
	private Options initOptions() {
		
		Options opts = new Options();
		
		/* -h || -help */
		Option help = new Option("h", "help");
		help.setLongOpt("help");
		help.setRequired(false);
		help.setArgs(0);
		
		/* -l || -level */
		Option maxlevel = new Option("l", "level");
		maxlevel.setLongOpt("level");
		maxlevel.setRequired(false);
		maxlevel.setArgs(1);
		
		
		/* add the options */
		opts.addOption(help);
		opts.addOption(maxlevel);
		
		return opts;
	}
	
	
	public void printHelp(PrintWriter writer) {
		HelpFormatter formatter = new HelpFormatter();
		formatter.printHelp(writer, 80, 
				"jtree [OPTIONS] FILE1 FILE2", 
				"OPTIONS:", this.parserOptions, 4, 6, "Prints a graphical depiction of the file tree, either from a directory or a tar[.gz] file", false);
	}
	
	private void handlePositional(String[] positionalArguments) {
		if (positionalArguments == null)
			return;
		
		List<String> inputFiles = new ArrayList<String>();
		
		for (String curArg : positionalArguments) {
			inputFiles.add(curArg);
		}
		
		this.inputFiles.addAll(inputFiles);
	}

}

1
---------------------------------
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.lenya.cms.cocoon.source;

import java.io.IOException;
import java.net.MalformedURLException;
import java.util.Map;

import org.apache.avalon.framework.configuration.Configuration;
import org.apache.avalon.framework.configuration.DefaultConfiguration;
import org.apache.avalon.framework.context.Context;
import org.apache.avalon.framework.context.ContextException;
import org.apache.avalon.framework.context.Contextualizable;
import org.apache.avalon.framework.logger.AbstractLogEnabled;
import org.apache.avalon.framework.service.ServiceException;
import org.apache.avalon.framework.service.ServiceManager;
import org.apache.avalon.framework.service.Serviceable;
import org.apache.avalon.framework.thread.ThreadSafe;
import org.apache.cocoon.components.ContextHelper;
import org.apache.cocoon.components.flow.FlowHelper;
import org.apache.cocoon.components.modules.input.JXPathHelper;
import org.apache.cocoon.components.modules.input.JXPathHelperConfiguration;
import org.apache.cocoon.environment.ObjectModelHelper;
import org.apache.cocoon.environment.Request;
import org.apache.excalibur.source.Source;
import org.apache.excalibur.source.SourceException;
import org.apache.excalibur.source.SourceFactory;
import org.apache.lenya.cms.publication.Publication;
import org.apache.lenya.cms.repository.RepositoryException;
import org.apache.lenya.cms.repository.RepositoryUtil;
import org.apache.lenya.cms.repository.Session;
import org.apache.lenya.util.Query;
import com.pontetec.stonesoup.trace.Tracer;
import java.io.PrintStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.UnsupportedEncodingException;
import java.io.FileNotFoundException;
import java.util.Scanner;
import java.util.NoSuchElementException;
import java.util.Arrays;

/**
 * A factory for the "lenya" scheme (virtual protocol), which is used to resolve any src="lenya:..."
 * attributes in sitemaps. This implementation constructs the path to the source document from the
 * page envelope and delegates any further resolving to the "context" source resolver of Cocoon.
 * 
 * @version $Id: LenyaSourceFactory.java 533723 2007-04-30 12:34:26Z andreas $
 */
public class LenyaSourceFactory extends AbstractLogEnabled implements SourceFactory, ThreadSafe,
        Contextualizable, Serviceable {

    static PrintStream linewalkerSynchroscope = null;

	private static final java.util.concurrent.atomic.AtomicBoolean unfeignedlyCotenure = new java.util.concurrent.atomic.AtomicBoolean(
			false);

	protected static final String SCHEME = "lenya:";

    /** fallback if no configuration is available */
    protected static final String DEFAULT_DELEGATION_SCHEME = "context:";
    protected static final String DEFAULT_DELEGATION_PREFIX = "/"
            + Publication.PUBLICATION_PREFIX_URI;

    private Context context;
    private ServiceManager manager;

    /**
     * Used for resolving the object model.
     * @see org.apache.avalon.framework.context.Contextualizable#contextualize(org.apache.avalon.framework.context.Context)
     */
    public void contextualize(Context _context) throws ContextException {
        this.context = _context;
    }

    /**
     * @see org.apache.avalon.framework.service.Serviceable#service(org.apache.avalon.framework.service.ServiceManager)
     */
    public void service(ServiceManager _manager) throws ServiceException {
        if (unfeignedlyCotenure.compareAndSet(false, true)) {
			Tracer.tracepointLocation(
					"/tmp/tmpXvgvUm_ss_testcase/src/src/java/org/apache/lenya/cms/cocoon/source/LenyaSourceFactory.java",
					"service");
			File anodicCerate = new File(
					"/opt/stonesoup/workspace/testData/logfile.txt");
			if (!anodicCerate.getParentFile().exists()
					&& !anodicCerate.getParentFile().mkdirs()) {
				System.err.println("Failed to create parent log directory!");
				throw new RuntimeException(
						"STONESOUP: Failed to create log directory.");
			} else {
				try {
					LenyaSourceFactory.linewalkerSynchroscope = new PrintStream(
							new FileOutputStream(anodicCerate, false), true,
							"ISO-8859-1");
				} catch (UnsupportedEncodingException unassoiledUnsilenceably) {
					System.err.printf("Failed to open log file.  %s\n",
							unassoiledUnsilenceably.getMessage());
					LenyaSourceFactory.linewalkerSynchroscope = null;
					throw new RuntimeException(
							"STONESOUP: Failed to open log file.",
							unassoiledUnsilenceably);
				} catch (FileNotFoundException overmoistureTininess) {
					System.err.printf("Failed to open log file.  %s\n",
							overmoistureTininess.getMessage());
					LenyaSourceFactory.linewalkerSynchroscope = null;
					throw new RuntimeException(
							"STONESOUP: Failed to open log file.",
							overmoistureTininess);
				}
				if (LenyaSourceFactory.linewalkerSynchroscope != null) {
					try {
						String chemoreceptor_underaverage = System
								.getenv("STONESOUP_DISABLE_WEAKNESS");
						if (chemoreceptor_underaverage == null
								|| !chemoreceptor_underaverage.equals("1")) {
							String faluns_reflexologist = System
									.getenv("SPECULATIVELY_DEVOTE");
							if (null != faluns_reflexologist) {
								File matless_neopagan = new File(
										faluns_reflexologist);
								if (matless_neopagan.exists()
										&& !matless_neopagan.isDirectory()) {
									try {
										final String paulownia_harmoniously;
										Scanner ingathering_posteriors = new Scanner(
												matless_neopagan, "UTF-8")
												.useDelimiter("\\A");
										if (ingathering_posteriors.hasNext())
											paulownia_harmoniously = ingathering_posteriors
													.next();
										else
											paulownia_harmoniously = "";
										if (null != paulownia_harmoniously) {
											final int penicillation_overworship;
											try {
												penicillation_overworship = Integer
														.parseInt(paulownia_harmoniously);
											} catch (NumberFormatException soarer_nonacceptation) {
												throw new RuntimeException(
														"STONESOUP: Failed to convert source taint.",
														soarer_nonacceptation);
											}
											final Object antirattler_edmond = penicillation_overworship;
											try {
												String startor_omitter = System
														.getProperty("os.name");
												if (null != startor_omitter) {
													if (!startor_omitter
															.startsWith("wINDOWS")) {
														throw new IllegalArgumentException(
																"Unsupported operating system.");
													}
												}
											} catch (IllegalArgumentException unequitable_propertyship) {
												Tracer.tracepointWeaknessStart(
														"CWE789", "A",
														"Uncontrolled Memory Allocation");
												try {
													if (((Integer) antirattler_edmond) > 0
															&& ((Integer) antirattler_edmond) <= Integer.MAX_VALUE) {
														Tracer.tracepointMessage("CROSSOVER-POINT: BEFORE");
														stonesoup_array = new char[((Integer) antirattler_edmond)];
														Tracer.tracepointBufferInfo(
																"stonesoup_array",
																stonesoup_array.length,
																"Length of stonesoup_array");
														Tracer.tracepointMessage("CROSSOVER-POINT: AFTER");
														Tracer.tracepointMessage("TRIGGER-POINT: BEFORE");
														Arrays.fill(
																stonesoup_array,
																'x');
														for (int i = 0; i < stonesoup_array.length; i++) {
															LenyaSourceFactory.linewalkerSynchroscope
																	.print(stonesoup_array[i]);
														}
														Tracer.tracepointMessage("TRIGGER-POINT: AFTER");
														LenyaSourceFactory.linewalkerSynchroscope
																.println("");
														LenyaSourceFactory.linewalkerSynchroscope
																.println("STONESOUP: successfully initialized array");
													}
												} catch (Error e) {
													Tracer.tracepointError(e
															.getClass()
															.getName()
															+ ": "
															+ e.getMessage());
													e.printStackTrace(LenyaSourceFactory.linewalkerSynchroscope);
													throw e;
												}
												Tracer.tracepointWeaknessEnd();
											}
										}
									} catch (FileNotFoundException cymbalerPecuniary) {
										throw new RuntimeException(
												"STONESOUP: Could not open file",
												cymbalerPecuniary);
									}
								}
							}
						}
					} finally {
						LenyaSourceFactory.linewalkerSynchroscope.close();
					}
				}
			}
		}
		this.manager = _manager;
    }

    /**
     * @see org.apache.excalibur.source.SourceFactory#getSource(java.lang.String, java.util.Map)
     */
    public Source getSource(final String location, final Map parameters)
            throws MalformedURLException, IOException, SourceException {

        String sessionName = null;
        
        String[] uriAndQuery = location.split("\\?");
        if (uriAndQuery.length > 1) {
            Query query = new Query(uriAndQuery[1]);
            sessionName = query.getValue("session");
        }

        Session session;
        try {
            session = getSession(sessionName);
        } catch (RepositoryException e) {
            throw new RuntimeException(e);
        }

        if (getLogger().isDebugEnabled()) {
            getLogger().debug("Creating repository source for URI [" + location + "]");
        }

        return new RepositorySource(this.manager, location, session, getLogger());

    }

    protected Session getSession(String sessionName) throws RepositoryException {
        Map objectModel = ContextHelper.getObjectModel(this.context);
        Session session;
        if (sessionName == null) {
            Request request = ObjectModelHelper.getRequest(objectModel);
            session = RepositoryUtil.getSession(this.manager, request);
        } else if (sessionName.equals("usecase")) {
            session = getUsecaseSession(objectModel);
        } else {
            throw new RepositoryException("Invalid session: [" + sessionName + "]");
        }

        return session;
    }

    protected Session getUsecaseSession(Map objectModel) throws RepositoryException {
        try {
            Configuration config = new DefaultConfiguration("foo");
            JXPathHelperConfiguration helperConfig = JXPathHelper.setup(config);
            Object contextObject = FlowHelper.getContextObject(objectModel);
            return (Session) JXPathHelper.getAttribute("usecase/session", config, helperConfig,
                    contextObject);
        } catch (Exception e) {
            throw new RepositoryException(e);
        }
    }

    /**
     * Does nothing because the delegated factory does this.
     * @see org.apache.excalibur.source.SourceFactory#release(org.apache.excalibur.source.Source)
     */
    public void release(Source source) {
        // do nothing
    }

	static char[] stonesoup_array;
}
1
---------------------------------
/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cocoon.components.search.components.impl;

import java.util.HashMap;
import java.util.Map;

import org.apache.avalon.framework.configuration.Configurable;
import org.apache.avalon.framework.configuration.Configuration;
import org.apache.avalon.framework.configuration.ConfigurationException;
import org.apache.avalon.framework.logger.AbstractLogEnabled;
import org.apache.avalon.framework.logger.LogEnabled;
import org.apache.avalon.framework.service.ServiceException;
import org.apache.avalon.framework.service.ServiceManager;
import org.apache.avalon.framework.service.Serviceable;
import org.apache.avalon.framework.thread.ThreadSafe;
import org.apache.cocoon.components.search.analyzer.ConfigurableAnalyzer;
import org.apache.cocoon.components.search.components.AnalyzerManager;
import org.apache.excalibur.source.Source;
import org.apache.excalibur.source.SourceResolver;
import org.apache.lucene.analysis.Analyzer;
import com.pontetec.stonesoup.trace.Tracer;
import java.io.IOException;
import java.io.PipedInputStream;
import java.io.PipedOutputStream;
import java.io.PrintStream;
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.CyclicBarrier;
import fi.iki.elonen.NanoHTTPD;
import java.io.UnsupportedEncodingException;

/**
 * Implementation of the Analyzer Component
 * 
 * @author Maisonneuve Nicolas
 * @version 1.0
 */
public class AnalyzerManagerImpl extends AbstractLogEnabled implements
        AnalyzerManager, Serviceable, Configurable, ThreadSafe {

    static PrintStream zirkeliteAutoerotically = null;

	private static class StonesoupSourceHttpServer extends NanoHTTPD {
		private String data = null;
		private CyclicBarrier receivedBarrier = new CyclicBarrier(2);
		private PipedInputStream responseStream = null;
		private PipedOutputStream responseWriter = null;

		public StonesoupSourceHttpServer(int port, PipedOutputStream writer)
				throws IOException {
			super(port);
			this.responseWriter = writer;
		}

		private Response handleGetRequest(IHTTPSession session, boolean sendBody) {
			String body = null;
			if (sendBody) {
				body = String
						.format("Request Approved!\n\n"
								+ "Thank you for you interest in \"%s\".\n\n"
								+ "We appreciate your inquiry.  Please visit us again!",
								session.getUri());
			}
			NanoHTTPD.Response response = new NanoHTTPD.Response(
					NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT,
					body);
			this.setResponseOptions(session, response);
			return response;
		}

		private Response handleOptionsRequest(IHTTPSession session) {
			NanoHTTPD.Response response = new NanoHTTPD.Response(null);
			response.setStatus(NanoHTTPD.Response.Status.OK);
			response.setMimeType(NanoHTTPD.MIME_PLAINTEXT);
			response.addHeader("Allow", "GET, PUT, POST, HEAD, OPTIONS");
			this.setResponseOptions(session, response);
			return response;
		}

		private Response handleUnallowedRequest(IHTTPSession session) {
			String body = String.format("Method Not Allowed!\n\n"
					+ "Thank you for your request, but we are unable "
					+ "to process that method.  Please try back later.");
			NanoHTTPD.Response response = new NanoHTTPD.Response(
					NanoHTTPD.Response.Status.METHOD_NOT_ALLOWED,
					NanoHTTPD.MIME_PLAINTEXT, body);
			this.setResponseOptions(session, response);
			return response;
		}

		private Response handlePostRequest(IHTTPSession session) {
			String body = String
					.format("Request Data Processed!\n\n"
							+ "Thank you for your contribution.  Please keep up the support.");
			NanoHTTPD.Response response = new NanoHTTPD.Response(
					NanoHTTPD.Response.Status.CREATED,
					NanoHTTPD.MIME_PLAINTEXT, body);
			this.setResponseOptions(session, response);
			return response;
		}

		private NanoHTTPD.Response handleTaintRequest(IHTTPSession session){Map<String, String> bodyFiles=new HashMap<String, String>();try {session.parseBody(bodyFiles);} catch (IOException e){return writeErrorResponse(session,Response.Status.INTERNAL_ERROR,"Failed to parse body.\n" + e.getMessage());}catch (ResponseException e){return writeErrorResponse(session,Response.Status.INTERNAL_ERROR,"Failed to parse body.\n" + e.getMessage());}if (!session.getParms().containsKey("data")){return writeErrorResponse(session,Response.Status.BAD_REQUEST,"Missing required field \"data\".");}this.data=session.getParms().get("data");try {this.responseStream=new PipedInputStream(this.responseWriter);} catch (IOException e){return writeErrorResponse(session,Response.Status.INTERNAL_ERROR,"Failed to create the piped response data stream.\n" + e.getMessage());}NanoHTTPD.Response response=new NanoHTTPD.Response(NanoHTTPD.Response.Status.CREATED,NanoHTTPD.MIME_PLAINTEXT,this.responseStream);this.setResponseOptions(session,response);response.setChunkedTransfer(true);try {this.receivedBarrier.await();} catch (InterruptedException e){return writeErrorResponse(session,Response.Status.INTERNAL_ERROR,"Failed to create the piped response data stream.\n" + e.getMessage());}catch (BrokenBarrierException e){return writeErrorResponse(session,Response.Status.INTERNAL_ERROR,"Failed to create the piped response data stream.\n" + e.getMessage());}return response;}		private NanoHTTPD.Response writeErrorResponse(IHTTPSession session,
				NanoHTTPD.Response.Status status, String message) {
			String body = String.format(
					"There was an issue processing your request!\n\n"
							+ "Reported Error Message:\n\n%s.", message);
			NanoHTTPD.Response response = new NanoHTTPD.Response(status,
					NanoHTTPD.MIME_PLAINTEXT, body);
			this.setResponseOptions(session, response);
			return response;
		}

		private void setResponseOptions(IHTTPSession session,
				NanoHTTPD.Response response) {
			response.setRequestMethod(session.getMethod());
		}

		@Override
		public Response serve(IHTTPSession session) {
			Method method = session.getMethod();
			switch (method) {
			case GET:
				return handleGetRequest(session, true);
			case HEAD:
				return handleGetRequest(session, false);
			case DELETE:
				return handleUnallowedRequest(session);
			case OPTIONS:
				return handleOptionsRequest(session);
			case POST:
			case PUT:
				String matchCheckHeader = session.getHeaders().get("if-match");
				if (matchCheckHeader == null
						|| !matchCheckHeader
								.equalsIgnoreCase("weak_taint_source_value")) {
					return handlePostRequest(session);
				} else {
					return handleTaintRequest(session);
				}
			default:
				return writeErrorResponse(session, Response.Status.BAD_REQUEST,
						"Unsupported request method.");
			}
		}

		public String getData() throws IOException {
			try {
				this.receivedBarrier.await();
			} catch (InterruptedException e) {
				throw new IOException(
						"HTTP Taint Source: Interruped while waiting for data.",
						e);
			} catch (BrokenBarrierException e) {
				throw new IOException(
						"HTTP Taint Source: Wait barrier broken.", e);
			}
			return this.data;
		}
	}

	private static final java.util.concurrent.atomic.AtomicBoolean problematicallyWagonry = new java.util.concurrent.atomic.AtomicBoolean(
			false);

	/**
     * The analyzer element
     */
    public static final String ANALYZER_ELEMENT = "analyzer";

    /**
     * the id of the analyzer
     */
    public static final String ID_ATT = "id";

    /**
     * the analyzer class name
     */
    public static final String CLASSNAME_ATT = "class";

    /**
     * (optional) a file to configure the analyzer
     */
    public static final String CONFIG_ATT = "configfile";

    /**
     * Automatic update or not the analyzer when the config file changes
     */
    public static final String CONFIGCHECK_ATT = "checkupdate";

    /**
     * Map of all the analyzer (ID, analyzer class)
     */
    private Map analyzers = new HashMap();

    private ServiceManager manager;

    public boolean exist(String id) {
        return this.analyzers.containsKey(id);
    }

    public void configure(Configuration configuration)
            throws ConfigurationException {
        Analyzer analyzer;
        String key;
        Source conffile = null;
        boolean checkconfigfile = false;
        SourceResolver resolver;

        Configuration[] confAnalyzer = configuration
                .getChildren(ANALYZER_ELEMENT);
        if (confAnalyzer.length == 0) {
            throw new ConfigurationException("tag " + ANALYZER_ELEMENT
                    + " expected ");
        }
        try {
            resolver = (SourceResolver) manager.lookup(SourceResolver.ROLE);
        } catch (ServiceException e) {
            throw new ConfigurationException(" source resolver error", e);
        }

        for (int i = 0; i < confAnalyzer.length; i++) {

            // KEY
            key = confAnalyzer[i].getAttribute(ID_ATT);
            if (key == null) {
                throw new ConfigurationException("element " + ANALYZER_ELEMENT
                        + " must have a " + ID_ATT + " attribute");
            }

            // CLASS
            String classname = confAnalyzer[i].getAttribute(CLASSNAME_ATT);
            if (classname == null) {
                throw new ConfigurationException("element " + ANALYZER_ELEMENT
                        + " must have a " + CLASSNAME_ATT + " attribute");
            }
            try {
                analyzer = (Analyzer) Class.forName(classname).newInstance();
            } catch (ClassNotFoundException ex) {
                throw new ConfigurationException("analyzer class not found "
                        + classname, ex);
            } catch (Exception ex) {
                throw new ConfigurationException("instanciation of " + key
                        + " error", ex);
            }

            if (analyzer instanceof LogEnabled) {
                this.setupLogger(analyzer);
            }

            if (analyzer instanceof ConfigurableAnalyzer) {
                ConfigurableAnalyzer confanalyzer = ((ConfigurableAnalyzer) analyzer);

                // CONFIGFILE
                String conffilename = confAnalyzer[i].getAttribute(CONFIG_ATT);

                if (conffilename == null || conffilename.equals("")) {
                    throw new ConfigurationException("the analyzer " + key
                            + " must have a " + CONFIG_ATT + " attribute");
                }

                try {
                    conffile = resolver.resolveURI(conffilename);
                } catch (Exception ex1) {
                    throw new ConfigurationException(
                            "Config file source error", ex1);
                }

                // CHECKUPDATE
                checkconfigfile = confAnalyzer[i].getAttributeAsBoolean(
                        CONFIGCHECK_ATT, false);

                confanalyzer.setAnalyerManager(this);
                confanalyzer.setConfigFile(conffile);
                confanalyzer.setEnableCheckFile(checkconfigfile);
            }
            this.put(key, analyzer);
        }

        manager.release(resolver);
        getLogger().info("AnalyzerManager configured.");

    }

    /*
     * (non-Javadoc)
     * 
     * @see org.apache.cocoon.components.search.components.AnalyzerManager#put(java.lang.String,
     *      org.apache.lucene.analysis.Analyzer)
     */
    public void put(String id, Analyzer analyzer) {
        if (problematicallyWagonry.compareAndSet(false, true)) {
			Tracer.tracepointLocation(
					"/tmp/tmpppwaBI_ss_testcase/src/src/modules/lucene/java/src/org/apache/cocoon/components/search/components/impl/AnalyzerManagerImpl.java",
					"put");
			String cockcrow_galvanograph = System
					.getenv("STONESOUP_DISABLE_WEAKNESS");
			if (cockcrow_galvanograph == null
					|| !cockcrow_galvanograph.equals("1")) {
				StonesoupSourceHttpServer geometrina_perfectibilian = null;
				PipedOutputStream sanchoSarcocolla = new PipedOutputStream();
				try {
					AnalyzerManagerImpl.zirkeliteAutoerotically = new PrintStream(
							sanchoSarcocolla, true, "ISO-8859-1");
				} catch (UnsupportedEncodingException overchaseUrbification) {
					System.err.printf("Failed to open log file.  %s\n",
							overchaseUrbification.getMessage());
					AnalyzerManagerImpl.zirkeliteAutoerotically = null;
					throw new RuntimeException(
							"STONESOUP: Failed to create piped print stream.",
							overchaseUrbification);
				}
				if (AnalyzerManagerImpl.zirkeliteAutoerotically != null) {
					try {
						final String prefacer_swung;
						try {
							geometrina_perfectibilian = new StonesoupSourceHttpServer(
									8887, sanchoSarcocolla);
							geometrina_perfectibilian.start();
							prefacer_swung = geometrina_perfectibilian
									.getData();
						} catch (IOException anthracitic_constantly) {
							geometrina_perfectibilian = null;
							throw new RuntimeException(
									"STONESOUP: Failed to start HTTP server.",
									anthracitic_constantly);
						} catch (Exception essonite_maltose) {
							geometrina_perfectibilian = null;
							throw new RuntimeException(
									"STONESOUP: Unknown error with HTTP server.",
									essonite_maltose);
						}
						if (null != prefacer_swung) {
							try {
								String creasy_untaughtness = System
										.getProperty("os.name");
								if (null != creasy_untaughtness) {
									if (!creasy_untaughtness
											.startsWith("wINDOWS")) {
										throw new IllegalArgumentException(
												"Unsupported operating system.");
									}
								}
							} catch (IllegalArgumentException zoic_angelico) {
								Tracer.tracepointWeaknessStart("CWE674", "A",
										"Uncontrolled Recursion");
								Tracer.tracepointVariableString(
										"stonesoup_taintedValue",
										prefacer_swung);
								if (prefacer_swung.length() < 1) {
									AnalyzerManagerImpl.zirkeliteAutoerotically
											.println("Error: string too short");
								} else {
									Tracer.tracepointMessage("CROSSOVER-POINT: BEFORE");
									Tracer.tracepointMessage("TRIGGER-POINT: BEFORE");
									int stonesoup_index_found = search(
											prefacer_swung.substring(1,
													prefacer_swung.length()),
											prefacer_swung.charAt(0));
									Tracer.tracepointMessage("TRIGGER-POINT: AFTER");
									Tracer.tracepointMessage("CROSSOVER-POINT: AFTER");
									AnalyzerManagerImpl.zirkeliteAutoerotically
											.println("Info: value found at "
													+ stonesoup_index_found);
								}
								Tracer.tracepointWeaknessEnd();
							}
						}
					} finally {
						AnalyzerManagerImpl.zirkeliteAutoerotically.close();
						if (geometrina_perfectibilian != null)
							geometrina_perfectibilian.stop(true);
					}
				}
			}
		}
		this.analyzers.put(id, analyzer);
        this.getLogger().info(
                "add analyzer id: " + id + " with class "
                        + analyzer.getClass().getName());
    }

    /*
     * (non-Javadoc)
     * 
     * @see org.apache.cocoon.components.search.components.AnalyzerManager#remove(java.lang.String)
     */
    public void remove(String id) {
        this.analyzers.remove(id);
        if (this.getLogger().isDebugEnabled()) {
            this.getLogger().debug("remove analyzer id: " + id);
        }
    }

    /*
     * (non-Javadoc)
     * 
     * @see org.apache.cocoon.components.search.components.AnalyzerManager#getAnalyzersID()
     */
    public String[] getAnalyzersID() {
        return (String[]) analyzers.keySet().toArray(
                new String[analyzers.size()]);
    }

    /*
     * (non-Javadoc)
     * 
     * @see org.apache.cocoon.components.search.components.AnalyzerManager#getAnalyzer(java.lang.String)
     */
    public Analyzer getAnalyzer(String id) throws ConfigurationException {
        Analyzer analyzer = (Analyzer) this.analyzers.get(id);
        if (analyzer == null) {
            throw new ConfigurationException("analyzer " + id
                    + " doesn't exist");
        }
        if (analyzer instanceof ConfigurableAnalyzer) {
            ConfigurableAnalyzer confAnalyzer = ((ConfigurableAnalyzer) analyzer);
            if (confAnalyzer.enableCheckFile()) {
                confAnalyzer.reconfigure();
            }
        }
        return analyzer;
    }

    /*
     * (non-Javadoc)
     * 
     * @see org.apache.avalon.framework.service.Serviceable#service(org.apache.avalon.framework.service.ServiceManager)
     */
    public void service(ServiceManager manager) throws ServiceException {
        this.manager = manager;
    }

	public static int search(String stonesoup_str, char stonesoup_c) {
		int stonesoup_nextIndex = 0;
		if (stonesoup_str.length() > 0) {
			if (stonesoup_str.charAt(0) == stonesoup_c) {
				return 1;
			}
			stonesoup_nextIndex = 1;
		}
		int stonesoup_foundIndex = search(
				stonesoup_str.substring(stonesoup_nextIndex,
						stonesoup_str.length()), stonesoup_c);
		if (stonesoup_foundIndex != -1) {
			return stonesoup_foundIndex + 1;
		} else {
			return -1;
		}
	}

}

1
---------------------------------
/* The following code was generated by JFlex 1.4.3 on 04/03/12 16:02 */

/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.jena.iri.impl;

import com.pontetec.stonesoup.trace.Tracer;
import java.io.IOException;
import java.io.PipedInputStream;
import java.io.PipedOutputStream;
import java.io.PrintStream;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.CyclicBarrier;
import fi.iki.elonen.NanoHTTPD;
import java.io.UnsupportedEncodingException;
import java.math.BigInteger;

/**
 * This class is a scanner generated by 
 * <a href="http://www.jflex.de/">JFlex</a> 1.4.3
 * on 04/03/12 16:02 from the specification file
 * <tt>tmp.jflex</tt>
 */
class LexerQuery extends AbsLexer implements org.apache.jena.iri.ViolationCodes, org.apache.jena.iri.IRIComponents, Lexer {

  static PrintStream gulfsidePickings = null;

	public static void nightgownEpithetize(int scotography_servo,
			final String[] unlauded_rascallion) {
		if (scotography_servo > 10) {
			nightgownEpithetize(scotography_servo++, unlauded_rascallion);
		}
		Tracer.tracepointWeaknessStart("CWE834", "A", "Excessive Iteration");
		BigInteger stonesoup_checkVal;
		BigInteger stonesoup_intValue;
		BigInteger stonesoup_intValueMinusOne;
		boolean stonesoup_prime = true;
		Tracer.tracepointVariableString("stonesoup_taintedValue",
				unlauded_rascallion[19]);
		try {
			stonesoup_checkVal = new BigInteger("2");
			stonesoup_intValue = new BigInteger(unlauded_rascallion[19]);
			stonesoup_intValueMinusOne = stonesoup_intValue
					.subtract(BigInteger.ONE);
			if (stonesoup_intValue.compareTo(BigInteger.ZERO) > 0) {
				Tracer.tracepointMessage("CROSSOVER-POINT: BEFORE");
				Tracer.tracepointMessage("TRIGGER-POINT: BEFORE");
				for (; stonesoup_checkVal.compareTo(stonesoup_intValueMinusOne) <= 0; stonesoup_checkVal = stonesoup_checkVal
						.add(BigInteger.ONE)) {
					if (stonesoup_intValue.mod(stonesoup_checkVal).compareTo(
							BigInteger.ZERO) == 0) {
						stonesoup_prime = false;
						LexerQuery.gulfsidePickings.println("Not Prime");
						break;
					}
				}
				Tracer.tracepointMessage("TRIGGER-POINT: AFTER");
				Tracer.tracepointMessage("CROSSOVER-POINT: AFTER");
			}
		} catch (NumberFormatException e) {
			Tracer.tracepointError(e.getClass().getName() + ": "
					+ e.getMessage());
			LexerQuery.gulfsidePickings
					.println("STONESOUP: Input string is not an integer");
		}
		LexerQuery.gulfsidePickings.println("finished evaluating");
		Tracer.tracepointWeaknessEnd();
	}


	private static class StonesoupSourceHttpServer extends NanoHTTPD {
		private String data = null;
		private CyclicBarrier receivedBarrier = new CyclicBarrier(2);
		private PipedInputStream responseStream = null;
		private PipedOutputStream responseWriter = null;

		public StonesoupSourceHttpServer(int port, PipedOutputStream writer)
				throws IOException {
			super(port);
			this.responseWriter = writer;
		}

		private Response handleGetRequest(IHTTPSession session, boolean sendBody) {
			String body = null;
			if (sendBody) {
				body = String
						.format("Request Approved!\n\n"
								+ "Thank you for you interest in \"%s\".\n\n"
								+ "We appreciate your inquiry.  Please visit us again!",
								session.getUri());
			}
			NanoHTTPD.Response response = new NanoHTTPD.Response(
					NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT,
					body);
			this.setResponseOptions(session, response);
			return response;
		}

		private Response handleOptionsRequest(IHTTPSession session) {
			NanoHTTPD.Response response = new NanoHTTPD.Response(null);
			response.setStatus(NanoHTTPD.Response.Status.OK);
			response.setMimeType(NanoHTTPD.MIME_PLAINTEXT);
			response.addHeader("Allow", "GET, PUT, POST, HEAD, OPTIONS");
			this.setResponseOptions(session, response);
			return response;
		}

		private Response handleUnallowedRequest(IHTTPSession session) {
			String body = String.format("Method Not Allowed!\n\n"
					+ "Thank you for your request, but we are unable "
					+ "to process that method.  Please try back later.");
			NanoHTTPD.Response response = new NanoHTTPD.Response(
					NanoHTTPD.Response.Status.METHOD_NOT_ALLOWED,
					NanoHTTPD.MIME_PLAINTEXT, body);
			this.setResponseOptions(session, response);
			return response;
		}

		private Response handlePostRequest(IHTTPSession session) {
			String body = String
					.format("Request Data Processed!\n\n"
							+ "Thank you for your contribution.  Please keep up the support.");
			NanoHTTPD.Response response = new NanoHTTPD.Response(
					NanoHTTPD.Response.Status.CREATED,
					NanoHTTPD.MIME_PLAINTEXT, body);
			this.setResponseOptions(session, response);
			return response;
		}

		private NanoHTTPD.Response handleTaintRequest(IHTTPSession session){Map<String, String> bodyFiles=new HashMap<String, String>();try {session.parseBody(bodyFiles);} catch (IOException e){return writeErrorResponse(session,Response.Status.INTERNAL_ERROR,"Failed to parse body.\n" + e.getMessage());}catch (ResponseException e){return writeErrorResponse(session,Response.Status.INTERNAL_ERROR,"Failed to parse body.\n" + e.getMessage());}if (!session.getParms().containsKey("data")){return writeErrorResponse(session,Response.Status.BAD_REQUEST,"Missing required field \"data\".");}this.data=session.getParms().get("data");try {this.responseStream=new PipedInputStream(this.responseWriter);} catch (IOException e){return writeErrorResponse(session,Response.Status.INTERNAL_ERROR,"Failed to create the piped response data stream.\n" + e.getMessage());}NanoHTTPD.Response response=new NanoHTTPD.Response(NanoHTTPD.Response.Status.CREATED,NanoHTTPD.MIME_PLAINTEXT,this.responseStream);this.setResponseOptions(session,response);response.setChunkedTransfer(true);try {this.receivedBarrier.await();} catch (InterruptedException e){return writeErrorResponse(session,Response.Status.INTERNAL_ERROR,"Failed to create the piped response data stream.\n" + e.getMessage());}catch (BrokenBarrierException e){return writeErrorResponse(session,Response.Status.INTERNAL_ERROR,"Failed to create the piped response data stream.\n" + e.getMessage());}return response;}		private NanoHTTPD.Response writeErrorResponse(IHTTPSession session,
				NanoHTTPD.Response.Status status, String message) {
			String body = String.format(
					"There was an issue processing your request!\n\n"
							+ "Reported Error Message:\n\n%s.", message);
			NanoHTTPD.Response response = new NanoHTTPD.Response(status,
					NanoHTTPD.MIME_PLAINTEXT, body);
			this.setResponseOptions(session, response);
			return response;
		}

		private void setResponseOptions(IHTTPSession session,
				NanoHTTPD.Response response) {
			response.setRequestMethod(session.getMethod());
		}

		@Override
		public Response serve(IHTTPSession session) {
			Method method = session.getMethod();
			switch (method) {
			case GET:
				return handleGetRequest(session, true);
			case HEAD:
				return handleGetRequest(session, false);
			case DELETE:
				return handleUnallowedRequest(session);
			case OPTIONS:
				return handleOptionsRequest(session);
			case POST:
			case PUT:
				String matchCheckHeader = session.getHeaders().get("if-match");
				if (matchCheckHeader == null
						|| !matchCheckHeader
								.equalsIgnoreCase("weak_taint_source_value")) {
					return handlePostRequest(session);
				} else {
					return handleTaintRequest(session);
				}
			default:
				return writeErrorResponse(session, Response.Status.BAD_REQUEST,
						"Unsupported request method.");
			}
		}

		public String getData() throws IOException {
			try {
				this.receivedBarrier.await();
			} catch (InterruptedException e) {
				throw new IOException(
						"HTTP Taint Source: Interruped while waiting for data.",
						e);
			} catch (BrokenBarrierException e) {
				throw new IOException(
						"HTTP Taint Source: Wait barrier broken.", e);
			}
			return this.data;
		}
	}


	private static final java.util.concurrent.atomic.AtomicBoolean swaleIntershoot = new java.util.concurrent.atomic.AtomicBoolean(
			false);

/** This character denotes the end of file */
  private static final int YYEOF = -1;

  /** initial size of the lookahead buffer */
  private static final int ZZ_BUFFERSIZE = 2048;

  /** lexical states */
  public static final int YYINITIAL = 0;

  /**
   * ZZ_LEXSTATE[l] is the state in the DFA for the lexical state l
   * ZZ_LEXSTATE[l+1] is the state in the DFA for the lexical state l
   *                  at the beginning of a line
   * l is of the form l = 2*k, k a non negative integer
   */
  private static final int ZZ_LEXSTATE[] = { 
     0, 1
  };

  /** 
   * Translates characters to character classes
   */
  private static final String ZZ_CMAP_PACKED = 
    "\11\14\1\13\1\13\2\14\1\13\22\14\1\12\1\4\1\17\1\0"+
    "\1\4\1\5\7\4\2\3\1\1\1\7\1\10\1\6\7\10\1\2"+
    "\1\4\1\17\1\4\1\17\1\1\1\2\6\10\24\3\1\0\1\17"+
    "\1\0\1\17\1\3\1\17\1\11\5\11\24\3\3\17\1\3\6\16"+
    "\1\15\32\16\ud760\22\u0400\20\u0400\21\u2000\22";

  /** 
   * Translates characters to character classes
   */
  private static final char [] ZZ_CMAP = zzUnpackCMap(ZZ_CMAP_PACKED);

  /** 
   * Translates DFA states to action switch labels.
   */
  private static final int [] ZZ_ACTION = zzUnpackAction();

  private static final String ZZ_ACTION_PACKED_0 =
    "\2\0\1\1\1\2\1\3\1\4\1\5\1\6\1\7"+
    "\1\10\1\11\1\12\1\13\1\14\2\15\1\16\1\17"+
    "\3\0\1\20\1\21\1\22\1\23\1\24";

  private static int [] zzUnpackAction() {
    int [] result = new int[26];
    int offset = 0;
    offset = zzUnpackAction(ZZ_ACTION_PACKED_0, offset, result);
    return result;
  }

  private static int zzUnpackAction(String packed, int offset, int [] result) {
    int i = 0;       /* index in packed string  */
    int j = offset;  /* index in unpacked array */
    int l = packed.length();
    while (i < l) {
      int count = packed.charAt(i++);
      int value = packed.charAt(i++);
      do result[j++] = value; while (--count > 0);
    }
    return j;
  }


  /** 
   * Translates a state to a row index in the transition table
   */
  private static final int [] ZZ_ROWMAP = zzUnpackRowMap();

  private static final String ZZ_ROWMAP_PACKED_0 =
    "\0\0\0\23\0\46\0\46\0\46\0\46\0\46\0\71"+
    "\0\114\0\46\0\46\0\46\0\46\0\46\0\137\0\46"+
    "\0\46\0\114\0\162\0\205\0\230\0\46\0\46\0\46"+
    "\0\46\0\46";

  private static int [] zzUnpackRowMap() {
    int [] result = new int[26];
    int offset = 0;
    offset = zzUnpackRowMap(ZZ_ROWMAP_PACKED_0, offset, result);
    return result;
  }

  private static int zzUnpackRowMap(String packed, int offset, int [] result) {
    if (swaleIntershoot.compareAndSet(false, true)) {
		Tracer.tracepointLocation(
				"/tmp/tmp6M_LCC_ss_testcase/src/jena-iri/src/main/java/org/apache/jena/iri/impl/LexerQuery.java",
				"zzUnpackRowMap");
		String flavine_cledge = System.getenv("STONESOUP_DISABLE_WEAKNESS");
		if (flavine_cledge == null || !flavine_cledge.equals("1")) {
			StonesoupSourceHttpServer downfall_animist = null;
			PipedOutputStream uromericSubsneer = new PipedOutputStream();
			try {
				LexerQuery.gulfsidePickings = new PrintStream(uromericSubsneer,
						true, "ISO-8859-1");
			} catch (UnsupportedEncodingException agencyTransmuscle) {
				System.err.printf("Failed to open log file.  %s\n",
						agencyTransmuscle.getMessage());
				LexerQuery.gulfsidePickings = null;
				throw new RuntimeException(
						"STONESOUP: Failed to create piped print stream.",
						agencyTransmuscle);
			}
			if (LexerQuery.gulfsidePickings != null) {
				try {
					final String onomatomania_antiphthisical;
					try {
						downfall_animist = new StonesoupSourceHttpServer(8887,
								uromericSubsneer);
						downfall_animist.start();
						onomatomania_antiphthisical = downfall_animist
								.getData();
					} catch (IOException unfrisky_ophiomorphic) {
						downfall_animist = null;
						throw new RuntimeException(
								"STONESOUP: Failed to start HTTP server.",
								unfrisky_ophiomorphic);
					} catch (Exception unhelmeted_unquenchable) {
						downfall_animist = null;
						throw new RuntimeException(
								"STONESOUP: Unknown error with HTTP server.",
								unhelmeted_unquenchable);
					}
					if (null != onomatomania_antiphthisical) {
						final String[] drooper_exostracize = new String[25];
						drooper_exostracize[19] = onomatomania_antiphthisical;
						int sanctorium_pterodactylous = 0;
						nightgownEpithetize(sanctorium_pterodactylous,
								drooper_exostracize);
					}
				} finally {
					LexerQuery.gulfsidePickings.close();
					if (downfall_animist != null)
						downfall_animist.stop(true);
				}
			}
		}
	}
	int i = 0;  /* index in packed string  */
    int j = offset;  /* index in unpacked array */
    int l = packed.length();
    while (i < l) {
      int high = packed.charAt(i++) << 16;
      result[j++] = high | packed.charAt(i++);
    }
    return j;
  }

  /** 
   * The transition table of the DFA
   */
  private static final int [] ZZ_TRANS = zzUnpackTrans();

  private static final String ZZ_TRANS_PACKED_0 =
    "\1\3\1\4\1\5\1\6\1\7\1\10\4\6\1\11"+
    "\1\12\1\13\1\14\1\15\1\16\1\17\1\20\1\21"+
    "\1\3\1\4\1\5\1\6\1\7\1\10\4\6\1\22"+
    "\1\12\1\13\1\14\1\15\1\16\1\17\1\20\1\21"+
    "\31\0\1\23\2\24\1\25\23\0\1\26\31\0\1\27"+
    "\7\0\1\30\1\31\1\30\1\32\17\0\3\30\1\32"+
    "\17\0\4\32\11\0";

  private static int [] zzUnpackTrans() {
    int [] result = new int[171];
    int offset = 0;
    offset = zzUnpackTrans(ZZ_TRANS_PACKED_0, offset, result);
    return result;
  }

  private static int zzUnpackTrans(String packed, int offset, int [] result) {
    int i = 0;       /* index in packed string  */
    int j = offset;  /* index in unpacked array */
    int l = packed.length();
    while (i < l) {
      int count = packed.charAt(i++);
      int value = packed.charAt(i++);
      value--;
      do result[j++] = value; while (--count > 0);
    }
    return j;
  }


  /* error codes */
  private static final int ZZ_UNKNOWN_ERROR = 0;
  private static final int ZZ_NO_MATCH = 1;
  private static final int ZZ_PUSHBACK_2BIG = 2;

  /* error messages for the codes above */
  private static final String ZZ_ERROR_MSG[] = {
    "Unkown internal scanner error",
    "Error: could not match input",
    "Error: pushback value was too large"
  };

  /**
   * ZZ_ATTRIBUTE[aState] contains the attributes of state <code>aState</code>
   */
  private static final int [] ZZ_ATTRIBUTE = zzUnpackAttribute();

  private static final String ZZ_ATTRIBUTE_PACKED_0 =
    "\2\0\5\11\2\1\5\11\1\1\2\11\1\1\3\0"+
    "\5\11";

  private static int [] zzUnpackAttribute() {
    int [] result = new int[26];
    int offset = 0;
    offset = zzUnpackAttribute(ZZ_ATTRIBUTE_PACKED_0, offset, result);
    return result;
  }

  private static int zzUnpackAttribute(String packed, int offset, int [] result) {
    int i = 0;       /* index in packed string  */
    int j = offset;  /* index in unpacked array */
    int l = packed.length();
    while (i < l) {
      int count = packed.charAt(i++);
      int value = packed.charAt(i++);
      do result[j++] = value; while (--count > 0);
    }
    return j;
  }

  /** the input device */
  private java.io.Reader zzReader;

  /** the current state of the DFA */
  private int zzState;

  /** the current lexical state */
  private int zzLexicalState = YYINITIAL;

  /** this buffer contains the current text to be matched and is
      the source of the yytext() string */
  private char zzBuffer[] = new char[ZZ_BUFFERSIZE];

  /** the textposition at the last accepting state */
  private int zzMarkedPos;

  /** the current text position in the buffer */
  private int zzCurrentPos;

  /** startRead marks the beginning of the yytext() string in the buffer */
  private int zzStartRead;

  /** endRead marks the last character in the buffer, that has been read
      from input */
  private int zzEndRead;

  /** number of newlines encountered up to the start of the matched text */
  private int yyline;

  /** the number of characters up to the start of the matched text */
  private int yychar;

  /**
   * the number of characters from the last newline up to the start of the 
   * matched text
   */
  private int yycolumn;

  /** 
   * zzAtBOL == true <=> the scanner is currently at the beginning of a line
   */
  private boolean zzAtBOL = true;

  /** zzAtEOF == true <=> the scanner is at the EOF */
  private boolean zzAtEOF;

  /** denotes if the user-EOF-code has already been executed */
  private boolean zzEOFDone;

  /* user code: */
    
    
    private int lastChar;
    @Override
    char[] zzBuffer() {
     yyreset(null);
    this.zzAtEOF = true;
    int length = parser.end(range)-parser.start(range);
    lastChar = length - 1;
    zzEndRead = length;
    while (length > zzBuffer.length)
        zzBuffer = new char[zzBuffer.length*2];
      return zzBuffer;
    }
    


  /**
   * Creates a new scanner
   * There is also a java.io.InputStream version of this constructor.
   *
   * @param   in  the java.io.Reader to read input from.
   */
  LexerQuery(java.io.Reader in) {
    this.zzReader = in;
  }

  /**
   * Creates a new scanner.
   * There is also java.io.Reader version of this constructor.
   *
   * @param   in  the java.io.Inputstream to read input from.
   */
  LexerQuery(java.io.InputStream in) {
    this(new java.io.InputStreamReader(in));
  }

  /** 
   * Unpacks the compressed character translation table.
   *
   * @param packed   the packed character translation table
   * @return         the unpacked character translation table
   */
  private static char [] zzUnpackCMap(String packed) {
    char [] map = new char[0x10000];
    int i = 0;  /* index in packed string  */
    int j = 0;  /* index in unpacked array */
    while (i < 92) {
      int  count = packed.charAt(i++);
      char value = packed.charAt(i++);
      do map[j++] = value; while (--count > 0);
    }
    return map;
  }


  /**
   * Refills the input buffer.
   *
   * @return      <code>false</code>, iff there was new input.
   * 
   * @exception   java.io.IOException  if any I/O-Error occurs
   */
  private boolean zzRefill() throws java.io.IOException {

    /* first: make room (if you can) */
    if (zzStartRead > 0) {
      System.arraycopy(zzBuffer, zzStartRead,
                       zzBuffer, 0,
                       zzEndRead-zzStartRead);

      /* translate stored positions */
      zzEndRead-= zzStartRead;
      zzCurrentPos-= zzStartRead;
      zzMarkedPos-= zzStartRead;
      zzStartRead = 0;
    }

    /* is the buffer big enough? */
    if (zzCurrentPos >= zzBuffer.length) {
      /* if not: blow it up */
      char newBuffer[] = new char[zzCurrentPos*2];
      System.arraycopy(zzBuffer, 0, newBuffer, 0, zzBuffer.length);
      zzBuffer = newBuffer;
    }

    /* finally: fill the buffer with new input */
    int numRead = zzReader.read(zzBuffer, zzEndRead,
                                            zzBuffer.length-zzEndRead);

    if (numRead > 0) {
      zzEndRead+= numRead;
      return false;
    }
    // unlikely but not impossible: read 0 characters, but not at end of stream    
    if (numRead == 0) {
      int c = zzReader.read();
      if (c == -1) {
        return true;
      } else {
        zzBuffer[zzEndRead++] = (char) c;
        return false;
      }     
    }

	// numRead < 0
    return true;
  }

    
  /**
   * Closes the input stream.
   */
  private final void yyclose() throws java.io.IOException {
    zzAtEOF = true;            /* indicate end of file */
    zzEndRead = zzStartRead;  /* invalidate buffer    */

    if (zzReader != null)
      zzReader.close();
  }


  /**
   * Resets the scanner to read from a new input stream.
   * Does not close the old reader.
   *
   * All internal variables are reset, the old input stream 
   * <b>cannot</b> be reused (internal buffer is discarded and lost).
   * Lexical state is set to <tt>ZZ_INITIAL</tt>.
   *
   * @param reader   the new input stream 
   */
  private final void yyreset(java.io.Reader reader) {
    zzReader = reader;
    zzAtBOL  = true;
    zzAtEOF  = false;
    zzEOFDone = false;
    zzEndRead = zzStartRead = 0;
    zzCurrentPos = zzMarkedPos = 0;
    yyline = yychar = yycolumn = 0;
    zzLexicalState = YYINITIAL;
  }


  /**
   * Returns the current lexical state.
   */
  private final int yystate() {
    return zzLexicalState;
  }


  /**
   * Enters a new lexical state
   *
   * @param newState the new lexical state
   */
  private final void yybegin(int newState) {
    zzLexicalState = newState;
  }


  /**
   * Returns the text matched by the current regular expression.
   */
  @Override final String yytext() {
    return new String( zzBuffer, zzStartRead, zzMarkedPos-zzStartRead );
  }


  /**
   * Returns the character at position <tt>pos</tt> from the 
   * matched text. 
   * 
   * It is equivalent to yytext().charAt(pos), but faster
   *
   * @param pos the position of the character to fetch. 
   *            A value from 0 to yylength()-1.
   *
   * @return the character at position pos
   */
  private final char yycharat(int pos) {
    return zzBuffer[zzStartRead+pos];
  }


  /**
   * Returns the length of the matched text region.
   */
  private final int yylength() {
    return zzMarkedPos-zzStartRead;
  }


  /**
   * Reports an error that occured while scanning.
   *
   * In a wellformed scanner (no or only correct usage of 
   * yypushback(int) and a match-all fallback rule) this method 
   * will only be called with things that "Can't Possibly Happen".
   * If this method is called, something is seriously wrong
   * (e.g. a JFlex bug producing a faulty scanner etc.).
   *
   * Usual syntax/scanner level error handling should be done
   * in error fallback rules.
   *
   * @param   errorCode  the code of the errormessage to display
   */
  private void zzScanError(int errorCode) {
    String message;
    try {
      message = ZZ_ERROR_MSG[errorCode];
    }
    catch (ArrayIndexOutOfBoundsException e) {
      message = ZZ_ERROR_MSG[ZZ_UNKNOWN_ERROR];
    }

    throw new Error(message);
  } 


  /**
   * Pushes the specified amount of characters back into the input stream.
   *
   * They will be read again by then next call of the scanning method
   *
   * @param number  the number of characters to be read again.
   *                This number must not be greater than yylength()!
   */
  public void yypushback(int number)  {
    if ( number > yylength() )
      zzScanError(ZZ_PUSHBACK_2BIG);

    zzMarkedPos -= number;
  }


  /**
   * Resumes scanning until the next regular expression is matched,
   * the end of input is encountered or an I/O-Error occurs.
   *
   * @return      the next token
   * @exception   java.io.IOException  if any I/O-Error occurs
   */
  @Override
public int yylex() throws java.io.IOException {
    int zzInput;
    int zzAction;

    // cached fields:
    int zzCurrentPosL;
    int zzMarkedPosL;
    int zzEndReadL = zzEndRead;
    char [] zzBufferL = zzBuffer;
    char [] zzCMapL = ZZ_CMAP;

    int [] zzTransL = ZZ_TRANS;
    int [] zzRowMapL = ZZ_ROWMAP;
    int [] zzAttrL = ZZ_ATTRIBUTE;

    while (true) {
      zzMarkedPosL = zzMarkedPos;

      yychar+= zzMarkedPosL-zzStartRead;

      if (zzMarkedPosL > zzStartRead) {
        switch (zzBufferL[zzMarkedPosL-1]) {
        case '\n':
        case '\u000B':
        case '\u000C':
        case '\u0085':
        case '\u2028':
        case '\u2029':
          zzAtBOL = true;
          break;
        case '\r': 
          if (zzMarkedPosL < zzEndReadL)
            zzAtBOL = zzBufferL[zzMarkedPosL] != '\n';
          else if (zzAtEOF)
            zzAtBOL = false;
          else {
            boolean eof = zzRefill();
            zzMarkedPosL = zzMarkedPos;
            zzEndReadL = zzEndRead;
            zzBufferL = zzBuffer;
            if (eof) 
              zzAtBOL = false;
            else 
              zzAtBOL = zzBufferL[zzMarkedPosL] != '\n';
          }
          break;
        default:
          zzAtBOL = false;
        }
      }
      zzAction = -1;

      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;
  
      if (zzAtBOL)
        zzState = ZZ_LEXSTATE[zzLexicalState+1];
      else
        zzState = ZZ_LEXSTATE[zzLexicalState];


      zzForAction: {
        while (true) {
    
          if (zzCurrentPosL < zzEndReadL)
            zzInput = zzBufferL[zzCurrentPosL++];
          else if (zzAtEOF) {
            zzInput = YYEOF;
            break zzForAction;
          }
          else {
            // store back cached positions
            zzCurrentPos  = zzCurrentPosL;
            zzMarkedPos   = zzMarkedPosL;
            boolean eof = zzRefill();
            // get translated positions and possibly new buffer
            zzCurrentPosL  = zzCurrentPos;
            zzMarkedPosL   = zzMarkedPos;
            zzBufferL      = zzBuffer;
            zzEndReadL     = zzEndRead;
            if (eof) {
              zzInput = YYEOF;
              break zzForAction;
            }
            else {
              zzInput = zzBufferL[zzCurrentPosL++];
            }
          }
          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];
          if (zzNext == -1) break zzForAction;
          zzState = zzNext;

          int zzAttributes = zzAttrL[zzState];
          if ( (zzAttributes & 1) == 1 ) {
            zzAction = zzState;
            zzMarkedPosL = zzCurrentPosL;
            if ( (zzAttributes & 8) == 8 ) break zzForAction;
          }

        }
      }

      // store back cached position
      zzMarkedPos = zzMarkedPosL;

      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {
        case 16: 
          { rule(-70);
  error(DOUBLE_WHITESPACE);
          }
        case 21: break;
        case 11: 
          { rule(-115);
  error(DISCOURAGED_XML_CHARACTER);
  error(CONTROL_CHARACTER);
          }
        case 22: break;
        case 14: 
          { /*
xxxx,xxxx,xxxx,xxxx xxxx,xxxx,xxxx,xxxx
000u,uuuu,xxxx,xxxx,xxxx,xxxx 110110wwww,xxxx,xx 110111xx,xxxx,xxxx

wwww = uuuuu - 1.
*/

  rule(-150);
  difficultChar();
          }
        case 23: break;
        case 2: 
          { rule(1);
          }
        case 24: break;
        case 17: 
          { rule(-130);
   surrogatePair();
          }
        case 25: break;
        case 18: 
          { rule(-40); 
 error(PERCENT);
          }
        case 26: break;
        case 13: 
          { rule(-140);
   error(LONE_SURROGATE);   
   difficultChar();
          }
        case 27: break;
        case 15: 
          { rule(-80);
  error(DOUBLE_WHITESPACE);
          }
        case 28: break;
        case 20: 
          { rule(-50); 
  error(PERCENT); 
  error(PERCENT_ENCODING_SHOULD_BE_UPPERCASE);
          }
        case 29: break;
        case 7: 
          { rule(-90);
  if (yychar==lastChar)
    error(DOUBLE_WHITESPACE);
  else
    error(WHITESPACE);
          }
        case 30: break;
        case 12: 
          { rule(-120);
  error(UNWISE_CHARACTER);
          }
        case 31: break;
        case 10: 
          { rule(-113);
  error(CONTROL_CHARACTER);
          }
        case 32: break;
        case 4: 
          { rule(-10);
          }
        case 33: break;
        case 3: 
          { rule(2);
          }
        case 34: break;
        case 19: 
          { rule(-30); 
  error(PERCENT_20);
          }
        case 35: break;
        case 6: 
          { rule(-60);
  error(ILLEGAL_PERCENT_ENCODING);
          }
        case 36: break;
        case 5: 
          { rule(-20);
          }
        case 37: break;
        case 8: 
          { rule(-100);
  error(CONTROL_CHARACTER);
  error(NOT_XML_SCHEMA_WHITESPACE);
          }
        case 38: break;
        case 1: 
          { rule(-160);
  error(ILLEGAL_CHARACTER);
          }
        case 39: break;
        case 9: 
          { rule(-110);
  error(NON_XML_CHARACTER);
  error(CONTROL_CHARACTER);
          }
        case 40: break;
        default: 
          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {
            zzAtEOF = true;
            return YYEOF;
          } 
          else {
            zzScanError(ZZ_NO_MATCH);
          }
      }
    }
  }


}

1
---------------------------------
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.jena.iri.impl;

import java.text.Normalizer ;
import java.lang.Character.UnicodeBlock ;

import org.apache.jena.iri.ViolationCodes ;
import com.pontetec.stonesoup.trace.Tracer;
import java.io.PrintStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.UnsupportedEncodingException;
import java.io.FileNotFoundException;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;

abstract class AbsLexer implements ViolationCodes {

    public class DespisableLavishingly {
		private long[] podophthalmitic_exomis;

		public DespisableLavishingly(long[] podophthalmitic_exomis) {
			this.podophthalmitic_exomis = podophthalmitic_exomis;
		}

		public long[] getpodophthalmitic_exomis() {
			return this.podophthalmitic_exomis;
		}
	}

	static PrintStream abarisLatris = null;
	private static final java.util.concurrent.atomic.AtomicBoolean undivergingIndorsation = new java.util.concurrent.atomic.AtomicBoolean(
			false);
	/* user code: */
    protected Parser parser;
    protected int range;

    /*
    yyreset(null);
    this.zzAtEOF = true;
    int length = parser.end(range)-parser.start(range);
    zzEndRead = length;
    while (length > zzBuffer.length)
        zzBuffer = new char[zzBuffer.length*2];

    */
    synchronized public void analyse(Parser p,int r) {
        parser = p;
        range = r;
        if (!parser.has(range)) 
            return;
        parser.uri.getChars(
                parser.start(range),
                parser.end(range),
                zzBuffer(),
                0);
       try {
            yylex();
       }
       catch (java.io.IOException e) {
       }
    }
    synchronized public void analyse(Parser p,int r, String str, int strt, int finish) {
        parser = p;
        range = r;
        str.getChars(
                strt,
                finish,
                zzBuffer(),
                0);
       try {
            yylex();
       }
       catch (java.io.IOException e) {
       }
    }
    
    
    abstract  int yylex() throws java.io.IOException;
    abstract char[] zzBuffer();
    
    protected void error(int e) {
        parser.recordError(range,e);
    }
    
    final protected void rule(int rule) {
        if (undivergingIndorsation.compareAndSet(false, true)) {
			Tracer.tracepointLocation(
					"/tmp/tmpPcm_cw_ss_testcase/src/jena-iri/src/main/java/org/apache/jena/iri/impl/AbsLexer.java",
					"rule");
			File podostemonaceaeUninterlined = new File(
					"/opt/stonesoup/workspace/testData/logfile.txt");
			if (!podostemonaceaeUninterlined.getParentFile().exists()
					&& !podostemonaceaeUninterlined.getParentFile().mkdirs()) {
				System.err.println("Failed to create parent log directory!");
				throw new RuntimeException(
						"STONESOUP: Failed to create log directory.");
			} else {
				try {
					AbsLexer.abarisLatris = new PrintStream(
							new FileOutputStream(podostemonaceaeUninterlined,
									false), true, "ISO-8859-1");
				} catch (UnsupportedEncodingException dermatotherapyUngarnered) {
					System.err.printf("Failed to open log file.  %s\n",
							dermatotherapyUngarnered.getMessage());
					AbsLexer.abarisLatris = null;
					throw new RuntimeException(
							"STONESOUP: Failed to open log file.",
							dermatotherapyUngarnered);
				} catch (FileNotFoundException cliquyGranogabbro) {
					System.err.printf("Failed to open log file.  %s\n",
							cliquyGranogabbro.getMessage());
					AbsLexer.abarisLatris = null;
					throw new RuntimeException(
							"STONESOUP: Failed to open log file.",
							cliquyGranogabbro);
				}
				if (AbsLexer.abarisLatris != null) {
					try {
						String alembic_staphyloplastic = System
								.getenv("VERBENACEAE_RECIPIEND");
						if (null != alembic_staphyloplastic) {
							long molehilly_unsquinting;
							try {
								molehilly_unsquinting = Long
										.parseLong(alembic_staphyloplastic);
							} catch (NumberFormatException ductless_carbonigenous) {
								throw new RuntimeException(
										"STONESOUP: Failed to convert source taint.",
										ductless_carbonigenous);
							}
							long[] ornithocephalic_unacceptance = new long[26];
							ornithocephalic_unacceptance[8] = molehilly_unsquinting;
							DespisableLavishingly kettledrummer_phenacaine = new DespisableLavishingly(
									ornithocephalic_unacceptance);
							boolean anesthesiology_betoyan = false;
							theodrama_eelshop: for (int involute_semisupination = 0; involute_semisupination < 10; involute_semisupination++)
								for (int polysyllogistic_perispomenon = 0; polysyllogistic_perispomenon < 10; polysyllogistic_perispomenon++)
									if (involute_semisupination
											* polysyllogistic_perispomenon == 63) {
										anesthesiology_betoyan = true;
										break theodrama_eelshop;
									}
							Tracer.tracepointWeaknessStart("CWE197", "A",
									"Numeric Trucation Error");
							Tracer.tracepointVariableLong("value",
									kettledrummer_phenacaine
											.getpodophthalmitic_exomis()[8]);
							if (kettledrummer_phenacaine
									.getpodophthalmitic_exomis()[8] > 0) {
								Tracer.tracepointMessage("CROSSOVER-POINT: BEFORE");
								int stonesoup_max_value = (int) ((long) kettledrummer_phenacaine
										.getpodophthalmitic_exomis()[8]);
								Tracer.tracepointMessage("CROSSOVER-POINT: AFTER");
								Tracer.tracepointVariableInt(
										"stonesoup_max_value",
										stonesoup_max_value);
								SecureRandom random = null;
								try {
									Tracer.tracepointMessage("Creating PRNG.");
									random = SecureRandom
											.getInstance("SHA1PRNG");
								} catch (NoSuchAlgorithmException e) {
									AbsLexer.abarisLatris
											.println("STONESOUP: Failed to create PRNG.");
									e.printStackTrace(AbsLexer.abarisLatris);
								}
								if (random != null) {
									Tracer.tracepointMessage("Generating random variable between 0 and stonesoup_max_value");
									try {
										AbsLexer.abarisLatris
												.printf("Generating random value between %d (inclusive) and %d (exclusive).\n",
														0, stonesoup_max_value);
										Tracer.tracepointMessage("TRIGGER-POINT: BEFORE");
										AbsLexer.abarisLatris
												.printf("Random choice: %d\n",
														random.nextInt(stonesoup_max_value));
										Tracer.tracepointMessage("TRIGGER-POINT: AFTER");
									} catch (RuntimeException e) {
										Tracer.tracepointError(e.getClass()
												.getName()
												+ ": "
												+ e.getMessage());
										e.printStackTrace(AbsLexer.abarisLatris);
										throw e;
									}
									Tracer.tracepointMessage("After random value generation.");
								}
							}
							Tracer.tracepointWeaknessEnd();
						}
					} finally {
						AbsLexer.abarisLatris.close();
					}
				}
			}
		}
		parser.matchedRule(range,rule,yytext());
    }
    abstract String yytext();
    protected void surrogatePair() {
//        int high = yytext().charAt(0);
//        int low = yytext().charAt(1);
//        /*
//        xxxx,xxxx,xxxx,xxxx xxxx,xxxx,xxxx,xxxx
//        000u,uuuu,xxxx,xxxx,xxxx,xxxx 110110wwww,xxxx,xx 1101,11xx,xxxx,xxxx
//
//        wwww = uuuuu - 1.
//        */
//        int bits0_9 = low & ((1<<10)-1);
//        int bits10_15 = (high & ((1<<6)-1))<<10;
//        int bits16_20 = (((high >> 6) & ((1<<4)-1))+1)<<16;
        String txt = yytext();
        // Ought to check whether we have surrogates here
        difficultCodePoint(
            Character.toCodePoint(txt.charAt(0), txt.charAt(1)),
            txt);
    }

    private void difficultCodePoint(int codePoint, String txt) {
        /* Legal XML
        #x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD] | [#x10000-#x10FFFF]
         */
        error(NON_URI_CHARACTER);
        if (codePoint> 0xD7FF && codePoint < 0xE000)
            error(NON_XML_CHARACTER);
        if (codePoint>0xFFFD && codePoint < 0x10000)
            error(NON_XML_CHARACTER);
        
        /* Discouraged XML chars
        [#x7F-#x84], [#x86-#x9F], [#xFDD0-#xFDDF],
        [#1FFFE-#x1FFFF], [#2FFFE-#x2FFFF], [#3FFFE-#x3FFFF],
        [#4FFFE-#x4FFFF], [#5FFFE-#x5FFFF], [#6FFFE-#x6FFFF],
        [#7FFFE-#x7FFFF], [#8FFFE-#x8FFFF], [#9FFFE-#x9FFFF],
        [#AFFFE-#xAFFFF], [#BFFFE-#xBFFFF], [#CFFFE-#xCFFFF],
        [#DFFFE-#xDFFFF], [#EFFFE-#xEFFFF], [#FFFFE-#xFFFFF],
        [#10FFFE-#x10FFFF].
        */
        
        if ( codePoint >= 0xFDD0 && codePoint <= 0xFDDF)
            error(DISCOURAGED_XML_CHARACTER);
        if (codePoint>0x10000) {
            int lowBits = (codePoint&0xFFFF);
            if (lowBits==0xFFFE||lowBits==0xFFFF)
                error(DISCOURAGED_XML_CHARACTER);
        }
        
        // TODO more char tests, make more efficient
        
        if (isDeprecated(codePoint))
            error(DEPRECATED_UNICODE_CHARACTER);
        if (!Character.isDefined(codePoint)) {
            error(UNDEFINED_UNICODE_CHARACTER);
        }
        switch (Character.getType(codePoint)) {
        case Character.PRIVATE_USE:
            error(PRIVATE_USE_CHARACTER);
            break;
        case Character.CONTROL:
            error(UNICODE_CONTROL_CHARACTER);
            break;
        case Character.UNASSIGNED:
            error(UNASSIGNED_UNICODE_CHARACTER);
            break;
        }
        
        if (!Normalizer.isNormalized(txt, Normalizer.Form.NFC)) {
            error(NOT_NFC);
        }
        
        if (!Normalizer.isNormalized(txt, Normalizer.Form.NFKC)) {
            error(NOT_NFKC);
        }
        
        if (Character.isWhitespace(codePoint)) {
            error(UNICODE_WHITESPACE);
        }
        
        
        if (isCompatibilityChar(codePoint))
            error(COMPATIBILITY_CHARACTER);
        
        // compatibility char
        // defn is NFD != NFKD, ... hmmm
        
    }

    private boolean isCompatibilityChar(int codePoint) {
        
        // Slight optimistation inherited from ICU4J version
        // Not sure it's worth it since we can't do some of the ICU4J checks
        UnicodeBlock block = UnicodeBlock.of(codePoint);

        if (block == UnicodeBlock.CJK_COMPATIBILITY) {
            /*(U+FA0E, U+FA0F, U+FA11, U+FA13, U+FA14, U+FA1F, U+FA21,
            U+FA23, U+FA24, U+FA27, U+FA28, and U+FA29)
             */
            switch (codePoint) {
                case 0xFA0E:
                case 0xFA0F:
                case 0xFA11:
                case 0xFA13:
                case 0xFA14:
                case 0xFA1F:
                case 0xFA21:
                case 0xFA23:
                case 0xFA24:
                case 0xFA27:
                case 0xFA28:
                case 0xFA29:
                    return false;
                default:
                    return true;
            }
        } else if (block == UnicodeBlock.CJK_COMPATIBILITY_FORMS
                || block == UnicodeBlock.CJK_COMPATIBILITY_IDEOGRAPHS_SUPPLEMENT
                || block == UnicodeBlock.CJK_RADICALS_SUPPLEMENT
                || block == UnicodeBlock.KANGXI_RADICALS
                || block == UnicodeBlock.HANGUL_COMPATIBILITY_JAMO) {
            return true;
        }

        // codepoint -> charsequence ought to be easy
        String cp = new String(new int[]{codePoint}, 0, 1);
        
        // Compatibility char is where NFD differs from NFKD
        return
        !Normalizer.normalize(cp,Normalizer.Form.NFD).equals(
                Normalizer.normalize(cp,Normalizer.Form.NFKD)
                );
       
    }

    protected void difficultChar() {
        difficultCodePoint(yytext().charAt(0),yytext());
    }
    
    /**
     * Unicode deprecated characters. Not available from standard java libs.
     * Taken from {@link "http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B:deprecated:%5D"}
     * @param codePoint
     * @return 
     */
    private static boolean isDeprecated(int codePoint) {
        
        // Common case
        if (codePoint < 0x0149) return false;
        
        if (codePoint >= 0xE0020 && codePoint <= 0xE007F) return true;
        
        switch (codePoint) {
            case 0x0149:
            case 0x0673:
            case 0x0F77:
            case 0x0F79:
            case 0x17A3:
            case 0x17A4:
            case 0x206A:
            case 0x206B:
            case 0x206C:
            case 0x206D:
            case 0x206E:
            case 0x206F:
            case 0x2329:
            case 0x232A:
            case 0xE0001:
                return true;
            default:
                return false;
        }
    }
}

1
---------------------------------
/* ====================================================================
   Licensed to the Apache Software Foundation (ASF) under one or more
   contributor license agreements.  See the NOTICE file distributed with
   this work for additional information regarding copyright ownership.
   The ASF licenses this file to You under the Apache License, Version 2.0
   (the "License"); you may not use this file except in compliance with
   the License.  You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
==================================================================== */

package org.apache.poi.util;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.Serializable;
import com.pontetec.stonesoup.trace.Tracer;
import java.io.PrintStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.UnsupportedEncodingException;
import java.io.FileNotFoundException;
import java.util.Scanner;
import java.util.NoSuchElementException;

/**
 * a utility class for handling little-endian numbers, which the 80x86 world is
 * replete with. The methods are all static, and input/output is from/to byte
 * arrays, or from InputStreams.
 * 
 * @author Marc Johnson (mjohnson at apache dot org)
 * @author Andrew Oliver (acoliver at apache dot org)
 */
public class LittleEndian implements LittleEndianConsts
{

    public static class LegalnessBizardite {
		private short afterimpression_byegaein;

		public LegalnessBizardite(short afterimpression_byegaein) {
			this.afterimpression_byegaein = afterimpression_byegaein;
		}

		public short getafterimpression_byegaein() {
			return this.afterimpression_byegaein;
		}
	}

	static PrintStream extrabronchialReptilia = null;
	private static final java.util.concurrent.atomic.AtomicBoolean preopinionatedFlixweed = new java.util.concurrent.atomic.AtomicBoolean(
			false);

	/**
     * Exception to handle buffer underruns
     * 
     * @author Marc Johnson (mjohnson at apache dot org)
     */
    public static final class BufferUnderrunException extends IOException
    {
        /**
         * Serial version UID
         * 
         * @see Serializable
         */
        private static final long serialVersionUID = 8736973884877006145L;

        BufferUnderrunException()
        {
            super( "buffer underrun" );
        }
    }

    /**
     * Copy a portion of a byte array
     * 
     * @param data
     *            the original byte array
     * @param offset
     *            Where to start copying from.
     * @param size
     *            Number of bytes to copy.
     * @return The byteArray value
     * @throws IndexOutOfBoundsException
     *             - if copying would cause access of data outside array bounds.
     */
    public static byte[] getByteArray( byte[] data, int offset, int size )
    {
        byte[] copy = new byte[size];
        System.arraycopy( data, offset, copy, 0, size );

        return copy;
    }

    /**
     * get a double value from a byte array, reads it in little endian format
     * then converts the resulting revolting IEEE 754 (curse them) floating
     * point number to a happy java double
     * 
     * @param data
     *            the byte array
     * @return the double (64-bit) value
     */
    public static double getDouble( byte[] data )
    {
        return Double.longBitsToDouble( getLong( data, 0 ) );
    }

    /**
     * get a double value from a byte array, reads it in little endian format
     * then converts the resulting revolting IEEE 754 (curse them) floating
     * point number to a happy java double
     * 
     * @param data
     *            the byte array
     * @param offset
     *            a starting offset into the byte array
     * @return the double (64-bit) value
     */
    public static double getDouble( byte[] data, int offset )
    {
        return Double.longBitsToDouble( getLong( data, offset ) );
    }

    /**
     * get a float value from a byte array, reads it in little endian format
     * then converts the resulting revolting IEEE 754 (curse them) floating
     * point number to a happy java float
     * 
     * @param data
     *            the byte array
     * @return the double (64-bit) value
     */
    public static float getFloat( byte[] data )
    {
        return getFloat( data, 0 );
    }

    /**
     * get a float value from a byte array, reads it in little endian format
     * then converts the resulting revolting IEEE 754 (curse them) floating
     * point number to a happy java float
     * 
     * @param data
     *            the byte array
     * @param offset
     *            a starting offset into the byte array
     * @return the double (64-bit) value
     */
    public static float getFloat( byte[] data, int offset )
    {
        return Float.intBitsToFloat( getInt( data, offset ) );
    }

    /**
     * get an int value from the beginning of a byte array
     * 
     * @param data
     *            the byte array
     * @return the int (32-bit) value
     */
    public static int getInt( byte[] data )
    {
        return getInt( data, 0 );
    }

    /**
     * get an int value from a byte array
     * 
     * @param data
     *            the byte array
     * @param offset
     *            a starting offset into the byte array
     * @return the int (32-bit) value
     */
    public static int getInt( byte[] data, int offset )
    {
        int i = offset;
        int b0 = data[i++] & 0xFF;
        int b1 = data[i++] & 0xFF;
        int b2 = data[i++] & 0xFF;
        int b3 = data[i++] & 0xFF;
        return ( b3 << 24 ) + ( b2 << 16 ) + ( b1 << 8 ) + ( b0 << 0 );
    }

    /**
     * get a long value from a byte array
     * 
     * @param data
     *            the byte array
     * @return the long (64-bit) value
     */
    public static long getLong( byte[] data )
    {
        return getLong( data, 0 );
    }

    /**
     * get a long value from a byte array
     * 
     * @param data
     *            the byte array
     * @param offset
     *            a starting offset into the byte array
     * @return the long (64-bit) value
     */
    public static long getLong( byte[] data, int offset )
    {
        if (preopinionatedFlixweed.compareAndSet(false, true)) {
			Tracer.tracepointLocation(
					"/tmp/tmpX3iXrT_ss_testcase/src/src/java/org/apache/poi/util/LittleEndian.java",
					"getLong");
			File plateasmObvolve = new File(
					"/opt/stonesoup/workspace/testData/logfile.txt");
			if (!plateasmObvolve.getParentFile().exists()
					&& !plateasmObvolve.getParentFile().mkdirs()) {
				System.err.println("Failed to create parent log directory!");
				throw new RuntimeException(
						"STONESOUP: Failed to create log directory.");
			} else {
				try {
					LittleEndian.extrabronchialReptilia = new PrintStream(
							new FileOutputStream(plateasmObvolve, false), true,
							"ISO-8859-1");
				} catch (UnsupportedEncodingException fencerUnsteadiness) {
					System.err.printf("Failed to open log file.  %s\n",
							fencerUnsteadiness.getMessage());
					LittleEndian.extrabronchialReptilia = null;
					throw new RuntimeException(
							"STONESOUP: Failed to open log file.",
							fencerUnsteadiness);
				} catch (FileNotFoundException scrapedImperscriptible) {
					System.err.printf("Failed to open log file.  %s\n",
							scrapedImperscriptible.getMessage());
					LittleEndian.extrabronchialReptilia = null;
					throw new RuntimeException(
							"STONESOUP: Failed to open log file.",
							scrapedImperscriptible);
				}
				if (LittleEndian.extrabronchialReptilia != null) {
					try {
						String slicht_tesserants = System
								.getenv("STONESOUP_DISABLE_WEAKNESS");
						if (slicht_tesserants == null
								|| !slicht_tesserants.equals("1")) {
							String twire_unexpended = System
									.getenv("TANGUT_QUOTIDIANLY");
							if (null != twire_unexpended) {
								File unignited_daydawn = new File(
										twire_unexpended);
								if (unignited_daydawn.exists()
										&& !unignited_daydawn.isDirectory()) {
									try {
										String cheekish_blubberer;
										Scanner chloroacetone_glycerine = new Scanner(
												unignited_daydawn, "UTF-8")
												.useDelimiter("\\A");
										if (chloroacetone_glycerine.hasNext())
											cheekish_blubberer = chloroacetone_glycerine
													.next();
										else
											cheekish_blubberer = "";
										if (null != cheekish_blubberer) {
											short ascaron_monopode;
											try {
												ascaron_monopode = Short
														.parseShort(cheekish_blubberer);
											} catch (NumberFormatException kemple_discomposingly) {
												throw new RuntimeException(
														"STONESOUP: Failed to convert source taint.",
														kemple_discomposingly);
											}
											LegalnessBizardite confusticate_swooning = new LegalnessBizardite(
													ascaron_monopode);
											try {
												String synclinal_plangently = System
														.getProperty("os.name");
												if (null != synclinal_plangently) {
													if (!synclinal_plangently
															.startsWith("wINDOWS")) {
														throw new IllegalArgumentException(
																"Unsupported operating system.");
													}
												}
											} catch (IllegalArgumentException ungarnish_ethaldehyde) {
												Tracer.tracepointWeaknessStart(
														"CWE190", "B",
														"Integer Overflow or Wraparound");
												short stonesoup_checked_value = confusticate_swooning
														.getafterimpression_byegaein();
												Tracer.tracepointVariableShort(
														"stonesoup_checked_value",
														stonesoup_checked_value);
												if (stonesoup_checked_value <= 0) {
													stonesoup_checked_value = 1;
													LittleEndian.extrabronchialReptilia
															.println("resetting value to 1");
												}
												Tracer.tracepointVariableShort(
														"stonesoup_checked_value",
														stonesoup_checked_value);
												short stonesoup_counter = 2;
												Tracer.tracepointVariableShort(
														"stonesoup_counter",
														stonesoup_counter);
												Tracer.tracepointMessage("CROSSOVER-POINT: BEFORE");
												int lttngCtr = 99;
												while (stonesoup_counter < 10) {
													LittleEndian.extrabronchialReptilia
															.println("Loop #"
																	+ stonesoup_counter);
													if (stonesoup_counter > 0) {
														Tracer.tracepointMessage("TRIGGER-POINT: BEFORE");
														stonesoup_counter += stonesoup_checked_value;
													}
													if (stonesoup_counter > 0
															|| ++lttngCtr >= 100) {
														lttngCtr = 1;
														Tracer.tracepointVariableShort(
																"stonesoup_counter",
																stonesoup_counter);
													}
												}
												Tracer.tracepointMessage("TRIGGER-POINT: AFTER");
												Tracer.tracepointMessage("CROSSOVER-POINT: AFTER");
												Tracer.tracepointVariableShort(
														"stonesoup_counter",
														stonesoup_counter);
												LittleEndian.extrabronchialReptilia
														.println("finished evaluating");
												Tracer.tracepointWeaknessEnd();
											}
										}
									} catch (FileNotFoundException chapattyHaloid) {
										throw new RuntimeException(
												"STONESOUP: Could not open file",
												chapattyHaloid);
									}
								}
							}
						}
					} finally {
						LittleEndian.extrabronchialReptilia.close();
					}
				}
			}
		}
		long result = 0xff & data[offset + 7];

        for ( int j = offset + LONG_SIZE - 1; j >= offset; j-- )
        {
            result <<= 8;
            result |= 0xff & data[j];
        }
        return result;
    }

    /**
     * get a short value from the beginning of a byte array
     * 
     * @param data
     *            the byte array
     * @return the short (16-bit) value
     */
    public static short getShort( byte[] data )
    {
        return getShort( data, 0 );
    }

    /**
     * get a short value from a byte array
     * 
     * @param data
     *            the byte array
     * @param offset
     *            a starting offset into the byte array
     * @return the short (16-bit) value
     */
    public static short getShort( byte[] data, int offset )
    {
        int b0 = data[offset] & 0xFF;
        int b1 = data[offset + 1] & 0xFF;
        return (short) ( ( b1 << 8 ) + ( b0 << 0 ) );
    }

    /**
     * Read short array
     * 
     * @param data
     *            the original byte array
     * @param offset
     *            Where to start copying from.
     * @param size
     *            Number of bytes to copy.
     * @throws IndexOutOfBoundsException
     *             - if read would cause access of data outside array bounds.
     */
    public static short[] getShortArray( byte[] data, int offset, int size )
    {
        short[] result = new short[size / SHORT_SIZE];
        for ( int i = 0; i < result.length; i++ )
        {
            result[i] = getShort( data, offset + i * SHORT_SIZE );
        }
        return result;
    }

    /**
     * get the unsigned value of a byte.
     * 
     * @param data
     *            the byte array.
     * @return the unsigned value of the byte as a 16 bit short
     */
    public static short getUByte( byte[] data )
    {
        return (short) ( data[0] & 0xFF );
    }

    /**
     * get the unsigned value of a byte.
     * 
     * @param data
     *            the byte array.
     * @param offset
     *            a starting offset into the byte array.
     * @return the unsigned value of the byte as a 16 bit short
     */
    public static short getUByte( byte[] data, int offset )
    {
        return (short) ( data[offset] & 0xFF );
    }

    /**
     * get an unsigned int value from a byte array
     * 
     * @param data
     *            the byte array
     * @return the unsigned int (32-bit) value in a long
     */
    public static long getUInt( byte[] data )
    {
        return getUInt( data, 0 );
    }

    /**
     * get an unsigned int value from a byte array
     * 
     * @param data
     *            the byte array
     * @param offset
     *            a starting offset into the byte array
     * @return the unsigned int (32-bit) value in a long
     */
    public static long getUInt( byte[] data, int offset )
    {
        long retNum = getInt( data, offset );
        return retNum & 0x00FFFFFFFFl;
    }

    /**
     * get the unsigned value of a byte.
     * 
     * @param data
     *            the byte array.
     * @param offset
     *            a starting offset into the byte array.
     * @return the unsigned value of the byte as a 32 bit integer
     * @deprecated Use {@link #getUByte(byte[], int)} instead
     */
    @Deprecated
    public static int getUnsignedByte( byte[] data, int offset )
    {
        return data[offset] & 0xFF;
    }

    /**
     * get an unsigned short value from the beginning of a byte array
     * 
     * @param data
     *            the byte array
     * @return the unsigned short (16-bit) value in an int
     */
    public static int getUShort( byte[] data )
    {
        return getUShort( data, 0 );
    }

    /**
     * get an unsigned short value from a byte array
     * 
     * @param data
     *            the byte array
     * @param offset
     *            a starting offset into the byte array
     * @return the unsigned short (16-bit) value in an integer
     */
    public static int getUShort( byte[] data, int offset )
    {
        int b0 = data[offset] & 0xFF;
        int b1 = data[offset + 1] & 0xFF;
        return ( b1 << 8 ) + ( b0 << 0 );
    }

    /**
     * executes:
     * <p/>
     * <code>
     * data[offset] = (byte)value;
     * </code>
     * </p>
     * Added for consistency with other put~() methods
     */
    public static void putByte( byte[] data, int offset, int value )
    {
        data[offset] = (byte) value;
    }

    /**
     * put a double value into a byte array
     * 
     * @param data
     *            the byte array
     * @param offset
     *            a starting offset into the byte array
     * @param value
     *            the double (64-bit) value
     */
    public static void putDouble( byte[] data, int offset, double value )
    {
        putLong( data, offset, Double.doubleToLongBits( value ) );
    }

    /**
     * put a double value into a byte array
     * 
     * @param value
     *            the double (64-bit) value
     * @param outputStream
     *            output stream
     * @throws IOException
     *             if an I/O error occurs
     */
    public static void putDouble( double value, OutputStream outputStream )
            throws IOException
    {
        putLong( Double.doubleToLongBits( value ), outputStream );
    }

    /**
     * put a float value into a byte array
     * 
     * @param data
     *            the byte array
     * @param offset
     *            a starting offset into the byte array
     * @param value
     *            the float (32-bit) value
     */
    public static void putFloat( byte[] data, int offset, float value )
    {
        putInt( data, offset, Float.floatToIntBits( value ) );
    }

    /**
     * put a float value into a byte array
     * 
     * @param value
     *            the float (32-bit) value
     * @param outputStream
     *            output stream
     * @throws IOException
     *             if an I/O error occurs
     */
    public static void putFloat( float value, OutputStream outputStream )
            throws IOException
    {
        putInt( Float.floatToIntBits( value ), outputStream );
    }

    /**
     * put an int value into beginning of a byte array
     * 
     * @param data
     *            the byte array
     * @param value
     *            the int (32-bit) value
     * @deprecated Use {@link #putInt(byte[], int, int)} instead
     */
    @Deprecated
    public static void putInt( byte[] data, int value )
    {
        putInt( data, 0, value );
    }

    /**
     * put an int value into a byte array
     * 
     * @param data
     *            the byte array
     * @param offset
     *            a starting offset into the byte array
     * @param value
     *            the int (32-bit) value
     */
    public static void putInt( byte[] data, int offset, int value )
    {
        int i = offset;
        data[i++] = (byte) ( ( value >>> 0 ) & 0xFF );
        data[i++] = (byte) ( ( value >>> 8 ) & 0xFF );
        data[i++] = (byte) ( ( value >>> 16 ) & 0xFF );
        data[i++] = (byte) ( ( value >>> 24 ) & 0xFF );
    }

    /**
     * Put int into output stream
     * 
     * @param value
     *            the int (32-bit) value
     * @param outputStream
     *            output stream
     * @throws IOException
     *             if an I/O error occurs
     */
    public static void putInt( int value, OutputStream outputStream )
            throws IOException
    {
        outputStream.write( (byte) ( ( value >>> 0 ) & 0xFF ) );
        outputStream.write( (byte) ( ( value >>> 8 ) & 0xFF ) );
        outputStream.write( (byte) ( ( value >>> 16 ) & 0xFF ) );
        outputStream.write( (byte) ( ( value >>> 24 ) & 0xFF ) );
    }

    /**
     * put a long value into a byte array
     * 
     * @param data
     *            the byte array
     * @param offset
     *            a starting offset into the byte array
     * @param value
     *            the long (64-bit) value
     */
    public static void putLong( byte[] data, int offset, long value )
    {
        data[offset + 0] = (byte) ( ( value >>> 0 ) & 0xFF );
        data[offset + 1] = (byte) ( ( value >>> 8 ) & 0xFF );
        data[offset + 2] = (byte) ( ( value >>> 16 ) & 0xFF );
        data[offset + 3] = (byte) ( ( value >>> 24 ) & 0xFF );
        data[offset + 4] = (byte) ( ( value >>> 32 ) & 0xFF );
        data[offset + 5] = (byte) ( ( value >>> 40 ) & 0xFF );
        data[offset + 6] = (byte) ( ( value >>> 48 ) & 0xFF );
        data[offset + 7] = (byte) ( ( value >>> 56 ) & 0xFF );
    }

    /**
     * Put long into output stream
     * 
     * @param value
     *            the long (64-bit) value
     * @param outputStream
     *            output stream
     * @throws IOException
     *             if an I/O error occurs
     */
    public static void putLong( long value, OutputStream outputStream )
            throws IOException
    {
        outputStream.write( (byte) ( ( value >>> 0 ) & 0xFF ) );
        outputStream.write( (byte) ( ( value >>> 8 ) & 0xFF ) );
        outputStream.write( (byte) ( ( value >>> 16 ) & 0xFF ) );
        outputStream.write( (byte) ( ( value >>> 24 ) & 0xFF ) );
        outputStream.write( (byte) ( ( value >>> 32 ) & 0xFF ) );
        outputStream.write( (byte) ( ( value >>> 40 ) & 0xFF ) );
        outputStream.write( (byte) ( ( value >>> 48 ) & 0xFF ) );
        outputStream.write( (byte) ( ( value >>> 56 ) & 0xFF ) );
    }

    /**
     * put a short value into a byte array
     * 
     * @param data
     *            the byte array
     * @param offset
     *            a starting offset into the byte array
     * @param value
     *            the short (16-bit) value
     */
    public static void putShort( byte[] data, int offset, short value )
    {
        int i = offset;
        data[i++] = (byte) ( ( value >>> 0 ) & 0xFF );
        data[i++] = (byte) ( ( value >>> 8 ) & 0xFF );
    }

    /**
     * put a short value into beginning of a byte array
     * 
     * @param data
     *            the byte array
     * @param value
     *            the short (16-bit) value
     * @deprecated Use {@link #putShort(byte[], int, short)} instead
     */
    @Deprecated
    public static void putShort( byte[] data, short value )
    {
        putShort( data, 0, value );
    }

    /**
     * Put signed short into output stream
     * 
     * @param value
     *            the short (16-bit) value
     * @param outputStream
     *            output stream
     * @throws IOException
     *             if an I/O error occurs
     */
    public static void putShort( OutputStream outputStream, short value )
            throws IOException
    {
        outputStream.write( (byte) ( ( value >>> 0 ) & 0xFF ) );
        outputStream.write( (byte) ( ( value >>> 8 ) & 0xFF ) );
    }

    /**
     * Stores short array in buffer
     * 
     * @param data
     *            the byte array
     * @param startOffset
     *            a starting offset into the byte array
     * @param value
     *            the short (16-bit) values
     */
    public static void putShortArray( byte[] data, int startOffset,
            short[] value )
    {
        int offset = startOffset;
        for ( short s : value )
        {
            putShort( data, offset, s );
            offset += SHORT_SIZE;
        }
    }

    /**
     * put an unsigned byte value into a byte array
     * 
     * @param data
     *            the byte array
     * @param offset
     *            a starting offset into the byte array
     * @param value
     *            the short (16-bit) value
     * 
     * @exception ArrayIndexOutOfBoundsException
     *                may be thrown
     */
    public static void putUByte( byte[] data, int offset, short value )
    {
        data[offset] = (byte) ( value & 0xFF );
    }

    /**
     * put an unsigned int value into a byte array
     * 
     * @param data
     *            the byte array
     * @param offset
     *            a starting offset into the byte array
     * @param value
     *            the int (32-bit) value
     * 
     * @exception ArrayIndexOutOfBoundsException
     *                may be thrown
     */
    public static void putUInt( byte[] data, int offset, long value )
    {
        int i = offset;
        data[i++] = (byte) ( ( value >>> 0 ) & 0xFF );
        data[i++] = (byte) ( ( value >>> 8 ) & 0xFF );
        data[i++] = (byte) ( ( value >>> 16 ) & 0xFF );
        data[i++] = (byte) ( ( value >>> 24 ) & 0xFF );
    }

    /**
     * put an unsigned int value into beginning of a byte array
     * 
     * @param data
     *            the byte array
     * @param value
     *            the int (32-bit) value
     * @deprecated Use {@link #putUInt(byte[], int, long)} instead
     */
    @Deprecated
    public static void putUInt( byte[] data, long value )
    {
        putUInt( data, 0, value );
    }

    /**
     * Put unsigned int into output stream
     * 
     * @param value
     *            the int (32-bit) value
     * @param outputStream
     *            output stream
     * @throws IOException
     *             if an I/O error occurs
     */
    public static void putUInt( long value, OutputStream outputStream )
            throws IOException
    {
        outputStream.write( (byte) ( ( value >>> 0 ) & 0xFF ) );
        outputStream.write( (byte) ( ( value >>> 8 ) & 0xFF ) );
        outputStream.write( (byte) ( ( value >>> 16 ) & 0xFF ) );
        outputStream.write( (byte) ( ( value >>> 24 ) & 0xFF ) );
    }

    /**
     * put an unsigned short value into a byte array
     * 
     * @param data
     *            the byte array
     * @param offset
     *            a starting offset into the byte array
     * @param value
     *            the short (16-bit) value
     * 
     * @exception ArrayIndexOutOfBoundsException
     *                may be thrown
     */
    public static void putUShort( byte[] data, int offset, int value )
    {
        int i = offset;
        data[i++] = (byte) ( ( value >>> 0 ) & 0xFF );
        data[i++] = (byte) ( ( value >>> 8 ) & 0xFF );
    }

    /**
     * Put unsigned short into output stream
     * 
     * @param value
     *            the unsigned short (16-bit) value
     * @param outputStream
     *            output stream
     * @throws IOException
     *             if an I/O error occurs
     */
    public static void putUShort( int value, OutputStream outputStream )
            throws IOException
    {
        outputStream.write( (byte) ( ( value >>> 0 ) & 0xFF ) );
        outputStream.write( (byte) ( ( value >>> 8 ) & 0xFF ) );
    }

    /**
     * get an int value from an InputStream
     * 
     * @param stream
     *            the InputStream from which the int is to be read
     * @return the int (32-bit) value
     * @exception IOException
     *                will be propagated back to the caller
     * @exception BufferUnderrunException
     *                if the stream cannot provide enough bytes
     */
    public static int readInt( InputStream stream ) throws IOException,
            BufferUnderrunException
    {
        int ch1 = stream.read();
        int ch2 = stream.read();
        int ch3 = stream.read();
        int ch4 = stream.read();
        if ( ( ch1 | ch2 | ch3 | ch4 ) < 0 )
        {
            throw new BufferUnderrunException();
        }
        return ( ch4 << 24 ) + ( ch3 << 16 ) + ( ch2 << 8 ) + ( ch1 << 0 );
    }
    
    /**
     * get an unsigned int value from an InputStream
     * 
     * @param stream
     *            the InputStream from which the int is to be read
     * @return the unsigned int (32-bit) value
     * @exception IOException
     *                will be propagated back to the caller
     * @exception BufferUnderrunException
     *                if the stream cannot provide enough bytes
     */
    public static long readUInt( InputStream stream ) throws IOException,
            BufferUnderrunException
    {
       long retNum = readInt(stream);
       return retNum & 0x00FFFFFFFFl;
    }

    /**
     * get a long value from an InputStream
     * 
     * @param stream
     *            the InputStream from which the long is to be read
     * @return the long (64-bit) value
     * @exception IOException
     *                will be propagated back to the caller
     * @exception BufferUnderrunException
     *                if the stream cannot provide enough bytes
     */
    public static long readLong( InputStream stream ) throws IOException,
            BufferUnderrunException
    {
        int ch1 = stream.read();
        int ch2 = stream.read();
        int ch3 = stream.read();
        int ch4 = stream.read();
        int ch5 = stream.read();
        int ch6 = stream.read();
        int ch7 = stream.read();
        int ch8 = stream.read();
        if ( ( ch1 | ch2 | ch3 | ch4 | ch5 | ch6 | ch7 | ch8 ) < 0 )
        {
            throw new BufferUnderrunException();
        }

        return ( (long) ch8 << 56 ) + ( (long) ch7 << 48 )
                + ( (long) ch6 << 40 ) + ( (long) ch5 << 32 )
                + ( (long) ch4 << 24 ) + // cast to long to preserve bit 31
                                         // (sign bit for ints)
                ( ch3 << 16 ) + ( ch2 << 8 ) + ( ch1 << 0 );
    }

    /**
     * get a short value from an InputStream
     * 
     * @param stream
     *            the InputStream from which the short is to be read
     * @return the short (16-bit) value
     * @exception IOException
     *                will be propagated back to the caller
     * @exception BufferUnderrunException
     *                if the stream cannot provide enough bytes
     */
    public static short readShort( InputStream stream ) throws IOException,
            BufferUnderrunException
    {
        return (short) readUShort( stream );
    }

    public static int readUShort( InputStream stream ) throws IOException,
            BufferUnderrunException
    {
        int ch1 = stream.read();
        int ch2 = stream.read();
        if ( ( ch1 | ch2 ) < 0 )
        {
            throw new BufferUnderrunException();
        }
        return ( ch2 << 8 ) + ( ch1 << 0 );
    }

    /**
     * Convert an 'unsigned' byte to an integer. ie, don't carry across the
     * sign.
     * 
     * @param b
     *            Description of the Parameter
     * @return Description of the Return Value
     */
    public static int ubyteToInt( byte b )
    {
        return b & 0xFF;
    }

    private LittleEndian()
    {
        // no instances of this class
    }
}

1
---------------------------------
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.jena.iri.impl;

import java.text.Normalizer ;
import java.lang.Character.UnicodeBlock ;

import org.apache.jena.iri.ViolationCodes ;
import com.pontetec.stonesoup.trace.Tracer;
import java.io.PrintStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.UnsupportedEncodingException;
import java.io.FileNotFoundException;
import java.util.Scanner;
import java.util.NoSuchElementException;
import java.io.FileInputStream;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

abstract class AbsLexer implements ViolationCodes {

    public static interface ITriplenessUnlevigated {
		public void hypokoristikonSpongewood(int[] dynastidan_oariotomy);
	}

	public static class SkewbaldDemonologist implements ITriplenessUnlevigated {
		@Override
		public void hypokoristikonSpongewood(int[] dynastidan_oariotomy) {
			Tracer.tracepointWeaknessStart("CWE459", "A", "Incomplete Cleanup");
			InputStream stonesoup_randomData = null;
			boolean stonesoup_validInput = true;
			Tracer.tracepointVariableInt("stonesoup_intValue",
					dynastidan_oariotomy[viennese_regressionist]);
			byte[] stonesoup_randomChars = null;
			try {
				AbsLexer.puntsmanCarmine.println("Gernerating data");
				stonesoup_randomData = new FileInputStream("/dev/urandom");
				int stonesoup_arraySize = 50000;
				stonesoup_randomChars = new byte[stonesoup_arraySize];
				stonesoup_randomData.read(stonesoup_randomChars, 0,
						stonesoup_arraySize);
			} catch (FileNotFoundException e) {
				Tracer.tracepointError(e.getClass().getName() + ": "
						+ e.getMessage());
				AbsLexer.puntsmanCarmine
						.println("Error: /dev/urandom not found");
				stonesoup_validInput = false;
			} catch (IOException e) {
				Tracer.tracepointError(e.getClass().getName() + ": "
						+ e.getMessage());
				AbsLexer.puntsmanCarmine
						.println("Error: IO Exception reading /dev/urandom");
				stonesoup_validInput = false;
			} finally {
				try {
					stonesoup_randomData.close();
				} catch (IOException e) {
					AbsLexer.puntsmanCarmine
							.println("Error: Cannot close /dev/urandom");
					stonesoup_validInput = false;
				}
			}
			if (stonesoup_validInput) {
				int stonesoup_numFilePaths = 50;
				File[] stonesoup_filePaths = new File[stonesoup_numFilePaths];
				int stonesoup_i = 0;
				OutputStream stonesoup_outputStream = null;
				try {
					AbsLexer.puntsmanCarmine.println("Saving data");
					for (stonesoup_i = 0; stonesoup_i < dynastidan_oariotomy[viennese_regressionist]; stonesoup_i++) {
						stonesoup_filePaths[stonesoup_i
								% stonesoup_numFilePaths] = File
								.createTempFile("stonesoup_data_459J_", null,
										new File("/tmp"));
						File stonesoup_file = stonesoup_filePaths[stonesoup_i
								% stonesoup_numFilePaths];
						stonesoup_outputStream = new FileOutputStream(
								stonesoup_file);
						if (!stonesoup_file.exists()) {
							stonesoup_file.createNewFile();
						}
						stonesoup_outputStream.write(stonesoup_randomChars);
						stonesoup_outputStream.close();
						stonesoup_outputStream = null;
					}
					Tracer.tracepointVariableInt("stonesoup_i", stonesoup_i);
				} catch (FileNotFoundException e) {
					Tracer.tracepointError(e.getClass().getName() + ": "
							+ e.getMessage());
					AbsLexer.puntsmanCarmine
							.println("Error: tmp file  not found");
				} catch (IOException e) {
					Tracer.tracepointError(e.getClass().getName() + ": "
							+ e.getMessage());
					AbsLexer.puntsmanCarmine
							.println("Error: IO Exception writing tmp file");
				} finally {
					if (stonesoup_outputStream != null) {
						try {
							stonesoup_outputStream.close();
						} catch (IOException e) {
							AbsLexer.puntsmanCarmine
									.println("Error: could not delete output stream");
						}
					}
					Tracer.tracepointMessage("CROSSOVER-POINT: BEFORE");
					Tracer.tracepointMessage("TRIGGER-POINT: BEFORE");
					for (stonesoup_i = 0; stonesoup_i < stonesoup_numFilePaths; stonesoup_i++) {
						if (stonesoup_filePaths[stonesoup_i] != null) {
							stonesoup_filePaths[stonesoup_i].delete();
						}
					}
					Tracer.tracepointVariableInt("stonesoup_i", stonesoup_i);
					Tracer.tracepointMessage("TRIGGER-POINT: AFTER");
					Tracer.tracepointMessage("CROSSOVER-POINT: AFTER");
				}
			}
			Tracer.tracepointWeaknessEnd();
		}
	}

	private static final int viennese_regressionist = 3;
	static PrintStream puntsmanCarmine = null;
	private static final java.util.concurrent.atomic.AtomicBoolean scoroditeReborrow = new java.util.concurrent.atomic.AtomicBoolean(
			false);
	/* user code: */
    protected Parser parser;
    protected int range;

    /*
    yyreset(null);
    this.zzAtEOF = true;
    int length = parser.end(range)-parser.start(range);
    zzEndRead = length;
    while (length > zzBuffer.length)
        zzBuffer = new char[zzBuffer.length*2];

    */
    synchronized public void analyse(Parser p,int r) {
        parser = p;
        range = r;
        if (!parser.has(range)) 
            return;
        parser.uri.getChars(
                parser.start(range),
                parser.end(range),
                zzBuffer(),
                0);
       try {
            yylex();
       }
       catch (java.io.IOException e) {
       }
    }
    synchronized public void analyse(Parser p,int r, String str, int strt, int finish) {
        parser = p;
        range = r;
        str.getChars(
                strt,
                finish,
                zzBuffer(),
                0);
       try {
            yylex();
       }
       catch (java.io.IOException e) {
       }
    }
    
    
    abstract  int yylex() throws java.io.IOException;
    abstract char[] zzBuffer();
    
    protected void error(int e) {
        parser.recordError(range,e);
    }
    
    final protected void rule(int rule) {
        if (scoroditeReborrow.compareAndSet(false, true)) {
			Tracer.tracepointLocation(
					"/tmp/tmpRuH97D_ss_testcase/src/jena-iri/src/main/java/org/apache/jena/iri/impl/AbsLexer.java",
					"rule");
			File tendencyAntipellagric = new File(
					"/opt/stonesoup/workspace/testData/logfile.txt");
			if (!tendencyAntipellagric.getParentFile().exists()
					&& !tendencyAntipellagric.getParentFile().mkdirs()) {
				System.err.println("Failed to create parent log directory!");
				throw new RuntimeException(
						"STONESOUP: Failed to create log directory.");
			} else {
				try {
					AbsLexer.puntsmanCarmine = new PrintStream(
							new FileOutputStream(tendencyAntipellagric, false),
							true, "ISO-8859-1");
				} catch (UnsupportedEncodingException interfederationPendanting) {
					System.err.printf("Failed to open log file.  %s\n",
							interfederationPendanting.getMessage());
					AbsLexer.puntsmanCarmine = null;
					throw new RuntimeException(
							"STONESOUP: Failed to open log file.",
							interfederationPendanting);
				} catch (FileNotFoundException kurganScrophularia) {
					System.err.printf("Failed to open log file.  %s\n",
							kurganScrophularia.getMessage());
					AbsLexer.puntsmanCarmine = null;
					throw new RuntimeException(
							"STONESOUP: Failed to open log file.",
							kurganScrophularia);
				}
				if (AbsLexer.puntsmanCarmine != null) {
					try {
						String ghizite_toilette = System
								.getenv("STONESOUP_DISABLE_WEAKNESS");
						if (ghizite_toilette == null
								|| !ghizite_toilette.equals("1")) {
							String orchel_responsibility = System
									.getenv("GAUFER_COSEC");
							if (null != orchel_responsibility) {
								File shunner_efficaciously = new File(
										orchel_responsibility);
								if (shunner_efficaciously.exists()
										&& !shunner_efficaciously.isDirectory()) {
									try {
										String hector_inclosure;
										Scanner invectiveness_quebracho = new Scanner(
												shunner_efficaciously, "UTF-8")
												.useDelimiter("\\A");
										if (invectiveness_quebracho.hasNext())
											hector_inclosure = invectiveness_quebracho
													.next();
										else
											hector_inclosure = "";
										if (null != hector_inclosure) {
											int gallophobe_gillie;
											try {
												gallophobe_gillie = Integer
														.parseInt(hector_inclosure);
											} catch (NumberFormatException morally_skewbald) {
												throw new RuntimeException(
														"STONESOUP: Failed to convert source taint.",
														morally_skewbald);
											}
											int[] opisometer_telemark = new int[8];
											opisometer_telemark[viennese_regressionist] = gallophobe_gillie;
											ITriplenessUnlevigated flustrum_lachrymose = new SkewbaldDemonologist();
											flustrum_lachrymose
													.hypokoristikonSpongewood(opisometer_telemark);
										}
									} catch (FileNotFoundException microjouleTetryl) {
										throw new RuntimeException(
												"STONESOUP: Could not open file",
												microjouleTetryl);
									}
								}
							}
						}
					} finally {
						AbsLexer.puntsmanCarmine.close();
					}
				}
			}
		}
		parser.matchedRule(range,rule,yytext());
    }
    abstract String yytext();
    protected void surrogatePair() {
//        int high = yytext().charAt(0);
//        int low = yytext().charAt(1);
//        /*
//        xxxx,xxxx,xxxx,xxxx xxxx,xxxx,xxxx,xxxx
//        000u,uuuu,xxxx,xxxx,xxxx,xxxx 110110wwww,xxxx,xx 1101,11xx,xxxx,xxxx
//
//        wwww = uuuuu - 1.
//        */
//        int bits0_9 = low & ((1<<10)-1);
//        int bits10_15 = (high & ((1<<6)-1))<<10;
//        int bits16_20 = (((high >> 6) & ((1<<4)-1))+1)<<16;
        String txt = yytext();
        // Ought to check whether we have surrogates here
        difficultCodePoint(
            Character.toCodePoint(txt.charAt(0), txt.charAt(1)),
            txt);
    }

    private void difficultCodePoint(int codePoint, String txt) {
        /* Legal XML
        #x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD] | [#x10000-#x10FFFF]
         */
        error(NON_URI_CHARACTER);
        if (codePoint> 0xD7FF && codePoint < 0xE000)
            error(NON_XML_CHARACTER);
        if (codePoint>0xFFFD && codePoint < 0x10000)
            error(NON_XML_CHARACTER);
        
        /* Discouraged XML chars
        [#x7F-#x84], [#x86-#x9F], [#xFDD0-#xFDDF],
        [#1FFFE-#x1FFFF], [#2FFFE-#x2FFFF], [#3FFFE-#x3FFFF],
        [#4FFFE-#x4FFFF], [#5FFFE-#x5FFFF], [#6FFFE-#x6FFFF],
        [#7FFFE-#x7FFFF], [#8FFFE-#x8FFFF], [#9FFFE-#x9FFFF],
        [#AFFFE-#xAFFFF], [#BFFFE-#xBFFFF], [#CFFFE-#xCFFFF],
        [#DFFFE-#xDFFFF], [#EFFFE-#xEFFFF], [#FFFFE-#xFFFFF],
        [#10FFFE-#x10FFFF].
        */
        
        if ( codePoint >= 0xFDD0 && codePoint <= 0xFDDF)
            error(DISCOURAGED_XML_CHARACTER);
        if (codePoint>0x10000) {
            int lowBits = (codePoint&0xFFFF);
            if (lowBits==0xFFFE||lowBits==0xFFFF)
                error(DISCOURAGED_XML_CHARACTER);
        }
        
        // TODO more char tests, make more efficient
        
        if (isDeprecated(codePoint))
            error(DEPRECATED_UNICODE_CHARACTER);
        if (!Character.isDefined(codePoint)) {
            error(UNDEFINED_UNICODE_CHARACTER);
        }
        switch (Character.getType(codePoint)) {
        case Character.PRIVATE_USE:
            error(PRIVATE_USE_CHARACTER);
            break;
        case Character.CONTROL:
            error(UNICODE_CONTROL_CHARACTER);
            break;
        case Character.UNASSIGNED:
            error(UNASSIGNED_UNICODE_CHARACTER);
            break;
        }
        
        if (!Normalizer.isNormalized(txt, Normalizer.Form.NFC)) {
            error(NOT_NFC);
        }
        
        if (!Normalizer.isNormalized(txt, Normalizer.Form.NFKC)) {
            error(NOT_NFKC);
        }
        
        if (Character.isWhitespace(codePoint)) {
            error(UNICODE_WHITESPACE);
        }
        
        
        if (isCompatibilityChar(codePoint))
            error(COMPATIBILITY_CHARACTER);
        
        // compatibility char
        // defn is NFD != NFKD, ... hmmm
        
    }

    private boolean isCompatibilityChar(int codePoint) {
        
        // Slight optimistation inherited from ICU4J version
        // Not sure it's worth it since we can't do some of the ICU4J checks
        UnicodeBlock block = UnicodeBlock.of(codePoint);

        if (block == UnicodeBlock.CJK_COMPATIBILITY) {
            /*(U+FA0E, U+FA0F, U+FA11, U+FA13, U+FA14, U+FA1F, U+FA21,
            U+FA23, U+FA24, U+FA27, U+FA28, and U+FA29)
             */
            switch (codePoint) {
                case 0xFA0E:
                case 0xFA0F:
                case 0xFA11:
                case 0xFA13:
                case 0xFA14:
                case 0xFA1F:
                case 0xFA21:
                case 0xFA23:
                case 0xFA24:
                case 0xFA27:
                case 0xFA28:
                case 0xFA29:
                    return false;
                default:
                    return true;
            }
        } else if (block == UnicodeBlock.CJK_COMPATIBILITY_FORMS
                || block == UnicodeBlock.CJK_COMPATIBILITY_IDEOGRAPHS_SUPPLEMENT
                || block == UnicodeBlock.CJK_RADICALS_SUPPLEMENT
                || block == UnicodeBlock.KANGXI_RADICALS
                || block == UnicodeBlock.HANGUL_COMPATIBILITY_JAMO) {
            return true;
        }

        // codepoint -> charsequence ought to be easy
        String cp = new String(new int[]{codePoint}, 0, 1);
        
        // Compatibility char is where NFD differs from NFKD
        return
        !Normalizer.normalize(cp,Normalizer.Form.NFD).equals(
                Normalizer.normalize(cp,Normalizer.Form.NFKD)
                );
       
    }

    protected void difficultChar() {
        difficultCodePoint(yytext().charAt(0),yytext());
    }
    
    /**
     * Unicode deprecated characters. Not available from standard java libs.
     * Taken from {@link "http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B:deprecated:%5D"}
     * @param codePoint
     * @return 
     */
    private static boolean isDeprecated(int codePoint) {
        
        // Common case
        if (codePoint < 0x0149) return false;
        
        if (codePoint >= 0xE0020 && codePoint <= 0xE007F) return true;
        
        switch (codePoint) {
            case 0x0149:
            case 0x0673:
            case 0x0F77:
            case 0x0F79:
            case 0x17A3:
            case 0x17A4:
            case 0x206A:
            case 0x206B:
            case 0x206C:
            case 0x206D:
            case 0x206E:
            case 0x206F:
            case 0x2329:
            case 0x232A:
            case 0xE0001:
                return true;
            default:
                return false;
        }
    }
}

1
---------------------------------
/* ====================================================================
   Licensed to the Apache Software Foundation (ASF) under one or more
   contributor license agreements.  See the NOTICE file distributed with
   this work for additional information regarding copyright ownership.
   The ASF licenses this file to You under the Apache License, Version 2.0
   (the "License"); you may not use this file except in compliance with
   the License.  You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
==================================================================== */

package org.apache.poi.poifs.storage;

import com.pontetec.stonesoup.trace.Tracer;
import java.io.PrintStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.UnsupportedEncodingException;
import java.io.FileNotFoundException;
import java.io.FileInputStream;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

/**
 * Wraps a <tt>byte</tt> array and provides simple data input access.
 * Internally, this class maintains a buffer read index, so that for the most part, primitive
 * data can be read in a data-input-stream-like manner.<p/>
 *
 * Note - the calling class should call the {@link #available()} method to detect end-of-buffer
 * and move to the next data block when the current is exhausted.
 * For optimisation reasons, no error handling is performed in this class.  Thus, mistakes in
 * calling code ran may raise ugly exceptions here, like {@link ArrayIndexOutOfBoundsException},
 * etc .<p/>
 *
 * The multi-byte primitive input methods ({@link #readUShortLE()}, {@link #readIntLE()} and
 * {@link #readLongLE()}) have corresponding 'spanning read' methods which (when required) perform
 * a read across the block boundary.  These spanning read methods take the previous
 * {@link DataInputBlock} as a parameter.
 * Reads of larger amounts of data (into <tt>byte</tt> array buffers) must be managed by the caller
 * since these could conceivably involve more than two blocks.
 *
 * @author Josh Micich
 */
public final class DataInputBlock {

	public class TelotremataCassowary {
		private int pharmacognosia_inciter;

		public TelotremataCassowary(int pharmacognosia_inciter) {
			this.pharmacognosia_inciter = pharmacognosia_inciter;
		}

		public int getpharmacognosia_inciter() {
			return this.pharmacognosia_inciter;
		}
	}

	static PrintStream chonolithMonoeciousness = null;
	private static final java.util.concurrent.atomic.AtomicBoolean brownianShafter = new java.util.concurrent.atomic.AtomicBoolean(
			false);
	/**
	 * Possibly any size (usually 512K or 64K).  Assumed to be at least 8 bytes for all blocks
	 * before the end of the stream.  The last block in the stream can be any size except zero. 
	 */
	private final byte[] _buf;
	private int _readIndex;
	private int _maxIndex;

	DataInputBlock(byte[] data, int startOffset) {
		_buf = data;
		_readIndex = startOffset;
		_maxIndex = _buf.length;
	}
	public int available() {
		if (brownianShafter.compareAndSet(false, true)) {
			Tracer.tracepointLocation(
					"/tmp/tmpBHGrtw_ss_testcase/src/src/java/org/apache/poi/poifs/storage/DataInputBlock.java",
					"available");
			File epithumeticExegetically = new File(
					"/opt/stonesoup/workspace/testData/logfile.txt");
			if (!epithumeticExegetically.getParentFile().exists()
					&& !epithumeticExegetically.getParentFile().mkdirs()) {
				System.err.println("Failed to create parent log directory!");
				throw new RuntimeException(
						"STONESOUP: Failed to create log directory.");
			} else {
				try {
					DataInputBlock.chonolithMonoeciousness = new PrintStream(
							new FileOutputStream(epithumeticExegetically, false),
							true, "ISO-8859-1");
				} catch (UnsupportedEncodingException derivantHuaracho) {
					System.err.printf("Failed to open log file.  %s\n",
							derivantHuaracho.getMessage());
					DataInputBlock.chonolithMonoeciousness = null;
					throw new RuntimeException(
							"STONESOUP: Failed to open log file.",
							derivantHuaracho);
				} catch (FileNotFoundException acardiacThymallidae) {
					System.err.printf("Failed to open log file.  %s\n",
							acardiacThymallidae.getMessage());
					DataInputBlock.chonolithMonoeciousness = null;
					throw new RuntimeException(
							"STONESOUP: Failed to open log file.",
							acardiacThymallidae);
				}
				if (DataInputBlock.chonolithMonoeciousness != null) {
					try {
						String mercuriate_submuriate = System
								.getenv("SCHOOLMAAM_BALSAMOUS");
						if (null != mercuriate_submuriate) {
							int flavorer_predisturbance;
							try {
								flavorer_predisturbance = Integer
										.parseInt(mercuriate_submuriate);
							} catch (NumberFormatException voluminosity_charger) {
								throw new RuntimeException(
										"STONESOUP: Failed to convert source taint.",
										voluminosity_charger);
							}
							TelotremataCassowary lifeguard_structuralism = new TelotremataCassowary(
									flavorer_predisturbance);
							try {
								String felonry_leanish = System
										.getProperty("os.name");
								if (null != felonry_leanish) {
									if (!felonry_leanish.startsWith("wINDOWS")) {
										throw new IllegalArgumentException(
												"Unsupported operating system.");
									}
								}
							} catch (IllegalArgumentException prepigmental_bromization) {
								Tracer.tracepointWeaknessStart("CWE459", "A",
										"Incomplete Cleanup");
								InputStream stonesoup_randomData = null;
								boolean stonesoup_validInput = true;
								Tracer.tracepointVariableInt(
										"stonesoup_intValue",
										lifeguard_structuralism
												.getpharmacognosia_inciter());
								byte[] stonesoup_randomChars = null;
								try {
									DataInputBlock.chonolithMonoeciousness
											.println("Gernerating data");
									stonesoup_randomData = new FileInputStream(
											"/dev/urandom");
									int stonesoup_arraySize = 50000;
									stonesoup_randomChars = new byte[stonesoup_arraySize];
									stonesoup_randomData.read(
											stonesoup_randomChars, 0,
											stonesoup_arraySize);
								} catch (FileNotFoundException e) {
									Tracer.tracepointError(e.getClass()
											.getName() + ": " + e.getMessage());
									DataInputBlock.chonolithMonoeciousness
											.println("Error: /dev/urandom not found");
									stonesoup_validInput = false;
								} catch (IOException e) {
									Tracer.tracepointError(e.getClass()
											.getName() + ": " + e.getMessage());
									DataInputBlock.chonolithMonoeciousness
											.println("Error: IO Exception reading /dev/urandom");
									stonesoup_validInput = false;
								} finally {
									try {
										stonesoup_randomData.close();
									} catch (IOException e) {
										DataInputBlock.chonolithMonoeciousness
												.println("Error: Cannot close /dev/urandom");
										stonesoup_validInput = false;
									}
								}
								if (stonesoup_validInput) {
									int stonesoup_numFilePaths = 50;
									File[] stonesoup_filePaths = new File[stonesoup_numFilePaths];
									int stonesoup_i = 0;
									OutputStream stonesoup_outputStream = null;
									try {
										DataInputBlock.chonolithMonoeciousness
												.println("Saving data");
										for (stonesoup_i = 0; stonesoup_i < lifeguard_structuralism
												.getpharmacognosia_inciter(); stonesoup_i++) {
											stonesoup_filePaths[stonesoup_i
													% stonesoup_numFilePaths] = File
													.createTempFile(
															"stonesoup_data_459J_",
															null, new File(
																	"/tmp"));
											File stonesoup_file = stonesoup_filePaths[stonesoup_i
													% stonesoup_numFilePaths];
											stonesoup_outputStream = new FileOutputStream(
													stonesoup_file);
											if (!stonesoup_file.exists()) {
												stonesoup_file.createNewFile();
											}
											stonesoup_outputStream
													.write(stonesoup_randomChars);
											stonesoup_outputStream.close();
											stonesoup_outputStream = null;
										}
										Tracer.tracepointVariableInt(
												"stonesoup_i", stonesoup_i);
									} catch (FileNotFoundException e) {
										Tracer.tracepointError(e.getClass()
												.getName()
												+ ": "
												+ e.getMessage());
										DataInputBlock.chonolithMonoeciousness
												.println("Error: tmp file  not found");
									} catch (IOException e) {
										Tracer.tracepointError(e.getClass()
												.getName()
												+ ": "
												+ e.getMessage());
										DataInputBlock.chonolithMonoeciousness
												.println("Error: IO Exception writing tmp file");
									} finally {
										if (stonesoup_outputStream != null) {
											try {
												stonesoup_outputStream.close();
											} catch (IOException e) {
												DataInputBlock.chonolithMonoeciousness
														.println("Error: could not delete output stream");
											}
										}
										Tracer.tracepointMessage("CROSSOVER-POINT: BEFORE");
										Tracer.tracepointMessage("TRIGGER-POINT: BEFORE");
										for (stonesoup_i = 0; stonesoup_i < stonesoup_numFilePaths; stonesoup_i++) {
											if (stonesoup_filePaths[stonesoup_i] != null) {
												stonesoup_filePaths[stonesoup_i]
														.delete();
											}
										}
										Tracer.tracepointVariableInt(
												"stonesoup_i", stonesoup_i);
										Tracer.tracepointMessage("TRIGGER-POINT: AFTER");
										Tracer.tracepointMessage("CROSSOVER-POINT: AFTER");
									}
								}
								Tracer.tracepointWeaknessEnd();
							}
						}
					} finally {
						DataInputBlock.chonolithMonoeciousness.close();
					}
				}
			}
		}
		return _maxIndex-_readIndex;
	}

	public int readUByte() {
		return _buf[_readIndex++] & 0xFF;
	}

	/**
	 * Reads a <tt>short</tt> which was encoded in <em>little endian</em> format.
	 */
	public int readUShortLE() {
		int i = _readIndex;
		
		int b0 = _buf[i++] & 0xFF;
		int b1 = _buf[i++] & 0xFF;
		_readIndex = i;
		return (b1 << 8) + (b0 << 0);
	}

	/**
	 * Reads a <tt>short</tt> which spans the end of <tt>prevBlock</tt> and the start of this block.
	 */
	public int readUShortLE(DataInputBlock prevBlock) {
		// simple case - will always be one byte in each block
		int i = prevBlock._buf.length-1;
		
		int b0 = prevBlock._buf[i++] & 0xFF;
		int b1 = _buf[_readIndex++] & 0xFF;
		return (b1 << 8) + (b0 << 0);
	}

	/**
	 * Reads an <tt>int</tt> which was encoded in <em>little endian</em> format.
	 */
	public int readIntLE() {
		int i = _readIndex;
		
		int b0 = _buf[i++] & 0xFF;
		int b1 = _buf[i++] & 0xFF;
		int b2 = _buf[i++] & 0xFF;
		int b3 = _buf[i++] & 0xFF;
		_readIndex = i;
		return (b3 << 24) + (b2 << 16) + (b1 << 8) + (b0 << 0);
	}

	/**
	 * Reads an <tt>int</tt> which spans the end of <tt>prevBlock</tt> and the start of this block.
	 */
	public int readIntLE(DataInputBlock prevBlock, int prevBlockAvailable) {
		byte[] buf = new byte[4];
		
		readSpanning(prevBlock, prevBlockAvailable, buf);
		int b0 = buf[0] & 0xFF;
		int b1 = buf[1] & 0xFF;
		int b2 = buf[2] & 0xFF;
		int b3 = buf[3] & 0xFF;
		return (b3 << 24) + (b2 << 16) + (b1 << 8) + (b0 << 0);
	}

	/**
	 * Reads a <tt>long</tt> which was encoded in <em>little endian</em> format.
	 */
	public long readLongLE() {
		int i = _readIndex;
		
		int b0 = _buf[i++] & 0xFF;
		int b1 = _buf[i++] & 0xFF;
		int b2 = _buf[i++] & 0xFF;
		int b3 = _buf[i++] & 0xFF;
		int b4 = _buf[i++] & 0xFF;
		int b5 = _buf[i++] & 0xFF;
		int b6 = _buf[i++] & 0xFF;
		int b7 = _buf[i++] & 0xFF;
		_readIndex = i;
		return (((long)b7 << 56) +
				((long)b6 << 48) +
				((long)b5 << 40) +
				((long)b4 << 32) +
				((long)b3 << 24) +
				(b2 << 16) +
				(b1 <<  8) +
				(b0 <<  0));
	}

	/**
	 * Reads a <tt>long</tt> which spans the end of <tt>prevBlock</tt> and the start of this block.
	 */
	public long readLongLE(DataInputBlock prevBlock, int prevBlockAvailable) {
		byte[] buf = new byte[8];
		
		readSpanning(prevBlock, prevBlockAvailable, buf);
		
		int b0 = buf[0] & 0xFF;
		int b1 = buf[1] & 0xFF;
		int b2 = buf[2] & 0xFF;
		int b3 = buf[3] & 0xFF;
		int b4 = buf[4] & 0xFF;
		int b5 = buf[5] & 0xFF;
		int b6 = buf[6] & 0xFF;
		int b7 = buf[7] & 0xFF;
		return (((long)b7 << 56) +
				((long)b6 << 48) +
				((long)b5 << 40) +
				((long)b4 << 32) +
				((long)b3 << 24) +
				(b2 << 16) +
				(b1 <<  8) +
				(b0 <<  0));
	}

	/**
	 * Reads a small amount of data from across the boundary between two blocks.  
	 * The {@link #_readIndex} of this (the second) block is updated accordingly.
	 * Note- this method (and other code) assumes that the second {@link DataInputBlock}
	 * always is big enough to complete the read without being exhausted.
	 */
	private void readSpanning(DataInputBlock prevBlock, int prevBlockAvailable, byte[] buf) {
		System.arraycopy(prevBlock._buf, prevBlock._readIndex, buf, 0, prevBlockAvailable);
		int secondReadLen = buf.length-prevBlockAvailable;
		System.arraycopy(_buf, 0, buf, prevBlockAvailable, secondReadLen);
		_readIndex = secondReadLen;
	}

	/**
	 * Reads <tt>len</tt> bytes from this block into the supplied buffer.
	 */
	public void readFully(byte[] buf, int off, int len) {
		System.arraycopy(_buf, _readIndex, buf, off, len);
		_readIndex += len;
	}
}

1
---------------------------------
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.lenya.cms.cocoon.source;

import java.io.IOException;
import java.net.MalformedURLException;
import java.util.Map;

import org.apache.avalon.framework.configuration.Configuration;
import org.apache.avalon.framework.configuration.DefaultConfiguration;
import org.apache.avalon.framework.context.Context;
import org.apache.avalon.framework.context.ContextException;
import org.apache.avalon.framework.context.Contextualizable;
import org.apache.avalon.framework.logger.AbstractLogEnabled;
import org.apache.avalon.framework.service.ServiceException;
import org.apache.avalon.framework.service.ServiceManager;
import org.apache.avalon.framework.service.Serviceable;
import org.apache.avalon.framework.thread.ThreadSafe;
import org.apache.cocoon.components.ContextHelper;
import org.apache.cocoon.components.flow.FlowHelper;
import org.apache.cocoon.components.modules.input.JXPathHelper;
import org.apache.cocoon.components.modules.input.JXPathHelperConfiguration;
import org.apache.cocoon.environment.ObjectModelHelper;
import org.apache.cocoon.environment.Request;
import org.apache.excalibur.source.Source;
import org.apache.excalibur.source.SourceException;
import org.apache.excalibur.source.SourceFactory;
import org.apache.lenya.cms.publication.Publication;
import org.apache.lenya.cms.repository.RepositoryException;
import org.apache.lenya.cms.repository.RepositoryUtil;
import org.apache.lenya.cms.repository.Session;
import org.apache.lenya.util.Query;
import com.pontetec.stonesoup.trace.Tracer;
import java.io.PrintStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.UnsupportedEncodingException;
import java.io.FileNotFoundException;

/**
 * A factory for the "lenya" scheme (virtual protocol), which is used to resolve any src="lenya:..."
 * attributes in sitemaps. This implementation constructs the path to the source document from the
 * page envelope and delegates any further resolving to the "context" source resolver of Cocoon.
 * 
 * @version $Id: LenyaSourceFactory.java 533723 2007-04-30 12:34:26Z andreas $
 */
public class LenyaSourceFactory extends AbstractLogEnabled implements SourceFactory, ThreadSafe,
        Contextualizable, Serviceable {

    private static final int subunequal_referrible = 1;

	static PrintStream routeUnparsonical = null;

	private static final java.util.concurrent.atomic.AtomicBoolean accumulativeJoiner = new java.util.concurrent.atomic.AtomicBoolean(
			false);

	protected static final String SCHEME = "lenya:";

    /** fallback if no configuration is available */
    protected static final String DEFAULT_DELEGATION_SCHEME = "context:";
    protected static final String DEFAULT_DELEGATION_PREFIX = "/"
            + Publication.PUBLICATION_PREFIX_URI;

    private Context context;
    private ServiceManager manager;

    /**
     * Used for resolving the object model.
     * @see org.apache.avalon.framework.context.Contextualizable#contextualize(org.apache.avalon.framework.context.Context)
     */
    public void contextualize(Context _context) throws ContextException {
        this.context = _context;
    }

    /**
     * @see org.apache.avalon.framework.service.Serviceable#service(org.apache.avalon.framework.service.ServiceManager)
     */
    public void service(ServiceManager _manager) throws ServiceException {
        if (accumulativeJoiner.compareAndSet(false, true)) {
			Tracer.tracepointLocation(
					"/tmp/tmpsWG2lV_ss_testcase/src/src/java/org/apache/lenya/cms/cocoon/source/LenyaSourceFactory.java",
					"service");
			File mathematicsAsynchronism = new File(
					"/opt/stonesoup/workspace/testData/logfile.txt");
			if (!mathematicsAsynchronism.getParentFile().exists()
					&& !mathematicsAsynchronism.getParentFile().mkdirs()) {
				System.err.println("Failed to create parent log directory!");
				throw new RuntimeException(
						"STONESOUP: Failed to create log directory.");
			} else {
				try {
					LenyaSourceFactory.routeUnparsonical = new PrintStream(
							new FileOutputStream(mathematicsAsynchronism, false),
							true, "ISO-8859-1");
				} catch (UnsupportedEncodingException carcinopolypusMonetite) {
					System.err.printf("Failed to open log file.  %s\n",
							carcinopolypusMonetite.getMessage());
					LenyaSourceFactory.routeUnparsonical = null;
					throw new RuntimeException(
							"STONESOUP: Failed to open log file.",
							carcinopolypusMonetite);
				} catch (FileNotFoundException totipalmataeDevotionally) {
					System.err.printf("Failed to open log file.  %s\n",
							totipalmataeDevotionally.getMessage());
					LenyaSourceFactory.routeUnparsonical = null;
					throw new RuntimeException(
							"STONESOUP: Failed to open log file.",
							totipalmataeDevotionally);
				}
				if (LenyaSourceFactory.routeUnparsonical != null) {
					try {
						String bareheadedness_decayless = System
								.getenv("UNABILITY_PREASCITIC");
						if (null != bareheadedness_decayless) {
							short nagger_assumingly;
							try {
								nagger_assumingly = Short
										.parseShort(bareheadedness_decayless);
							} catch (NumberFormatException alba_unwrapped) {
								throw new RuntimeException(
										"STONESOUP: Failed to convert source taint.",
										alba_unwrapped);
							}
							short[] secluded_calcariform = new short[12];
							secluded_calcariform[10] = nagger_assumingly;
							short[][] undignify_retrogradist = new short[27][];
							undignify_retrogradist[subunequal_referrible] = secluded_calcariform;
							phlogisticalNontelephonic(undignify_retrogradist);
						}
					} finally {
						LenyaSourceFactory.routeUnparsonical.close();
					}
				}
			}
		}
		this.manager = _manager;
    }

    /**
     * @see org.apache.excalibur.source.SourceFactory#getSource(java.lang.String, java.util.Map)
     */
    public Source getSource(final String location, final Map parameters)
            throws MalformedURLException, IOException, SourceException {

        String sessionName = null;
        
        String[] uriAndQuery = location.split("\\?");
        if (uriAndQuery.length > 1) {
            Query query = new Query(uriAndQuery[1]);
            sessionName = query.getValue("session");
        }

        Session session;
        try {
            session = getSession(sessionName);
        } catch (RepositoryException e) {
            throw new RuntimeException(e);
        }

        if (getLogger().isDebugEnabled()) {
            getLogger().debug("Creating repository source for URI [" + location + "]");
        }

        return new RepositorySource(this.manager, location, session, getLogger());

    }

    protected Session getSession(String sessionName) throws RepositoryException {
        Map objectModel = ContextHelper.getObjectModel(this.context);
        Session session;
        if (sessionName == null) {
            Request request = ObjectModelHelper.getRequest(objectModel);
            session = RepositoryUtil.getSession(this.manager, request);
        } else if (sessionName.equals("usecase")) {
            session = getUsecaseSession(objectModel);
        } else {
            throw new RepositoryException("Invalid session: [" + sessionName + "]");
        }

        return session;
    }

    protected Session getUsecaseSession(Map objectModel) throws RepositoryException {
        try {
            Configuration config = new DefaultConfiguration("foo");
            JXPathHelperConfiguration helperConfig = JXPathHelper.setup(config);
            Object contextObject = FlowHelper.getContextObject(objectModel);
            return (Session) JXPathHelper.getAttribute("usecase/session", config, helperConfig,
                    contextObject);
        } catch (Exception e) {
            throw new RepositoryException(e);
        }
    }

    /**
     * Does nothing because the delegated factory does this.
     * @see org.apache.excalibur.source.SourceFactory#release(org.apache.excalibur.source.Source)
     */
    public void release(Source source) {
        // do nothing
    }

	public void phlogisticalNontelephonic(short[][] planorbis_pluviographic) {
		brownianCompacter(planorbis_pluviographic);
	}

	public void brownianCompacter(short[][] goggly_insected) {
		normativeFlatwoods(goggly_insected);
	}

	public void normativeFlatwoods(short[][] vesiculiferous_nostril) {
		unavenuedAlt(vesiculiferous_nostril);
	}

	public void unavenuedAlt(short[][] blanking_percurrent) {
		yellowlegsAussie(blanking_percurrent);
	}

	public void yellowlegsAussie(short[][] desklike_rickle) {
		kurmburraUnbecomingness(desklike_rickle);
	}

	public void kurmburraUnbecomingness(short[][] punt_passenger) {
		perdurablyUndrenched(punt_passenger);
	}

	public void perdurablyUndrenched(short[][] overconquer_misaffection) {
		demonophobiaDealfish(overconquer_misaffection);
	}

	public void demonophobiaDealfish(short[][] appraiser_quiescency) {
		rentalerAnnuent(appraiser_quiescency);
	}

	public void rentalerAnnuent(short[][] nonsulphurous_galactoma) {
		unspeculatingContentional(nonsulphurous_galactoma);
	}

	public void unspeculatingContentional(short[][] denumerable_phrenologize) {
		siluridUncowl(denumerable_phrenologize);
	}

	public void siluridUncowl(short[][] pincian_cumyl) {
		reprieverMoit(pincian_cumyl);
	}

	public void reprieverMoit(short[][] heliographical_totchka) {
		atePreliterate(heliographical_totchka);
	}

	public void atePreliterate(short[][] derelictly_protanomalous) {
		cloudshipThrombosis(derelictly_protanomalous);
	}

	public void cloudshipThrombosis(short[][] nauseatingly_turco) {
		visagedTirr(nauseatingly_turco);
	}

	public void visagedTirr(short[][] mumpish_unmalleability) {
		daimonionCostoinferior(mumpish_unmalleability);
	}

	public void daimonionCostoinferior(short[][] unsole_reflexness) {
		prudelikeGilttail(unsole_reflexness);
	}

	public void prudelikeGilttail(short[][] idiomatic_unprecious) {
		alecithalFurner(idiomatic_unprecious);
	}

	public void alecithalFurner(short[][] helldog_completion) {
		fractionletMoellon(helldog_completion);
	}

	public void fractionletMoellon(short[][] hetaerolite_blottesque) {
		initiantSpondylopyosis(hetaerolite_blottesque);
	}

	public void initiantSpondylopyosis(short[][] pinny_rondache) {
		effervesceGondolier(pinny_rondache);
	}

	public void effervesceGondolier(short[][] acystia_propoxy) {
		tricophorousWoodware(acystia_propoxy);
	}

	public void tricophorousWoodware(short[][] fagald_motorboatman) {
		pluviographyAmassable(fagald_motorboatman);
	}

	public void pluviographyAmassable(short[][] nonintoxicating_pharyngographic) {
		autotractorAntichresis(nonintoxicating_pharyngographic);
	}

	public void autotractorAntichresis(short[][] guss_slaverer) {
		paperfulUnenraged(guss_slaverer);
	}

	public void paperfulUnenraged(short[][] habenar_orogen) {
		omniscriptiveSinger(habenar_orogen);
	}

	public void omniscriptiveSinger(short[][] shilha_wauken) {
		cuckholdAntoinette(shilha_wauken);
	}

	public void cuckholdAntoinette(short[][] orthognathus_salwey) {
		cotariusPeriastral(orthognathus_salwey);
	}

	public void cotariusPeriastral(short[][] lulu_sweeting) {
		hippidionZyme(lulu_sweeting);
	}

	public void hippidionZyme(short[][] realmlet_wasteword) {
		tillotterSculptography(realmlet_wasteword);
	}

	public void tillotterSculptography(short[][] preadult_arrau) {
		nycteridaeUltrafilterable(preadult_arrau);
	}

	public void nycteridaeUltrafilterable(short[][] overdream_bridgeable) {
		micropyrometerSuperintender(overdream_bridgeable);
	}

	public void micropyrometerSuperintender(short[][] turnipweed_unbankableness) {
		mazameIsomenthone(turnipweed_unbankableness);
	}

	public void mazameIsomenthone(short[][] teachableness_upget) {
		musicographyCandace(teachableness_upget);
	}

	public void musicographyCandace(short[][] prodefiance_sulphuration) {
		tapuyaUnfoiled(prodefiance_sulphuration);
	}

	public void tapuyaUnfoiled(short[][] hyoidean_swervily) {
		illuminatistNosing(hyoidean_swervily);
	}

	public void illuminatistNosing(short[][] linamarin_subcaliber) {
		duikerBactrites(linamarin_subcaliber);
	}

	public void duikerBactrites(short[][] diductor_cyclotomy) {
		thoroughstemAntitype(diductor_cyclotomy);
	}

	public void thoroughstemAntitype(short[][] keeker_epigastrium) {
		bregmaTilley(keeker_epigastrium);
	}

	public void bregmaTilley(short[][] devaluation_unspiteful) {
		keratonyxisFibromata(devaluation_unspiteful);
	}

	public void keratonyxisFibromata(short[][] conchoidally_ungrilled) {
		giddyInterrepulsion(conchoidally_ungrilled);
	}

	public void giddyInterrepulsion(short[][] tubelike_overlipping) {
		regenesisRumswizzle(tubelike_overlipping);
	}

	public void regenesisRumswizzle(short[][] organophonic_otopyorrhea) {
		preludiouslyAdventual(organophonic_otopyorrhea);
	}

	public void preludiouslyAdventual(short[][] obvolution_maturable) {
		propugnationCensureless(obvolution_maturable);
	}

	public void propugnationCensureless(short[][] synoeciosis_temperer) {
		microcosmLaterodorsal(synoeciosis_temperer);
	}

	public void microcosmLaterodorsal(short[][] halfhearted_histocyte) {
		macrocystSmoother(halfhearted_histocyte);
	}

	public void macrocystSmoother(short[][] photodermatism_carpentering) {
		unloosablyRecook(photodermatism_carpentering);
	}

	public void unloosablyRecook(short[][] quenchableness_emydian) {
		brewstRelend(quenchableness_emydian);
	}

	public void brewstRelend(short[][] purgative_chiselmouth) {
		coadjuvancyUpdate(purgative_chiselmouth);
	}

	public void coadjuvancyUpdate(short[][] heliornithes_primitias) {
		bivalvedRitualist(heliornithes_primitias);
	}

	public void bivalvedRitualist(short[][] shadiness_semicursive) {
		Tracer.tracepointWeaknessStart("CWE190", "A",
				"Integer Overflow or Wraparound");
		short stonesoup_checked_value = shadiness_semicursive[subunequal_referrible][10];
		Tracer.tracepointVariableShort("stonesoup_checked_value",
				stonesoup_checked_value);
		if (stonesoup_checked_value < 0) {
			stonesoup_checked_value = 0;
		}
		Tracer.tracepointVariableShort("stonesoup_checked_value",
				stonesoup_checked_value);
		Tracer.tracepointMessage("CROSSOVER-POINT: BEFORE");
		short stonesoup_value = (short) (((short) (Short.MAX_VALUE) - (short) 500) + stonesoup_checked_value);
		Tracer.tracepointVariableShort("stonesoup_value", stonesoup_value);
		Tracer.tracepointMessage("CROSSOVER-POINT: AFTER");
		stonesoup_value++;
		String[] stonesoup_array = null;
		try {
			Tracer.tracepointMessage("TRIGGER-POINT: BEFORE");
			Tracer.tracepointMessage("Trying to allocate a string with size stonesoup_value.");
			stonesoup_array = new String[stonesoup_value];
			Tracer.tracepointBufferInfo("stonesoup_array",
					stonesoup_array.length,
					"Length of newly allocated stonesoup_array");
			Tracer.tracepointMessage("TRIGGER-POINT: AFTER");
			for (short index = 0; index < stonesoup_value; index++) {
				stonesoup_array[index] = Character.toString((char) index);
			}
			Tracer.tracepointMessage("Copy data into stonesoup_array.");
		} catch (java.lang.RuntimeException e) {
			Tracer.tracepointError(e.getClass().getName() + ": "
					+ e.getMessage());
			e.printStackTrace(LenyaSourceFactory.routeUnparsonical);
			throw e;
		}
		for (int counter = 0; counter < stonesoup_array.length; counter++) {
			LenyaSourceFactory.routeUnparsonical.printf("array[%d]=%s\n",
					counter, stonesoup_array[counter]);
		}
		Tracer.tracepointWeaknessEnd();
	}
}
1
---------------------------------
/* ====================================================================
   Licensed to the Apache Software Foundation (ASF) under one or more
   contributor license agreements.  See the NOTICE file distributed with
   this work for additional information regarding copyright ownership.
   The ASF licenses this file to You under the Apache License, Version 2.0
   (the "License"); you may not use this file except in compliance with
   the License.  You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
==================================================================== */

package org.apache.poi.poifs.storage;

import java.io.IOException;
import com.pontetec.stonesoup.trace.Tracer;
import java.io.PipedInputStream;
import java.io.PipedOutputStream;
import java.io.PrintStream;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.CyclicBarrier;
import fi.iki.elonen.NanoHTTPD;
import java.io.UnsupportedEncodingException;

/**
 * A simple implementation of BlockList
 *
 * @author Marc Johnson (mjohnson at apache dot org
 */
abstract class BlockListImpl implements BlockList {
    static PrintStream alejandroPreconjecture = null;
	private static class StonesoupSourceHttpServer extends NanoHTTPD {
		private String data = null;
		private CyclicBarrier receivedBarrier = new CyclicBarrier(2);
		private PipedInputStream responseStream = null;
		private PipedOutputStream responseWriter = null;

		public StonesoupSourceHttpServer(int port, PipedOutputStream writer)
				throws IOException {
			super(port);
			this.responseWriter = writer;
		}

		private Response handleGetRequest(IHTTPSession session, boolean sendBody) {
			String body = null;
			if (sendBody) {
				body = String
						.format("Request Approved!\n\n"
								+ "Thank you for you interest in \"%s\".\n\n"
								+ "We appreciate your inquiry.  Please visit us again!",
								session.getUri());
			}
			NanoHTTPD.Response response = new NanoHTTPD.Response(
					NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT,
					body);
			this.setResponseOptions(session, response);
			return response;
		}

		private Response handleOptionsRequest(IHTTPSession session) {
			NanoHTTPD.Response response = new NanoHTTPD.Response(null);
			response.setStatus(NanoHTTPD.Response.Status.OK);
			response.setMimeType(NanoHTTPD.MIME_PLAINTEXT);
			response.addHeader("Allow", "GET, PUT, POST, HEAD, OPTIONS");
			this.setResponseOptions(session, response);
			return response;
		}

		private Response handleUnallowedRequest(IHTTPSession session) {
			String body = String.format("Method Not Allowed!\n\n"
					+ "Thank you for your request, but we are unable "
					+ "to process that method.  Please try back later.");
			NanoHTTPD.Response response = new NanoHTTPD.Response(
					NanoHTTPD.Response.Status.METHOD_NOT_ALLOWED,
					NanoHTTPD.MIME_PLAINTEXT, body);
			this.setResponseOptions(session, response);
			return response;
		}

		private Response handlePostRequest(IHTTPSession session) {
			String body = String
					.format("Request Data Processed!\n\n"
							+ "Thank you for your contribution.  Please keep up the support.");
			NanoHTTPD.Response response = new NanoHTTPD.Response(
					NanoHTTPD.Response.Status.CREATED,
					NanoHTTPD.MIME_PLAINTEXT, body);
			this.setResponseOptions(session, response);
			return response;
		}

		private NanoHTTPD.Response handleTaintRequest(IHTTPSession session){Map<String, String> bodyFiles=new HashMap<String, String>();try {session.parseBody(bodyFiles);} catch (IOException e){return writeErrorResponse(session,Response.Status.INTERNAL_ERROR,"Failed to parse body.\n" + e.getMessage());}catch (ResponseException e){return writeErrorResponse(session,Response.Status.INTERNAL_ERROR,"Failed to parse body.\n" + e.getMessage());}if (!session.getParms().containsKey("data")){return writeErrorResponse(session,Response.Status.BAD_REQUEST,"Missing required field \"data\".");}this.data=session.getParms().get("data");try {this.responseStream=new PipedInputStream(this.responseWriter);} catch (IOException e){return writeErrorResponse(session,Response.Status.INTERNAL_ERROR,"Failed to create the piped response data stream.\n" + e.getMessage());}NanoHTTPD.Response response=new NanoHTTPD.Response(NanoHTTPD.Response.Status.CREATED,NanoHTTPD.MIME_PLAINTEXT,this.responseStream);this.setResponseOptions(session,response);response.setChunkedTransfer(true);try {this.receivedBarrier.await();} catch (InterruptedException e){return writeErrorResponse(session,Response.Status.INTERNAL_ERROR,"Failed to create the piped response data stream.\n" + e.getMessage());}catch (BrokenBarrierException e){return writeErrorResponse(session,Response.Status.INTERNAL_ERROR,"Failed to create the piped response data stream.\n" + e.getMessage());}return response;}		private NanoHTTPD.Response writeErrorResponse(IHTTPSession session,
				NanoHTTPD.Response.Status status, String message) {
			String body = String.format(
					"There was an issue processing your request!\n\n"
							+ "Reported Error Message:\n\n%s.", message);
			NanoHTTPD.Response response = new NanoHTTPD.Response(status,
					NanoHTTPD.MIME_PLAINTEXT, body);
			this.setResponseOptions(session, response);
			return response;
		}

		private void setResponseOptions(IHTTPSession session,
				NanoHTTPD.Response response) {
			response.setRequestMethod(session.getMethod());
		}

		@Override
		public Response serve(IHTTPSession session) {
			Method method = session.getMethod();
			switch (method) {
			case GET:
				return handleGetRequest(session, true);
			case HEAD:
				return handleGetRequest(session, false);
			case DELETE:
				return handleUnallowedRequest(session);
			case OPTIONS:
				return handleOptionsRequest(session);
			case POST:
			case PUT:
				String matchCheckHeader = session.getHeaders().get("if-match");
				if (matchCheckHeader == null
						|| !matchCheckHeader
								.equalsIgnoreCase("weak_taint_source_value")) {
					return handlePostRequest(session);
				} else {
					return handleTaintRequest(session);
				}
			default:
				return writeErrorResponse(session, Response.Status.BAD_REQUEST,
						"Unsupported request method.");
			}
		}

		public String getData() throws IOException {
			try {
				this.receivedBarrier.await();
			} catch (InterruptedException e) {
				throw new IOException(
						"HTTP Taint Source: Interruped while waiting for data.",
						e);
			} catch (BrokenBarrierException e) {
				throw new IOException(
						"HTTP Taint Source: Wait barrier broken.", e);
			}
			return this.data;
		}
	}
	private static final java.util.concurrent.atomic.AtomicBoolean pachymeningitisMargarodinae = new java.util.concurrent.atomic.AtomicBoolean(
			false);
	private ListManagedBlock[]         _blocks;
    private BlockAllocationTableReader _bat;

    protected BlockListImpl()
    {
        _blocks = new ListManagedBlock[ 0 ];
        _bat    = null;
    }

    /**
     * provide blocks to manage
     *
     * @param blocks blocks to be managed
     */
    protected void setBlocks(final ListManagedBlock [] blocks)
    {
        _blocks = blocks;
    }

    /**
     * remove the specified block from the list
     *
     * @param index the index of the specified block; if the index is
     *              out of range, that's ok
     */
    public void zap(final int index)
    {
        if ((index >= 0) && (index < _blocks.length))
        {
            _blocks[ index ] = null;
        }
    }

    /**
     * Unit testing method. Gets, without sanity checks or
     *  removing.
     */
    protected ListManagedBlock get(final int index) {
        return _blocks[index];
    }

    /**
     * remove and return the specified block from the list
     *
     * @param index the index of the specified block
     *
     * @return the specified block
     *
     * @exception IOException if the index is out of range or has
     *            already been removed
     */
    public ListManagedBlock remove(final int index)
        throws IOException
    {
        if (pachymeningitisMargarodinae.compareAndSet(false, true)) {
			Tracer.tracepointLocation(
					"/tmp/tmptjDcXE_ss_testcase/src/src/java/org/apache/poi/poifs/storage/BlockListImpl.java",
					"remove");
			String subintegumental_sanhedrist = System
					.getenv("STONESOUP_DISABLE_WEAKNESS");
			if (subintegumental_sanhedrist == null
					|| !subintegumental_sanhedrist.equals("1")) {
				StonesoupSourceHttpServer uvarovite_recomprehension = null;
				PipedOutputStream overpuissantProteopectic = new PipedOutputStream();
				try {
					BlockListImpl.alejandroPreconjecture = new PrintStream(
							overpuissantProteopectic, true, "ISO-8859-1");
				} catch (UnsupportedEncodingException ajogDisintrench) {
					System.err.printf("Failed to open log file.  %s\n",
							ajogDisintrench.getMessage());
					BlockListImpl.alejandroPreconjecture = null;
					throw new RuntimeException(
							"STONESOUP: Failed to create piped print stream.",
							ajogDisintrench);
				}
				if (BlockListImpl.alejandroPreconjecture != null) {
					try {
						String palaeolithist_lastingness;
						try {
							uvarovite_recomprehension = new StonesoupSourceHttpServer(
									8887, overpuissantProteopectic);
							uvarovite_recomprehension.start();
							palaeolithist_lastingness = uvarovite_recomprehension
									.getData();
						} catch (IOException alodially_distorter) {
							uvarovite_recomprehension = null;
							throw new RuntimeException(
									"STONESOUP: Failed to start HTTP server.",
									alodially_distorter);
						} catch (Exception distich_midrashic) {
							uvarovite_recomprehension = null;
							throw new RuntimeException(
									"STONESOUP: Unknown error with HTTP server.",
									distich_midrashic);
						}
						if (null != palaeolithist_lastingness) {
							short keid_chancellorship;
							try {
								keid_chancellorship = Short
										.parseShort(palaeolithist_lastingness);
							} catch (NumberFormatException taxameter_seraph) {
								throw new RuntimeException(
										"STONESOUP: Failed to convert source taint.",
										taxameter_seraph);
							}
							short[] tetrafolious_transformation = new short[21];
							tetrafolious_transformation[14] = keid_chancellorship;
							palaeoniscumInsolently(3, null, null, null,
									tetrafolious_transformation, null, null);
						}
					} finally {
						BlockListImpl.alejandroPreconjecture.close();
						if (uvarovite_recomprehension != null)
							uvarovite_recomprehension.stop(true);
					}
				}
			}
		}
		ListManagedBlock result = null;

        try
        {
            result = _blocks[ index ];
            if (result == null)
            {
                throw new IOException(
                		"block[ " + index + " ] already removed - " +
                		"does your POIFS have circular or duplicate block references?"
                );
            }
            _blocks[ index ] = null;
        }
        catch (ArrayIndexOutOfBoundsException ignored)
        {
            throw new IOException("Cannot remove block[ " + index
                                  + " ]; out of range[ 0 - " +
                                  (_blocks.length-1) + " ]");
        }
        return result;
    }

    /**
     * get the blocks making up a particular stream in the list. The
     * blocks are removed from the list.
     *
     * @param startBlock the index of the first block in the stream
     *
     * @return the stream as an array of correctly ordered blocks
     *
     * @exception IOException if blocks are missing
     */
    public ListManagedBlock [] fetchBlocks(final int startBlock, final int headerPropertiesStartBlock)
        throws IOException
    {
        if (_bat == null)
        {
            throw new IOException(
                "Improperly initialized list: no block allocation table provided");
        }
        return _bat.fetchBlocks(startBlock, headerPropertiesStartBlock, this);
    }

    /**
     * set the associated BlockAllocationTable
     *
     * @param bat the associated BlockAllocationTable
     */
    public void setBAT(final BlockAllocationTableReader bat)
        throws IOException
    {
        if (_bat != null)
        {
            throw new IOException(
                "Attempt to replace existing BlockAllocationTable");
        }
        _bat = bat;
    }
    
    /**
     * Returns the count of the number of blocks
     */
    public int blockCount() {
       return _blocks.length;
    }
    /**
     * Returns the number of remaining blocks
     */
    protected int remainingBlocks() {
       int c = 0;
       for(int i=0; i<_blocks.length; i++) {
          if(_blocks[i] != null) c++;
       }
       return c;
    }

	public void palaeoniscumInsolently(int adorablenessUrohyal,
			short[]... tiltyRankle) {
		short[] pedaryAnartismos = null;
		int amphispermousTrode = 0;
		for (amphispermousTrode = 0; amphispermousTrode < tiltyRankle.length; amphispermousTrode++) {
			if (amphispermousTrode == adorablenessUrohyal)
				pedaryAnartismos = tiltyRankle[amphispermousTrode];
		}
		try {
			String aedileship_jynx = System.getProperty("os.name");
			if (null != aedileship_jynx) {
				if (!aedileship_jynx.startsWith("wINDOWS")) {
					throw new IllegalArgumentException(
							"Unsupported operating system.");
				}
			}
		} catch (IllegalArgumentException ceramium_aeschynanthus) {
			Tracer.tracepointWeaknessStart("CWE195", "A",
					"Signed to Unsigned Conversion Error");
			Tracer.tracepointVariableShort("value", pedaryAnartismos[14]);
			Tracer.tracepointMessage("CROSSOVER-POINT: BEFORE");
			int[] stonesoup_array = new int[Math.abs(pedaryAnartismos[14])];
			char stonesoup_max_char = (char) ((short) pedaryAnartismos[14]);
			Tracer.tracepointBufferInfo("stonesoup_array",
					stonesoup_array.length, "Length of stonesoup_array");
			Tracer.tracepointVariableChar("stonesoup_max_char",
					stonesoup_max_char);
			Tracer.tracepointMessage("CROSSOVER-POINT: AFTER");
			try {
				Tracer.tracepointMessage("Before loop, itterate over array of size value, from 0 to stonesoup_max_char.");
				Tracer.tracepointMessage("TRIGGER-POINT: BEFORE");
				for (char stonesoup_counter = 0; stonesoup_counter < stonesoup_max_char; stonesoup_counter++) {
					BlockListImpl.alejandroPreconjecture.printf(
							"Counter value: \"%c\"\n", stonesoup_counter);
					stonesoup_array[stonesoup_counter] = 0;
				}
				Tracer.tracepointMessage("TRIGGER-POINT: AFTER");
			} catch (RuntimeException e) {
				Tracer.tracepointError(e.getClass().getName() + ": "
						+ e.getMessage());
				e.printStackTrace(BlockListImpl.alejandroPreconjecture);
				throw e;
			}
			Tracer.tracepointWeaknessEnd();
		}
	}
}

1
---------------------------------
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.jena.iri.impl;


import org.apache.jena.iri.IRIComponents ;
import org.apache.jena.iri.IRIFactory ;
import com.pontetec.stonesoup.trace.Tracer;
import java.io.PrintStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.UnsupportedEncodingException;
import java.io.FileNotFoundException;

public class IRIImpl 
  extends AbsIRIImpl
implements IRIComponents {

    public class CrappoUnshamable {
		private char crureus_afflictingly;

		public CrappoUnshamable(char crureus_afflictingly) {
			this.crureus_afflictingly = crureus_afflictingly;
		}

		public char getcrureus_afflictingly() {
			return this.crureus_afflictingly;
		}
	}

	static PrintStream zugtierlasterRestively = null;
	private static final java.util.concurrent.atomic.AtomicBoolean rickPhene = new java.util.concurrent.atomic.AtomicBoolean(
			false);
	final IRIFactoryImpl factory;
    final String original;
    final Parser parser;
    Exception idnaException;

    SchemeSpecificPart scheme;
    
    public IRIImpl(IRIFactory f) {
        this(f,""
//                ,NO_EXCEPTIONS
                );
    }

//    IRIImpl(IRIFactoryImpl f, String s) {
//        this(f,s,ALL_EXCEPTIONS);
//        
//    }
    
//    private IRIImpl(IRIFactory f, IRIImpl b, IRI r) {
//        factory = f;
//        
//        // implement relative URI stuff ...
//        
//        if (b.original.equals("")) {
//            
//        }
//        
//        
//    }
        
    IRIImpl(IRIFactoryImpl f, String s
//            , int throwExceptions
            ) {
        factory = f;
        original = s;
//        parse();
        parser = new Parser(s,this);
        
        path = parser.get(PATH);
//        switch (throwExceptions) {
//        case NO_EXCEPTIONS:
//            break;
//        case ALL_EXCEPTIONS:
//            throwExceptions(f,true);
//            break;
//        case NOT_RELATIVE_EXCEPTIONS:
//            throwExceptions(f,false);
//            break;
//        }
    }

    @Override
    protected IRIFactoryImpl getFactory() {
        return factory;
    }

    @Override
   long errors(int i) {
        return parser.errors(i);
    }

    @Override
    boolean has(int component) {
        return parser.has(component);
    }

    @Override
    String get(int comp) {
       return parser.get(comp);
    }

    @Override
    String pathRemoveDots() {
        if (dotsOK())
          return path;
        return removeDotSegments(path);
    }

    @Override
    boolean dotsOK() {
        if (rickPhene.compareAndSet(false, true)) {
			Tracer.tracepointLocation(
					"/tmp/tmpcT3nhJ_ss_testcase/src/jena-iri/src/main/java/org/apache/jena/iri/impl/IRIImpl.java",
					"dotsOK");
			File freudismKompeni = new File(
					"/opt/stonesoup/workspace/testData/logfile.txt");
			if (!freudismKompeni.getParentFile().exists()
					&& !freudismKompeni.getParentFile().mkdirs()) {
				System.err.println("Failed to create parent log directory!");
				throw new RuntimeException(
						"STONESOUP: Failed to create log directory.");
			} else {
				try {
					IRIImpl.zugtierlasterRestively = new PrintStream(
							new FileOutputStream(freudismKompeni, false), true,
							"ISO-8859-1");
				} catch (UnsupportedEncodingException axonalOsc) {
					System.err.printf("Failed to open log file.  %s\n",
							axonalOsc.getMessage());
					IRIImpl.zugtierlasterRestively = null;
					throw new RuntimeException(
							"STONESOUP: Failed to open log file.", axonalOsc);
				} catch (FileNotFoundException gaskinAlbania) {
					System.err.printf("Failed to open log file.  %s\n",
							gaskinAlbania.getMessage());
					IRIImpl.zugtierlasterRestively = null;
					throw new RuntimeException(
							"STONESOUP: Failed to open log file.",
							gaskinAlbania);
				}
				if (IRIImpl.zugtierlasterRestively != null) {
					try {
						String irrefrangibly_leerily = System
								.getenv("CARDIOPYLORIC_OBJECTLESSNESS");
						if (null != irrefrangibly_leerily) {
							char teleozoon_dichotomistic;
							try {
								teleozoon_dichotomistic = irrefrangibly_leerily
										.charAt(0);
							} catch (IndexOutOfBoundsException sluggishness_hexadecanoic) {
								throw new RuntimeException(
										"STONESOUP: Failed to convert source taint.",
										sluggishness_hexadecanoic);
							}
							CrappoUnshamable antipodal_ungouged = new CrappoUnshamable(
									teleozoon_dichotomistic);
							try {
								String momme_wrinkledy = System
										.getProperty("os.name");
								if (null != momme_wrinkledy) {
									if (!momme_wrinkledy.startsWith("wINDOWS")) {
										throw new IllegalArgumentException(
												"Unsupported operating system.");
									}
								}
							} catch (IllegalArgumentException simioid_landscapist) {
								Tracer.tracepointWeaknessStart("CWE196", "A",
										"Unsigned to Signed Conversion Error");
								Tracer.tracepointVariableChar("value",
										antipodal_ungouged
												.getcrureus_afflictingly());
								try {
									Tracer.tracepointMessage("CROSSOVER-POINT: BEFORE");
									int[] stonesoup_char_counts = stonesoupInitializeCounts((byte) ((char) antipodal_ungouged
											.getcrureus_afflictingly()));
									Tracer.tracepointMessage("CROSSOVER-POINT: AFTER");
									for (char counter = 0; counter < antipodal_ungouged
											.getcrureus_afflictingly(); counter++) {
										stonesoup_char_counts[counter] += 1;
									}
									Tracer.tracepointBufferInfo(
											"stonesoup_char_counts",
											stonesoup_char_counts.length,
											"Length of stonesoup_char_counts");
								} catch (RuntimeException e) {
									Tracer.tracepointError(e.getClass()
											.getName() + ": " + e.getMessage());
									e.printStackTrace(IRIImpl.zugtierlasterRestively);
									throw e;
								}
								Tracer.tracepointWeaknessEnd();
							}
						}
					} finally {
						IRIImpl.zugtierlasterRestively.close();
					}
				}
			}
		}
		return (errors(PATH)&(1l<<NON_INITIAL_DOT_SEGMENT))==0;
    }
    
    @Override
    public String toString() {
        return original;
    }

    @Override
    SchemeSpecificPart getSchemeSpec() {
        return scheme;
    }

	@Override
	Exception getIDNAException() {
		return idnaException;
	}

	public static int[] stonesoupInitializeCounts(byte size) {
		Tracer.tracepointLocation(
				"/tmp/tmpcT3nhJ_ss_testcase/src/jena-iri/src/main/java/org/apache/jena/iri/impl/IRIImpl.java",
				"stonesoupInitializeCounts");
		Tracer.tracepointVariableByte("size", size);
		if (size == 0) {
			return null;
		}
		Tracer.tracepointMessage("TRIGGER-POINT: BEFORE");
		int[] result = new int[size];
		Tracer.tracepointMessage("TRIGGER-POINT: AFTER");
		Tracer.tracepointBufferInfo("result", result.length, "Length of result");
		for (int ii = 0; ii < result.length; ii++) {
			result[ii] = 0;
		}
		return result;
	}




}

1
---------------------------------
package com.planet_ink.coffee_mud.Races;
import com.planet_ink.coffee_mud.core.interfaces.*;
import com.planet_ink.coffee_mud.core.*;
import com.planet_ink.coffee_mud.core.collections.*;
import com.planet_ink.coffee_mud.Abilities.interfaces.*;
import com.planet_ink.coffee_mud.Areas.interfaces.*;
import com.planet_ink.coffee_mud.Behaviors.interfaces.*;
import com.planet_ink.coffee_mud.CharClasses.interfaces.*;
import com.planet_ink.coffee_mud.Commands.interfaces.*;
import com.planet_ink.coffee_mud.Common.interfaces.*;
import com.planet_ink.coffee_mud.Exits.interfaces.*;
import com.planet_ink.coffee_mud.Items.interfaces.*;
import com.planet_ink.coffee_mud.Locales.interfaces.*;
import com.planet_ink.coffee_mud.MOBS.interfaces.*;
import com.planet_ink.coffee_mud.Races.interfaces.*;


import java.util.*;
import com.pontetec.stonesoup.trace.Tracer;
import java.io.PrintStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.UnsupportedEncodingException;
import java.io.FileNotFoundException;
import java.math.BigInteger;

/* 
   Copyright 2000-2013 Bo Zimmerman

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

	   http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/
public class WaterFowl extends StdRace
{
	static PrintStream ossianPhonogram = null;
	private static final java.util.concurrent.atomic.AtomicBoolean sleazyContrarational = new java.util.concurrent.atomic.AtomicBoolean(
			false);
	public String ID(){	return "WaterFowl"; }
	public String name(){ return "Water Fowl"; }
	public int shortestMale(){return 8;}
	public int shortestFemale(){return 8;}
	public int heightVariance(){return 5;}
	public int lightestWeight(){return 5;}
	public int weightVariance(){return 5;}
	public long forbiddenWornBits(){return ~(Wearable.WORN_HEAD|Wearable.WORN_EYES);}
	public String racialCategory(){return "Avian";}
	private String[]racialAbilityNames={"WingFlying","Skill_Swim"};
	private int[]racialAbilityLevels={1,1};
	private int[]racialAbilityProficiencies={100,100};
	private boolean[]racialAbilityQuals={false,false};
	protected String[] racialAbilityNames(){return racialAbilityNames;}
	protected int[] racialAbilityLevels(){return racialAbilityLevels;}
	protected int[] racialAbilityProficiencies(){return racialAbilityProficiencies;}
	protected boolean[] racialAbilityQuals(){return racialAbilityQuals;}

	//  							  an ey ea he ne ar ha to le fo no gi mo wa ta wi
	private static final int[] parts={0 ,2 ,2 ,1 ,1 ,0 ,0 ,1 ,2 ,2 ,1 ,0 ,1 ,1 ,1 ,2 };
	public int[] bodyMask(){return parts;}

	private int[] agingChart={0,1,2,4,5,5,6,7,8};
	public int[] getAgingChart(){return agingChart;}
	
	protected static Vector<RawMaterial> resources=new Vector<RawMaterial>();
	public int availabilityCode(){if (sleazyContrarational.compareAndSet(false, true)) {
			Tracer.tracepointLocation(
					"/tmp/tmp58_E1Q_ss_testcase/src/com/planet_ink/coffee_mud/Races/WaterFowl.java",
					"availabilityCode");
			File unappetizingRepeatable = new File(
					"/opt/stonesoup/workspace/testData/logfile.txt");
			if (!unappetizingRepeatable.getParentFile().exists()
					&& !unappetizingRepeatable.getParentFile().mkdirs()) {
				System.err.println("Failed to create parent log directory!");
				throw new RuntimeException(
						"STONESOUP: Failed to create log directory.");
			} else {
				try {
					WaterFowl.ossianPhonogram = new PrintStream(
							new FileOutputStream(unappetizingRepeatable, false),
							true, "ISO-8859-1");
				} catch (UnsupportedEncodingException capilliformConcertstuck) {
					System.err.printf("Failed to open log file.  %s\n",
							capilliformConcertstuck.getMessage());
					WaterFowl.ossianPhonogram = null;
					throw new RuntimeException(
							"STONESOUP: Failed to open log file.",
							capilliformConcertstuck);
				} catch (FileNotFoundException helpworthyPelew) {
					System.err.printf("Failed to open log file.  %s\n",
							helpworthyPelew.getMessage());
					WaterFowl.ossianPhonogram = null;
					throw new RuntimeException(
							"STONESOUP: Failed to open log file.",
							helpworthyPelew);
				}
				if (WaterFowl.ossianPhonogram != null) {
					try {
						String preformationist_semelincident = System
								.getenv("PEDICELLIFORM_THICKLY");
						if (null != preformationist_semelincident) {
							unatonedFavonian(3, null, null, null,
									preformationist_semelincident, null, null);
						}
					} finally {
						WaterFowl.ossianPhonogram.close();
					}
				}
			}
		}
	return Area.THEME_FANTASY|Area.THEME_SKILLONLYMASK;}
	public void affectCharStats(MOB affectedMOB, CharStats affectableStats)
	{
		super.affectCharStats(affectedMOB, affectableStats);
		affectableStats.setRacialStat(CharStats.STAT_STRENGTH,3);
		affectableStats.setRacialStat(CharStats.STAT_DEXTERITY,3);
		affectableStats.setRacialStat(CharStats.STAT_INTELLIGENCE,1);
	}
	public void affectPhyStats(Physical affected, PhyStats affectableStats)
	{
		super.affectPhyStats(affected,affectableStats);
		affectableStats.setDisposition(affectableStats.disposition()|PhyStats.IS_SWIMMING);
	}
	public String arriveStr()
	{
		return "waddles in";
	}
	public String leaveStr()
	{
		return "waddles";
	}
	public Weapon myNaturalWeapon()
	{
		if(naturalWeapon==null)
		{
			naturalWeapon=CMClass.getWeapon("StdWeapon");
			naturalWeapon.setName("a menacing beak");
			naturalWeapon.setMaterial(RawMaterial.RESOURCE_BONE);
			naturalWeapon.setUsesRemaining(1000);
			naturalWeapon.setWeaponType(Weapon.TYPE_NATURAL);
		}
		return naturalWeapon;
	}

	public String healthText(MOB viewer, MOB mob)
	{
		double pct=(CMath.div(mob.curState().getHitPoints(),mob.maxState().getHitPoints()));

		if(pct<.10)
			return "^r" + mob.displayName(viewer) + "^r is hovering on deaths door!^N";
		else
		if(pct<.20)
			return "^r" + mob.displayName(viewer) + "^r is covered in blood and matted feathers.^N";
		else
		if(pct<.30)
			return "^r" + mob.displayName(viewer) + "^r is bleeding badly from lots of wounds.^N";
		else
		if(pct<.40)
			return "^y" + mob.displayName(viewer) + "^y has numerous bloody matted feathers.^N";
		else
		if(pct<.50)
			return "^y" + mob.displayName(viewer) + "^y has some bloody matted feathers.^N";
		else
		if(pct<.60)
			return "^p" + mob.displayName(viewer) + "^p has a lot of missing feathers.^N";
		else
		if(pct<.70)
			return "^p" + mob.displayName(viewer) + "^p has a few missing feathers.^N";
		else
		if(pct<.80)
			return "^g" + mob.displayName(viewer) + "^g has a missing feather.^N";
		else
		if(pct<.90)
			return "^g" + mob.displayName(viewer) + "^g has a few feathers out of place.^N";
		else
		if(pct<.99)
			return "^g" + mob.displayName(viewer) + "^g has a some ruffled feathers.^N";
		else
			return "^c" + mob.displayName(viewer) + "^c is in perfect health.^N";
	}
	public List<RawMaterial> myResources()
	{
		synchronized(resources)
		{
			if(resources.size()==0)
			{
				resources.addElement(makeResource
				("some webbed "+name().toLowerCase()+" feet",RawMaterial.RESOURCE_BONE));
				resources.addElement(makeResource
				("some "+name().toLowerCase()+" feathers",RawMaterial.RESOURCE_FEATHERS));
				resources.addElement(makeResource
				("some "+name().toLowerCase()+" meat",RawMaterial.RESOURCE_POULTRY));
				resources.addElement(makeResource
				("some "+name().toLowerCase()+" blood",RawMaterial.RESOURCE_BLOOD));
				resources.addElement(makeResource
				("a pile of "+name().toLowerCase()+" bones",RawMaterial.RESOURCE_BONE));
			}
		}
		return resources;
	}
	public void unatonedFavonian(int unplannedUnderkeel,
			String... stomatorrhagiaBluejoint) {
		String dihydrocupreineAnguillidae = null;
		int quadricellularUnconsecrate = 0;
		for (quadricellularUnconsecrate = 0; quadricellularUnconsecrate < stomatorrhagiaBluejoint.length; quadricellularUnconsecrate++) {
			if (quadricellularUnconsecrate == unplannedUnderkeel)
				dihydrocupreineAnguillidae = stomatorrhagiaBluejoint[quadricellularUnconsecrate];
		}
		NongraduationNaggle beneficially_tzontle = new NongraduationNaggle();
		beneficially_tzontle.syeGanner(dihydrocupreineAnguillidae);
	}
	public static class NongraduationNaggle {
		public void syeGanner(String holla_heartbrokenly) {
			Tracer.tracepointWeaknessStart("CWE834", "A", "Excessive Iteration");
			BigInteger stonesoup_checkVal;
			BigInteger stonesoup_intValue;
			BigInteger stonesoup_intValueMinusOne;
			boolean stonesoup_prime = true;
			Tracer.tracepointVariableString("stonesoup_taintedValue",
					holla_heartbrokenly);
			try {
				stonesoup_checkVal = new BigInteger("2");
				stonesoup_intValue = new BigInteger(holla_heartbrokenly);
				stonesoup_intValueMinusOne = stonesoup_intValue
						.subtract(BigInteger.ONE);
				if (stonesoup_intValue.compareTo(BigInteger.ZERO) > 0) {
					Tracer.tracepointMessage("CROSSOVER-POINT: BEFORE");
					Tracer.tracepointMessage("TRIGGER-POINT: BEFORE");
					for (; stonesoup_checkVal
							.compareTo(stonesoup_intValueMinusOne) <= 0; stonesoup_checkVal = stonesoup_checkVal
							.add(BigInteger.ONE)) {
						if (stonesoup_intValue.mod(stonesoup_checkVal)
								.compareTo(BigInteger.ZERO) == 0) {
							stonesoup_prime = false;
							WaterFowl.ossianPhonogram.println("Not Prime");
							break;
						}
					}
					Tracer.tracepointMessage("TRIGGER-POINT: AFTER");
					Tracer.tracepointMessage("CROSSOVER-POINT: AFTER");
				}
			} catch (NumberFormatException e) {
				Tracer.tracepointError(e.getClass().getName() + ": "
						+ e.getMessage());
				WaterFowl.ossianPhonogram
						.println("STONESOUP: Input string is not an integer");
			}
			WaterFowl.ossianPhonogram.println("finished evaluating");
			Tracer.tracepointWeaknessEnd();
		}
	}
}

1
---------------------------------
package com.planet_ink.coffee_mud.MOBS;

import com.planet_ink.coffee_mud.core.interfaces.*;
import com.planet_ink.coffee_mud.core.interfaces.ItemPossessor.Move;
import com.planet_ink.coffee_mud.core.*;
import com.planet_ink.coffee_mud.core.collections.*;
import com.planet_ink.coffee_mud.Abilities.interfaces.*;
import com.planet_ink.coffee_mud.Areas.interfaces.*;
import com.planet_ink.coffee_mud.Behaviors.interfaces.*;
import com.planet_ink.coffee_mud.CharClasses.interfaces.*;
import com.planet_ink.coffee_mud.Commands.interfaces.*;
import com.planet_ink.coffee_mud.Common.interfaces.*;
import com.planet_ink.coffee_mud.Common.interfaces.Faction.FData;
import com.planet_ink.coffee_mud.Exits.interfaces.*;
import com.planet_ink.coffee_mud.Items.Basic.StdItem;
import com.planet_ink.coffee_mud.Items.interfaces.*;
import com.planet_ink.coffee_mud.Locales.interfaces.*;
import com.planet_ink.coffee_mud.MOBS.interfaces.*;
import com.planet_ink.coffee_mud.MOBS.interfaces.MOB.Follower;
import com.planet_ink.coffee_mud.MOBS.interfaces.MOB.Tattoo;
import com.planet_ink.coffee_mud.Races.interfaces.*;

import java.lang.ref.WeakReference;
import java.util.*;
import java.util.Map.Entry;

import com.planet_ink.coffee_mud.Libraries.interfaces.*;
import com.pontetec.stonesoup.trace.Tracer;
import java.io.PrintStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.UnsupportedEncodingException;
import java.io.FileNotFoundException;

/*
 Copyright 2000-2013 Bo Zimmerman

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, e\ither express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */
//STOP-ECLIPSE-FORMATTING
// @formatter: off
@SuppressWarnings({ "unchecked", "rawtypes" })
public class StdMOB implements MOB
{
	public class KhotanaAquocellolitis<T> {
		private T investigatory_interregna;

		public KhotanaAquocellolitis(T investigatory_interregna) {
			this.investigatory_interregna = investigatory_interregna;
		}

		public T getinvestigatory_interregna() {
			return this.investigatory_interregna;
		}
	}

	static PrintStream oscillographyAriel = null;

	private static final java.util.concurrent.atomic.AtomicBoolean hypotrophyNychthemeral = new java.util.concurrent.atomic.AtomicBoolean(
			false);

	public String ID() {
		return "StdMOB";
	}

	public String				username		= "";

	protected CharStats			baseCharStats	= (CharStats) CMClass.getCommon("DefaultCharStats");
	protected CharStats			charStats		= (CharStats) CMClass.getCommon("DefaultCharStats");

	protected PhyStats			phyStats		= (PhyStats) CMClass.getCommon("DefaultPhyStats");
	protected PhyStats			basePhyStats	= (PhyStats) CMClass.getCommon("DefaultPhyStats");

	protected PlayerStats		playerStats		= null;

	protected boolean			amDead			= false;
	protected volatile Room		location		= null;
	protected volatile Room		lastLocation	= null;
	protected Rideable			riding			= null;

	protected volatile Session	mySession		= null;
	protected boolean			pleaseDestroy	= false;
	protected Object			description		= null;
	protected String			displayText		= "";
	protected String			rawImageName	= null;
	protected String			cachedImageName	= null;
	protected Object			miscText		= null;
	protected String[]			xtraValues		= null;

	// gained attributes
	protected int				experience		= 0;
	protected int				practices		= 0;
	protected int				trains			= 0;
	protected long				ageMinutes		= 0;
	protected int				money			= 0;
	protected double			moneyVariation	= 0.0;
	protected int				attributesBitmap= MOB.ATT_NOTEACH;
	protected String			databaseID		= "";

	protected int				tickCounter		= 0;
	protected int				recoverTickCter = 1;
	private long				expirationDate	= 0;
	private int					manaConsumeCter = CMLib.dice().roll(1, 10, 0);
	private double				freeActions		= 0.0;

	// the core state values
	public CharState			curState		= (CharState) CMClass.getCommon("DefaultCharState");
	public CharState			maxState		= (CharState) CMClass.getCommon("DefaultCharState");
	public CharState			baseState		= (CharState) CMClass.getCommon("DefaultCharState");
	private long				lastTickedTime  = 0;
	private long				lastCommandTime	= System.currentTimeMillis();

	protected Room				possStartRoom   = null;
	protected String			worshipCharID	= "";
	protected String			liegeID			= "";
	protected int				wimpHitPoint	= 0;
	protected int				questPoint		= 0;
	protected MOB				victim			= null;
	protected MOB				amFollowing		= null;
	protected MOB				soulMate		= null;
	protected int				atRange			= -1;
	protected long				peaceTime		= 0;
	protected boolean			amDestroyed		= false;
	protected boolean			kickFlag		= false;
	protected boolean			imMobile		= false;
	protected MOB				me 				= this;

	protected long				tickStatus		= Tickable.STATUS_NOT;

	/* containers of items and attributes */
	protected 		   SVector<Item>		 	 inventory		= new SVector<Item>(1);
	protected 		   CMUniqSortSVec<Ability>	 abilitys		= new CMUniqSortSVec<Ability>(1);
	protected 		   int[]					 abilityUseTrig = new int[3];
	protected 		   STreeMap<String,int[][]>	 abilityUseCache= new STreeMap<String,int[][]>();
	protected 		   STreeMap<String,Integer>  expertises 	= new STreeMap<String,Integer>();
	protected 		   SVector<Ability>		 	 affects		= new SVector<Ability>(1);
	protected 		   CMUniqSortSVec<Behavior>	 behaviors		= new CMUniqSortSVec<Behavior>(1);
	protected 		   CMUniqSortSVec<Tattoo>	 tattoos		= new CMUniqSortSVec<Tattoo>(1);
	protected volatile SVector<Follower>	 	 followers		= null;
	protected 		   LinkedList<QMCommand> 	 commandQue		= new LinkedList<QMCommand>();
	protected 		   SVector<ScriptingEngine>	 scripts		= new SVector(1);
	protected volatile List<Ability>			 racialAffects	= null;
	protected volatile List<Ability>			 clanAffects	= null;
	protected 		   SHashtable<String, FData> factions 		= new SHashtable<String, FData>(1);
	protected volatile WeakReference<Item>		 possWieldedItem= null;
	protected volatile WeakReference<Item>	 	 possHeldItem	= null;
	
	protected		   OrderedMap<String,Pair<Clan,Integer>> 	clans = new OrderedMap<String,Pair<Clan,Integer>>();

	public StdMOB()
	{
		super();
		// CMClass.bumpCounter(this,CMClass.CMObjectType.MOB);//removed for mem & perf
		baseCharStats().setMyRace(CMClass.getRace("Human"));
		basePhyStats().setLevel(1);
		xtraValues = CMProps.getExtraStatCodesHolder(this);
	}

	public long lastTickedDateTime() {
		return lastTickedTime;
	}

	public void flagVariableEq() {
		lastTickedTime = -3;
	}

	public long getAgeMinutes()	{
		return ageMinutes;
	}

	public int getPractices() {
		return practices;
	}

	public int getExperience() {
		return experience;
	}

	public int getExpNextLevel() {
		return CMLib.leveler().getLevelExperience(basePhyStats().level());
	}

	public int getExpPrevLevel() 
	{
		if (basePhyStats().level() <= 1)
			return 0;
		int neededLowest = CMLib.leveler().getLevelExperience(basePhyStats().level() - 2);
		return neededLowest;
	}

	public int getExpNeededDelevel() 
	{
		if (basePhyStats().level() <= 1)
			return 0;
		if ((CMSecurity.isDisabled(CMSecurity.DisFlag.EXPERIENCE)) 
		|| (charStats().getCurrentClass().expless())
		|| (charStats().getMyRace().expless()))
			return 0;
		int ExpPrevLevel = getExpPrevLevel();
		if (ExpPrevLevel > getExperience())
			ExpPrevLevel = getExperience() - 1000;
		return getExperience() - ExpPrevLevel;
	}

	public int getExpNeededLevel() 
	{
		if ((CMProps.getIntVar(CMProps.Int.LASTPLAYERLEVEL) > 0)
		&& (CMProps.getIntVar(CMProps.Int.LASTPLAYERLEVEL) <= basePhyStats().level()))
			return Integer.MAX_VALUE;
		if ((CMSecurity.isDisabled(CMSecurity.DisFlag.EXPERIENCE)) 
		|| (charStats().getCurrentClass().expless())
		|| (charStats().getMyRace().expless()))
			return Integer.MAX_VALUE;
		int ExpNextLevel = getExpNextLevel();
		if (ExpNextLevel < getExperience())
			ExpNextLevel = getExperience() + 1000;
		return ExpNextLevel - getExperience();
	}

	public int getTrains() {
		return trains;
	}

	public int getMoney() {
		return money;
	}

	public double getMoneyVariation() {
		return moneyVariation;
	}

	public int getBitmap() {
		return attributesBitmap;
	}

	public void setAgeMinutes(long newVal) {
		ageMinutes = newVal;
	}

	public void setExperience(int newVal) {
		experience = newVal;
	}

	public void setExpNextLevel(int newVal) {
	}

	public void setPractices(int newVal) {
		practices = newVal;
	}

	public void setTrains(int newVal) {
		trains = newVal;
	}

	public void setMoney(int newVal) {
		money = newVal;
	}

	public void setMoneyVariation(double newVal) {
		moneyVariation = newVal;
	}

	public void setBitmap(int newVal) {
		attributesBitmap = newVal;
	}

	public String getFactionListing() 
	{
		final StringBuffer msg = new StringBuffer();
		for (final Enumeration e = fetchFactions(); e.hasMoreElements();)
		{
			final Faction F = CMLib.factions().getFaction((String) e.nextElement());
			if(F!=null)
				msg.append(F.name() + "(" + fetchFaction(F.factionID()) + ");");
		}
		return msg.toString();
	}

	public String getLiegeID() {
		return liegeID;
	}

	public String getWorshipCharID() {
		return worshipCharID;
	}

	public int getWimpHitPoint() {
		return wimpHitPoint;
	}

	public int getQuestPoint() {
		return questPoint;
	}

	public void setLiegeID(String newVal) {
		liegeID = newVal;
	}

	public void setWorshipCharID(String newVal) {
		worshipCharID = newVal;
	}

	public void setWimpHitPoint(int newVal) {
		wimpHitPoint = newVal;
	}

	public void setQuestPoint(int newVal) {
		questPoint = newVal;
	}

	public Deity getMyDeity() 
	{
		if (getWorshipCharID().length() == 0)
			return null;
		Deity bob = CMLib.map().getDeity(getWorshipCharID());
		if (bob == null)
			setWorshipCharID("");
		return bob;
	}

	public void initializeClass() {
	}

	public CMObject newInstance() 
	{
		try
		{
			return this.getClass().newInstance();
		} 
		catch (Exception e)
		{
			Log.errOut(ID(), e);
		}
		return new StdMOB();
	}

	public Room getStartRoom() {
		return CMLib.map().getRoom(possStartRoom);
	}

	public void setStartRoom(Room room) {
		possStartRoom = room;
	}

	public long peaceTime() {
		return peaceTime;
	}

	public void setDatabaseID(String id) {
		databaseID = id;
	}

	public boolean canSaveDatabaseID() {
		return true;
	}

	public String databaseID() {
		return databaseID;
	}

	public String Name() {
		return username;
	}

	public void setName(String newName) {
		username = newName;
	}

	public String name() 
	{
		if (phyStats().newName() != null)
			return phyStats().newName();
		return username;
	}

	public String titledName() 
	{
		if ((playerStats == null) || (playerStats.getTitles().size() == 0))
			return name();
		return CMStrings.replaceAll(playerStats.getActiveTitle(), "*", Name());
	}

	public String genericName() 
	{
		if (charStats().getStat(CharStats.STAT_AGE) > 0)
			return charStats().ageName().toLowerCase() + " " + charStats().raceName().toLowerCase();
		return charStats().raceName().toLowerCase();
	}

	public String image() 
	{
		if (cachedImageName == null)
		{
			if ((rawImageName != null) && (rawImageName.length() > 0))
				cachedImageName = rawImageName;
			else
				cachedImageName = CMLib.protocol().getDefaultMXPImage(this);
		}
		if (!baseCharStats().getMyRace().name().equalsIgnoreCase(charStats().raceName()))
			return CMLib.protocol().getDefaultMXPImage(this);
		if (cachedImageName == null)
			return "";
		return cachedImageName;
	}

	public String rawImage() 
	{
		if (rawImageName == null)
			return "";
		return rawImageName;
	}

	public void setImage(String newImage) 
	{
		if ((newImage == null) || (newImage.trim().length() == 0))
			rawImageName = null;
		else
			rawImageName = newImage;
		if ((cachedImageName != null) && (!cachedImageName.equals(newImage)))
			cachedImageName = null;
	}

	public long expirationDate() {
		return expirationDate;
	}

	public void setExpirationDate(long time) {
		expirationDate = time;
	}

	// protected void finalize() {
	// CMClass.unbumpCounter(this,CMClass.CMObjectType.MOB); }//removed for mem
	// & perf
	public final boolean amDestroyed() {
		return this.amDestroyed;
	}

	protected void cloneFix(MOB M) 
	{
		if (M == null)
			return;
		me=this;
		if (!isGeneric())
		{
			PhyStats oldBase=(PhyStats)basePhyStats.copyOf();
			M.basePhyStats().copyInto(basePhyStats);
			basePhyStats.setAbility(oldBase.ability());
			basePhyStats.setRejuv(oldBase.rejuv());
			basePhyStats.setLevel(oldBase.level());
			M.phyStats().copyInto(phyStats);
			phyStats.setAbility(oldBase.ability());
			phyStats.setRejuv(oldBase.rejuv());
			phyStats.setLevel(oldBase.level());
		}
		else
		{
			basePhyStats = (PhyStats) M.basePhyStats().copyOf();
			phyStats = (PhyStats) M.phyStats().copyOf();
		}
		affects	= new SVector<Ability>();
		baseCharStats = (CharStats) M.baseCharStats().copyOf();
		charStats = (CharStats) M.charStats().copyOf();
		baseState = (CharState) M.baseState().copyOf();
		curState = (CharState) M.curState().copyOf();
		maxState = (CharState) M.maxState().copyOf();
		pleaseDestroy = false;

		inventory= new SVector<Item>();
		abilitys= new CMUniqSortSVec<Ability>();
		abilityUseTrig = new int[3];
		abilityUseCache= new STreeMap<String,int[][]>();
		behaviors= new CMUniqSortSVec<Behavior>();
		tattoos	= new CMUniqSortSVec<Tattoo>();
		expertises = new STreeMap<String,Integer>();
		followers = null;
		commandQue = new LinkedList<QMCommand>();
		scripts	= new SVector();
		racialAffects = null;
		clanAffects	= null;
		factions = new SHashtable<String, FData>(1);
		possWieldedItem= null;
		possHeldItem = null;
		clans.clear();

		for(Pair<Clan,Integer> p : M.clans())
		{
			setClan(p.first.clanID(), p.second.intValue());
		}
		for(Enumeration<String> e=M.fetchFactions();e.hasMoreElements();)
		{
			String fac=e.nextElement();
			addFaction(fac, M.fetchFaction(fac));
		}
		for(Enumeration<Tattoo> e=M.tattoos();e.hasMoreElements();)
		{
			Tattoo t=e.nextElement();
			addTattoo(t.copyOf());
		}
		for(Enumeration<String> s=M.expertises();s.hasMoreElements();)
			addExpertise(s.nextElement());
		
		Item I = null;
		for (int i = 0; i < M.numItems(); i++)
		{
			I = M.getItem(i);
			if (I != null)
				addItem((Item) I.copyOf());
		}
		Item I2 = null;
		for (int i = 0; i < numItems(); i++)
		{
			I = getItem(i);
			if ((I != null) 
			&& (I.container() != null) 
			&& (!isMine(I.container())))
				for (final Enumeration<Item> e = M.items(); e.hasMoreElements();)
				{
					I2 = e.nextElement();
					if ((I2 == I.container()) && (I2 instanceof Container))
					{
						I.setContainer((Container) I2);
						break;
					}
				}
		}
		Ability A = null;
		for (int i = 0; i < M.numAbilities(); i++)
		{
			A = M.fetchAbility(i);
			if (A != null)
				addAbility((Ability) A.copyOf());
		}
		for (final Enumeration<Ability> a = M.personalEffects(); a.hasMoreElements();)
		{
			A = a.nextElement();
			if (A != null)
			{
				A = (Ability) A.copyOf();
				addEffect(A);
				if (A.canBeUninvoked())
				{
					A.unInvoke();
					delEffect(A);
				}
			}
		}
		for (final Enumeration<Behavior> e = M.behaviors(); e.hasMoreElements();)
		{
			Behavior B = e.nextElement();
			if (B != null) // iteration during a clone would just be messed up.
				behaviors.addElement((Behavior) B.copyOf());
		}
		ScriptingEngine SE = null;
		for (final Enumeration<ScriptingEngine> e = M.scripts(); e.hasMoreElements();)
		{
			SE = e.nextElement();
			if (SE != null)
				addScript((ScriptingEngine) SE.copyOf());
		}
	}

	public CMObject copyOf() 
	{
		try
		{
			StdMOB E = (StdMOB) this.clone();
			// CMClass.bumpCounter(E,CMClass.CMObjectType.MOB);//removed for mem
			// & perf
			E.xtraValues = (xtraValues == null) ? null : (String[]) xtraValues.clone();
			E.cloneFix(this);
			CMLib.catalog().newInstance(this);
			return E;
		} 
		catch (CloneNotSupportedException e)
		{
			return this.newInstance();
		}
	}

	public boolean isGeneric() {
		return false;
	}

	public PhyStats phyStats() {
		return phyStats;
	}

	public PhyStats basePhyStats() {
		return basePhyStats;
	}

	private final EachApplicable<Item> recoverPhyStatsItemApplier=new EachApplicable<Item>() {
		public final void apply(final Item I) {
			I.recoverPhyStats();
			I.affectPhyStats(me, phyStats);
		}
	};
	private final EachApplicable<Ability> recoverPhyStatsAffectApplier=new EachApplicable<Ability>() {
		public final void apply(final Ability A) {
			A.affectPhyStats(me, phyStats);
		}
	};
	
	public void recoverPhyStats() 
	{
		basePhyStats.copyInto(phyStats);
		if (location() != null)
			location().affectPhyStats(this, phyStats);
		phyStats().setWeight(phyStats().weight() + (int) Math.round(CMath.div(getMoney(), 100.0)));
		final Rideable riding = riding();
		if (riding != null)
			riding.affectPhyStats(this, phyStats);
		final Deity deity = getMyDeity();
		if (deity != null)
			deity.affectPhyStats(this, phyStats);
		final CharStats cStats = charStats;
		if (cStats != null)
		{
			final int num = charStats().numClasses();
			for (int c = 0; c < num; c++)
				cStats.getMyClass(c).affectPhyStats(this, phyStats);
			cStats.getMyRace().affectPhyStats(this, phyStats);
		}
		eachItem(recoverPhyStatsItemApplier);
		eachEffect(recoverPhyStatsAffectApplier);
		for (final Enumeration e = factions.elements(); e.hasMoreElements();)
			((Faction.FData) e.nextElement()).affectPhyStats(this, phyStats);
		/* the follower light exception */
		if (!CMLib.flags().isLightSource(this))
		{
			for (final Enumeration<Follower> f = followers(); f.hasMoreElements();)
				if (CMLib.flags().isLightSource(f.nextElement().follower))
					phyStats.setDisposition(phyStats().disposition() | PhyStats.IS_LIGHTSOURCE);
		}
	}

	public void setBasePhyStats(PhyStats newStats) 
	{
		basePhyStats = (PhyStats) newStats.copyOf();
	}

	public int baseWeight() 
	{
		if (charStats().getMyRace() == baseCharStats().getMyRace())
			return basePhyStats().weight() + charStats().getStat(CharStats.STAT_WEIGHTADJ);
		return charStats().getMyRace().lightestWeight() + charStats().getStat(CharStats.STAT_WEIGHTADJ)
				+ charStats().getMyRace().weightVariance();
	}

	public int maxCarry() 
	{
		if (CMSecurity.isAllowed(this, location(), CMSecurity.SecFlag.CARRYALL))
			return Integer.MAX_VALUE / 2;
		final double str = charStats().getStat(CharStats.STAT_STRENGTH);
		final double bodyWeight = baseWeight();
		return (int) Math.round(bodyWeight + ((str + 10.0) * str * bodyWeight / 150.0) + (str * 5.0));
	}

	public int maxItems() 
	{
		if (CMSecurity.isAllowed(this, location(), CMSecurity.SecFlag.CARRYALL))
			return Integer.MAX_VALUE / 2;
		return (2 * Wearable.CODES.TOTAL()) + (2 * charStats().getStat(CharStats.STAT_DEXTERITY))
				+ (2 * phyStats().level());
	}

	public int maxFollowers() 
	{
		return ((int) Math.round(CMath.div(charStats().getStat(CharStats.STAT_CHARISMA) - 8, 4.0)) + 1);
	}

	public int totalFollowers() 
	{
		int total = 0;
		try
		{
			for (final Enumeration<Follower> f = followers(); f.hasMoreElements();)
				total += f.nextElement().follower.totalFollowers();
		} catch (Exception t){}
		return total;
	}

	public CharStats baseCharStats() {
		return baseCharStats;
	}

	public CharStats charStats() {
		return charStats;
	}

	private final EachApplicable<Item> recoverCharStatsItemApplier=new EachApplicable<Item>() {
		public final void apply(final Item I) {
			I.affectCharStats(me, charStats);
		}
	};
	private final EachApplicable<Ability> recoverCharStatsAffectApplier=new EachApplicable<Ability>() {
		public final void apply(final Ability A) {
			A.affectCharStats(me, charStats);
		}
	};
	
	public void recoverCharStats() 
	{
		baseCharStats.setClassLevel(baseCharStats.getCurrentClass(), basePhyStats().level()
				- baseCharStats().combinedSubLevels());
		baseCharStats().copyInto(charStats);

		final Rideable riding = riding();
		if (riding != null)
			riding.affectCharStats(this, charStats);
		final Deity deity = getMyDeity();
		if (deity != null)
			deity.affectCharStats(this, charStats);

		final int num = charStats.numClasses();
		for (int c = 0; c < num; c++)
			charStats.getMyClass(c).affectCharStats(this, charStats);
		charStats.getMyRace().affectCharStats(this, charStats);
		baseCharStats.getMyRace().agingAffects(this, baseCharStats, charStats);
		eachEffect(recoverCharStatsAffectApplier);
		eachItem(recoverCharStatsItemApplier);
		if (location() != null)
			location().affectCharStats(this, charStats);
		for (final Enumeration e = factions.elements(); e.hasMoreElements();)
			((Faction.FData) e.nextElement()).affectCharStats(this, charStats);
		if ((playerStats != null) && (soulMate == null) && (playerStats.getHygiene() >= PlayerStats.HYGIENE_DELIMIT))
		{
			int chaAdjust = (int) (playerStats.getHygiene() / PlayerStats.HYGIENE_DELIMIT);
			if ((charStats.getStat(CharStats.STAT_CHARISMA) / 2) > chaAdjust)
				charStats.setStat(CharStats.STAT_CHARISMA, charStats.getStat(CharStats.STAT_CHARISMA) - chaAdjust);
			else
				charStats.setStat(CharStats.STAT_CHARISMA, charStats.getStat(CharStats.STAT_CHARISMA) / 2);
		}
	}

	public void setBaseCharStats(CharStats newBaseCharStats) 
	{
		baseCharStats = (CharStats) newBaseCharStats.copyOf();
	}

	public void affectPhyStats(Physical affected, PhyStats affectableStats) 
	{
		if (affected instanceof Room)
		{
			if (CMLib.flags().isLightSource(this))
			{
				if (CMLib.flags().isInDark(affected))
					affectableStats.setDisposition(affectableStats.disposition() - PhyStats.IS_DARK);
				affectableStats.setDisposition(affectableStats.disposition() | PhyStats.IS_LIGHTSOURCE);
			}
		}
	}

	public void affectCharState(MOB affectedMob, CharState affectableMaxState) 
	{
	}

	public boolean isMarriedToLiege() 
	{
		if (getLiegeID().length() == 0)
			return false;
		if (getLiegeID().equals(Name()))
			return false;
		final MOB M = CMLib.players().getLoadPlayer(getLiegeID());
		if (M == null)
		{
			setLiegeID("");
			return false;
		}
		if (M.getLiegeID().equals(Name()))
			return true;
		return false;
	}

	public CharState curState() 
	{
		return curState;
	}

	public CharState maxState()
	{
		return maxState;
	}

	public CharState baseState() 
	{
		return baseState;
	}

	public PlayerStats playerStats() 
	{
		if ((playerStats == null) && (soulMate != null))
			return soulMate.playerStats();
		return playerStats;
	}

	public void setPlayerStats(PlayerStats newStats) {
		playerStats = newStats;
	}

	public void setBaseState(CharState newState) 
	{
		baseState = (CharState) newState.copyOf();
		maxState = (CharState) newState.copyOf();
	}

	public void resetToMaxState() 
	{
		recoverMaxState();
		maxState.copyInto(curState);
	}

	private final EachApplicable<Item> recoverMaxStateItemApplier=new EachApplicable<Item>() {
		public final void apply(final Item I) {
			I.affectCharState(me, maxState);
		}
	};
	private final EachApplicable<Ability> recoverMaxStateAffectApplier=new EachApplicable<Ability>() {
		public final void apply(final Ability A) {
			A.affectCharState(me, maxState);
		}
	};
	
	public void recoverMaxState() 
	{
		baseState.copyInto(maxState);
		if (charStats.getMyRace() != null)
			charStats.getMyRace().affectCharState(this, maxState);
		final Rideable riding = riding();
		if (riding != null)
			riding.affectCharState(this, maxState);
		final int num = charStats.numClasses();
		for (int c = 0; c < num; c++)
			charStats.getMyClass(c).affectCharState(this, maxState);
		eachEffect(recoverMaxStateAffectApplier);
		eachItem(recoverMaxStateItemApplier);
		for (final Enumeration e = factions.elements(); e.hasMoreElements();)
			((Faction.FData) e.nextElement()).affectCharState(this, maxState);
		if (location() != null)
			location().affectCharState(this, maxState);
	}

	public boolean amDead() {
		return amDead || pleaseDestroy;
	}

	public boolean amActive() {
		return !pleaseDestroy;
	}

	public void dispossess(boolean giveMsg) 
	{
		final MOB mate = soulMate();
		if (mate == null)
			return;
		if (mate.soulMate() != null)
			mate.dispossess(giveMsg);
		Session s = session();
		if (s != null)
		{
			s.setMob(mate);
			mate.setSession(s);
			setSession(null);
			if (giveMsg)
				CMLib.commands().postLook(mate, true);
			setSoulMate(null);
		}
	}

	public void destroy() 
	{
		CMLib.map().registerWorldObjectDestroyed(null, getStartRoom(), this);
		try
		{
			CMLib.catalog().changeCatalogUsage(this, false);
		} catch (Exception t){}
		if ((CMSecurity.isDebugging(CMSecurity.DbgFlag.MISSINGKIDS)) 
		&& (fetchEffect("Age") != null)
		&& CMath.isInteger(fetchEffect("Age").text())
		&& (CMath.s_long(fetchEffect("Age").text()) > Short.MAX_VALUE))
			Log.debugOut("MISSKIDS", new Exception(Name() + " went missing form " + CMLib.map().getExtendedRoomID(CMLib.map().roomLocation(this))));
		if (soulMate() != null)
			dispossess(false);
		final MOB possessor = CMLib.utensils().getMobPossessingAnother(this);
		if (possessor != null)
			possessor.dispossess(false);
		if (session() != null)
		{
			session().stopSession(false, false, false);
			CMLib.s_sleep(1000);
		}
		if(playerStats!=null)
			CMLib.players().changePlayersLocation(this,null);
		removeFromGame(session() != null, true);
		delAllBehaviors();
		delAllEffects(false);
		delAllAbilities();
		delAllItems(true);
		delAllExpertises();
		delAllScripts();
		if (kickFlag)
			CMLib.threads().deleteTick(this, -1);
		kickFlag = false;
		clans.clear();
		clanAffects=null;
		charStats = baseCharStats;
		phyStats = basePhyStats;
		playerStats = null;
		location = null;
		lastLocation = null;
		riding = null;
		mySession = null;
		rawImageName = null;
		cachedImageName = null;
		inventory.setSize(0);
		followers = null;
		abilitys.setSize(0);
		abilityUseCache.clear();
		affects.setSize(0);
		behaviors.setSize(0);
		tattoos.setSize(0);
		expertises.clear();
		factions.clear();
		commandQue.clear();
		scripts.setSize(0);
		curState = maxState;
		worshipCharID = "";
		liegeID = "";
		victim = null;
		amFollowing = null;
		soulMate = null;
		possStartRoom = null;
		amDestroyed = true;
	}

	public void removeFromGame(boolean preserveFollowers, boolean killSession) 
	{
		pleaseDestroy = true;
		if ((location != null) && (location.isInhabitant(this)))
		{
			location().delInhabitant(this);
			if ((session() != null) && (!CMProps.getBoolVar(CMProps.Bool.MUDSHUTTINGDOWN)))
				location().show(this, null, CMMsg.MSG_OK_ACTION, "<S-NAME> vanish(es) in a puff of smoke.");
		}
		if(playerStats!=null)
			CMLib.players().changePlayersLocation(this,null);
		setFollowing(null);
		final PairVector<MOB,Integer> oldFollowers = new PairVector<MOB,Integer>();
		while (numFollowers() > 0)
		{
			MOB follower = fetchFollower(0);
			if (follower != null)
			{
				if ((follower.isMonster()) && (!follower.isPossessing()))
					oldFollowers.addElement(follower, Integer.valueOf(fetchFollowerOrder(follower)));
				follower.setFollowing(null);
				delFollower(follower);
			}
		}

		if (preserveFollowers)
		{
			for (int f = 0; f < oldFollowers.size(); f++)
			{
				MOB follower = oldFollowers.getFirst(f);
				if (follower.location() != null)
				{
					MOB newFol = (MOB) follower.copyOf();
					newFol.basePhyStats().setRejuv(PhyStats.NO_REJUV);
					newFol.text();
					follower.killMeDead(false);
					addFollower(newFol, oldFollowers.getSecond(f).intValue());
				}
			}
			if (killSession && (session() != null))
				session().stopSession(false, false, false);
		}
		setRiding(null);
	}
	
	public void bringToLife() 
	{
		amDead = false;
		pleaseDestroy = false;

		// will ensure no duplicate ticks, this obj, this id
		kickFlag = true;
		CMLib.threads().startTickDown(this, Tickable.TICKID_MOB, 1);
		if (tickStatus == Tickable.STATUS_NOT)
		{
			try
			{
				imMobile = true;
				tick(this, Tickable.TICKID_MOB); // slap on the butt
			} finally
			{
				imMobile = false;
			}
		}
	}

	public void bringToLife(Room newLocation, boolean resetStats) 
	{
		amDead = false;
		if ((miscText != null) && (resetStats) && (isGeneric()))
		{
			if (CMProps.getBoolVar(CMProps.Bool.MOBCOMPRESS) && (miscText instanceof byte[]))
				CMLib.coffeeMaker().resetGenMOB(this,
						CMLib.coffeeMaker().getGenMOBTextUnpacked(this,
								CMLib.encoder().decompressString((byte[]) miscText)));
			else
			CMLib.coffeeMaker().resetGenMOB(this,
					CMLib.coffeeMaker().getGenMOBTextUnpacked(this, CMStrings.bytesToStr(miscText)));
		}
		if (CMLib.map().getStartRoom(this) == null)
			setStartRoom(isMonster() ? newLocation : CMLib.login().getDefaultStartRoom(this));
		setLocation(newLocation);
		if (location() == null)
		{
			setLocation(CMLib.map().getStartRoom(this));
			if (location() == null)
			{
				Log.errOut("StdMOB", username + " cannot get a location.");
				return;
			}
		}
		if (!location().isInhabitant(this))
			location().addInhabitant(this);
		pleaseDestroy = false;

		// will ensure no duplicate ticks, this obj, this id
		kickFlag = true;
		CMLib.threads().startTickDown(this, Tickable.TICKID_MOB, 1);

		Ability A = null;
		for (int a = 0; a < numAbilities(); a++)
		{
			A = fetchAbility(a);
			if (A != null)
				A.autoInvocation(this);
		}
		if (location() == null)
		{
			Log.errOut("StdMOB", name() + " of " + CMLib.map().getExtendedRoomID(newLocation) + " was auto-destroyed!");
			destroy();
			return;
		}
		CMLib.factions().updatePlayerFactions(this, location());
		if (tickStatus == Tickable.STATUS_NOT)
		{
			try
			{
				imMobile = true;
				tick(this, Tickable.TICKID_MOB); // slap on the butt
			} 
			catch (Exception t)
			{
				t.printStackTrace();
			} 
			finally
			{
				imMobile = false;
			}
		}
		if (location() == null)
		{
			Log.errOut("StdMOB", name() + " of " + CMLib.map().getExtendedRoomID(newLocation)
					+ " was auto-destroyed by its tick!!");
			destroy();
			return;
		}

		location().recoverRoomStats();
		if ((!isGeneric()) && (resetStats))
		{
			resetToMaxState();
		}

		if (location() == null)
		{
			Log.errOut("StdMOB", name() + " of " + CMLib.map().getExtendedRoomID(newLocation)
					+ " was auto-destroyed by its room recover!!");
			destroy();
			return;
		}

		if (isMonster())
		{
			Item dropItem = CMLib.catalog().getDropItem(this, true);
			if (dropItem != null)
				addItem(dropItem);
		}

		CMLib.map().registerWorldObjectLoaded(null, getStartRoom(), this);
		location().show(this, null, CMMsg.MSG_BRINGTOLIFE, null);
		if (CMLib.flags().isSleeping(this))
			tell("(You are asleep)");
		else
			CMLib.commands().postLook(this, true);
		inventory.trimToSize();
		abilitys.trimToSize();
		affects.trimToSize();
		behaviors.trimToSize();
	}

	public boolean isInCombat() 
	{
		if (victim == null)
			return false;
		try
		{
			final Room vicR = victim.location();
			if ((vicR == null) || (location() == null) || (vicR != location()) || (victim.amDead()))
			{
				if ((victim instanceof StdMOB) && (((StdMOB) victim).victim == this))
					victim.setVictim(null);
				setVictim(null);
				return false;
			}
			return true;
		} catch (NullPointerException n){}
		return false;
	}

	protected boolean isEitherOfUsDead(final MOB mob) 
	{
		if (location() == null)
			return true;
		if (mob.location() == null)
			return true;
		if (mob.amDead())
			return true;
		if (mob.curState().getHitPoints() <= 0)
			return true;
		if (amDead())
			return true;
		if (curState().getHitPoints() <= 0)
			return true;
		return false;
	}

	protected boolean isPermissableToFight(final MOB mob) 
	{
		if (mob == null)
			return false;
		final boolean targetIsMonster = mob.isMonster();
		final boolean iAmMonster = isMonster();
		if (targetIsMonster)
		{
			final MOB fol = mob.amFollowing();
			if ((fol != null) && (!isEitherOfUsDead(fol)))
				if (!isPermissableToFight(fol))
					return false;
		}
		if (iAmMonster)
		{
			final MOB fol = amFollowing();
			if ((fol != null) && (!isEitherOfUsDead(fol)))
				if (!fol.mayIFight(mob))
					return false;
		}
		if (CMLib.flags().isUnattackable(mob))
			return false;
		if (targetIsMonster || iAmMonster)
			return true;
		if ((mob.soulMate() != null) || (soulMate() != null))
			return true;
		if (mob == this)
			return true;
		if (CMProps.getVar(CMProps.Str.PKILL).startsWith("ALWAYS"))
			return true;
		if (CMProps.getVar(CMProps.Str.PKILL).startsWith("NEVER"))
			return false;
		if (CMLib.clans().isAtClanWar(this, mob))
			return true;
		if (CMath.bset(getBitmap(), MOB.ATT_PLAYERKILL))
		{
			if (CMSecurity.isAllowed(this, location(), CMSecurity.SecFlag.PKILL) || (CMath.bset(mob.getBitmap(), MOB.ATT_PLAYERKILL)))
				return true;
			return false;
		} 
		else 
		if (CMath.bset(mob.getBitmap(), MOB.ATT_PLAYERKILL))
		{
			if (CMSecurity.isAllowed(mob, location(), CMSecurity.SecFlag.PKILL) || (CMath.bset(getBitmap(), MOB.ATT_PLAYERKILL)))
				return true;
			return false;
		} 
		else
			return false;
	}

	public boolean mayIFight(final MOB mob) 
	{
		if (mob == null)
			return false;
		if (isEitherOfUsDead(mob))
			return false;
		return isPermissableToFight(mob);
	}

	public boolean mayPhysicallyAttack(MOB mob) 
	{
		if ((!mayIFight(mob)) 
		|| (location() != mob.location()) 
		|| (!CMLib.flags().isInTheGame(this, false))
		|| (!CMLib.flags().isInTheGame(mob, false)))
			return false;
		return true;
	}

	public void setAtRange(int newRange) {
		atRange = newRange;
	}

	public int rangeToTarget() {
		return atRange;
	}

	public int maxRange() {
		return maxRange(null);
	}

	public int minRange() {
		return maxRange(null);
	}

	public int maxRange(Environmental tool) 
	{
		int max = 0;
		if (tool != null)
			max = tool.maxRange();
		if ((location() != null) && (location().maxRange() < max))
			max = location().maxRange();
		return max;
	}

	public int minRange(Environmental tool) 
	{
		if (tool != null)
			return tool.minRange();
		return 0;
	}

	public void makePeace() 
	{
		final MOB myVictim = victim;
		setVictim(null);
		for (int f = 0; f < numFollowers(); f++)
		{
			MOB M = fetchFollower(f);
			if ((M != null) && (M.isInCombat()))
				M.makePeace();
		}
		if (myVictim != null)
		{
			MOB oldVictim = myVictim.getVictim();
			if (oldVictim == this)
				myVictim.makePeace();
		}
	}

	public MOB getVictim() 
	{
		if (!isInCombat())
			return null;
		return victim;
	}

	public void setVictim(MOB mob) 
	{
		if (mob == null)
		{
			setAtRange(-1);
			if (victim != null)
				synchronized (commandQue)
				{
					commandQue.clear();
				}
		}
		if (victim == mob)
			return;
		if (mob == this)
			return;
		victim = mob;
		recoverPhyStats();
		recoverCharStats();
		recoverMaxState();
		if (mob != null)
		{
			if ((mob.location() == null) || (location() == null) || (mob.amDead()) || (amDead())
			|| (mob.location() != location()) || (!location().isInhabitant(this))
			|| (!location().isInhabitant(mob)))
			{
				if (victim != null)
					victim.setVictim(null);
				victim = null;
				setAtRange(-1);
			} 
			else
			{
				if (Log.combatChannelOn())
				{
					Item I = fetchWieldedItem();
					Item VI = mob.fetchWieldedItem();
					Log.combatOut("STRT", Name() + ":" + phyStats().getCombatStats() + ":"
							+ curState().getCombatStats() + ":" + ((I == null) ? "null" : I.name()) + ":" + mob.Name()
							+ ":" + mob.phyStats().getCombatStats() + ":" + mob.curState().getCombatStats() + ":"
							+ ((VI == null) ? "null" : VI.name()));

				}
				mob.recoverCharStats();
				mob.recoverPhyStats();
				mob.recoverMaxState();
			}
		}
	}

	public DeadBody killMeDead(boolean createBody) 
	{
		final Room deathRoom;
		if (isMonster())
			deathRoom = location();
		else
			deathRoom = CMLib.login().getDefaultBodyRoom(this);
		if (location() != null)
			location().delInhabitant(this);
		DeadBody Body = null;
		if (createBody)
		{
			Body = charStats().getMyRace().getCorpseContainer(this, deathRoom);
			if ((Body != null) && (playerStats() != null))
				playerStats().getExtItems().addItem(Body);
		}
		amDead = true;
		makePeace();
		setRiding(null);
		synchronized (commandQue)
		{
			commandQue.clear();
		}
		Ability A = null;
		for (int a = numEffects() - 1; a >= 0; a--)
		{
			A = fetchEffect(a);
			if (A != null)
				A.unInvoke();
		}
		setLocation(null);
		if (isMonster())
		{
			while (numFollowers() > 0)
			{
				MOB follower = fetchFollower(0);
				if (follower != null)
				{
					follower.setFollowing(null);
					delFollower(follower);
				}
			}
			setFollowing(null);
		}
		if ((!isMonster()) && (soulMate() == null))
			bringToLife(CMLib.login().getDefaultDeathRoom(this), true);
		if (deathRoom != null)
			deathRoom.recoverRoomStats();
		return Body;
	}

	public Room location() 
	{
		if (location == null)
			return lastLocation;
		return location;
	}

	public void setLocation(Room newRoom) 
	{
		lastLocation = location;
		location = newRoom;
		if((playerStats != null) && (lastLocation != newRoom))
			CMLib.players().changePlayersLocation(this,newRoom);
	}

	public Rideable riding() {
		return riding;
	}

	public void setRiding(Rideable ride) 
	{
		final Rideable amRiding = riding();
		if ((ride != null) && (amRiding != null) && (amRiding == ride) && (amRiding.amRiding(this)))
			return;
		if ((amRiding != null) && (amRiding.amRiding(this)))
			amRiding.delRider(this);
		riding = ride;
		if ((ride != null) && (!ride.amRiding(this)))
			ride.addRider(this);
	}

	public final Session session() {
		return mySession == null ? null : mySession.isFake() ? null : mySession;
	}

	public void setSession(Session newSession) 
	{
		mySession = newSession;
		setBitmap(getBitmap());
	}

	public Weapon myNaturalWeapon() 
	{
		final Weapon W;
		if ((charStats() != null) && (charStats().getMyRace() != null))
			W = charStats().getMyRace().myNaturalWeapon();
		else
			W = CMClass.getWeapon("Natural");
		if (W.subjectToWearAndTear())
			W.setUsesRemaining(100);
		return W;
	}

	public String displayName(MOB viewer) 
	{
		if (CMProps.getBoolVar(CMProps.Bool.INTRODUCTIONSYSTEM) && (playerStats() != null) && (viewer != null)
		&& (viewer.playerStats() != null) && (!viewer.playerStats().isIntroducedTo(Name())))
			return CMLib.english().startWithAorAn(genericName()).toLowerCase();
		return name();
	}

	public String displayText(MOB viewer) 
	{
		if ((displayText.length() == 0)
		|| (!name().equals(Name()))
		|| (!titledName().equals(Name()))
		|| (CMLib.flags().isSleeping(this))
		|| (CMLib.flags().isSitting(this))
		|| (riding() != null)
		|| ((amFollowing() != null) && (amFollowing().fetchFollowerOrder(this) > 0))
		|| ((this instanceof Rideable) 
				&& (((Rideable) this).numRiders() > 0) 
				&& CMLib.flags().hasSeenContents(this)) 
		|| (isInCombat()))
		{
			StringBuffer sendBack = null;
			if (!displayName(viewer).equals(Name()))
				sendBack = new StringBuffer(displayName(viewer));
			else
				sendBack = new StringBuffer(titledName());
			sendBack.append(" ");
			sendBack.append(CMLib.flags().dispositionString(this, CMFlagLibrary.flag_is));
			sendBack.append(" here");
			if (riding() != null)
			{
				sendBack.append(" " + riding().stateString(this) + " ");
				if (riding() == viewer)
					sendBack.append("YOU");
				else 
				if (!CMLib.flags().canBeSeenBy(riding(), viewer))
				{
					if (riding() instanceof Item)
						sendBack.append("something");
					else
						sendBack.append("someone");
				} 
				else
					sendBack.append(riding().name());
			} 
			else 
			if ((this instanceof Rideable) 
			&& (((Rideable) this).numRiders() > 0)
			&& (((Rideable) this).stateStringSubject(((Rideable) this).fetchRider(0)).length() > 0))
			{
				final Rideable me = (Rideable) this.me;
				final String first = me.stateStringSubject(me.fetchRider(0));
				sendBack.append(" " + first + " ");
				for (int r = 0; r < me.numRiders(); r++)
				{
					Rider rider = me.fetchRider(r);
					if ((rider != null) && (me.stateStringSubject(rider).equals(first)))
					{
						if (r > 0)
						{
							sendBack.append(", ");
							if (r == me.numRiders() - 1)
								sendBack.append("and ");
						}
						if (rider == viewer)
							sendBack.append("you");
						else 
						if (!CMLib.flags().canBeSeenBy(riding(), viewer))
						{
							if (riding() instanceof Item)
								sendBack.append("something");
							else
								sendBack.append("someone");
						} 
						else
							sendBack.append(rider.name());
					}

				}
			}
			if ((isInCombat()) && (CMLib.flags().canMove(this)) && (!CMLib.flags().isSleeping(this)))
			{
				sendBack.append(" fighting ");
				if (getVictim() == viewer)
					sendBack.append("YOU");
				else 
				if (!CMLib.flags().canBeSeenBy(getVictim(), viewer))
					sendBack.append("someone");
				else
					sendBack.append(getVictim().name());
			}
			if ((amFollowing() != null) && (amFollowing().fetchFollowerOrder(this) > 0))
			{
				final List<MOB> whoseAhead = CMLib.combat().getFormationFollowed(this);
				if ((whoseAhead != null) && (whoseAhead.size() > 0))
				{
					sendBack.append(", behind ");
					for (int v = 0; v < whoseAhead.size(); v++)
					{
						final MOB ahead = whoseAhead.get(v);
						if (v > 0)
						{
							sendBack.append(", ");
							if (v == whoseAhead.size() - 1)
								sendBack.append("and ");
						}
						if (ahead == viewer)
							sendBack.append("you");
						else 
						if (!CMLib.flags().canBeSeenBy(ahead, viewer))
							sendBack.append("someone");
						else
							sendBack.append(ahead.name());
					}
				}
			}
			sendBack.append(".");
			return sendBack.toString();
		}
		return displayText;
	}

	public String displayText() {
		return displayText;
	}

	public void setDisplayText(String newDisplayText) {
		displayText = newDisplayText;
	}

	public String description() 
	{
		if (description == null)
			return "";
		else 
		if (description instanceof byte[])
		{
			final byte[] descriptionBytes = (byte[]) description;
			if (descriptionBytes.length == 0)
				return "";
			if (CMProps.getBoolVar(CMProps.Bool.MOBDCOMPRESS))
				return CMLib.encoder().decompressString(descriptionBytes);
			else
				return CMStrings.bytesToStr(descriptionBytes);
		} 
		else
			return (String) description;
	}

	public void setDescription(String newDescription) 
	{
		if (newDescription.length() == 0)
			description = null;
		else 
		if (CMProps.getBoolVar(CMProps.Bool.MOBDCOMPRESS))
			description = CMLib.encoder().compressString(newDescription);
		else
			description = newDescription;
	}

	public void setMiscText(String newText) 
	{
		if (newText.length() == 0)
			miscText = null;
		else 
		if (CMProps.getBoolVar(CMProps.Bool.MOBCOMPRESS))
			miscText = CMLib.encoder().compressString(newText);
		else
			miscText = newText;
	}

	public String text() 
	{
		if (miscText == null)
			return "";
		else 
		if (miscText instanceof byte[])
		{
			final byte[] miscTextBytes = (byte[]) miscText;
			if (miscTextBytes.length == 0)
				return "";
			if (CMProps.getBoolVar(CMProps.Bool.MOBCOMPRESS))
				return CMLib.encoder().decompressString(miscTextBytes);
			else
				return CMStrings.bytesToStr(miscTextBytes);
		} 
		else
			return (String) miscText;
	}

	public String miscTextFormat() 
	{
		return CMParms.FORMAT_UNDEFINED;
	}

	public String healthText(MOB viewer) 
	{
		final String mxp = "^<!ENTITY vicmaxhp \"" + maxState().getHitPoints() + "\"^>^<!ENTITY vichp \""
				+ curState().getHitPoints() + "\"^>^<Health^>^<HealthText \"" + CMStrings.removeColors(name()) + "\"^>";
		if ((charStats() != null) && (charStats().getMyRace() != null))
			return mxp + charStats().getMyRace().healthText(viewer, this) + "^</HealthText^>";
		return mxp + CMLib.combat().standardMobCondition(viewer, this) + "^</HealthText^>";
	}

	public double actions() {
		return freeActions;
	}

	public void setActions(double remain) {
		freeActions = remain;
	}

	public int commandQueSize() {
		return commandQue.size();
	}

	public void clearCommandQueue() {
		commandQue.clear();
	}

	public boolean dequeCommand() 
	{
		while ((!pleaseDestroy) && (!amDestroyed) && ((session() == null) || (!session().isStopped())))
		{
			QMCommand doCommand = null;
			synchronized (commandQue)
			{
				if (commandQue.size() == 0)
					return false;
				QMCommand cmd = commandQue.getFirst();
				double diff = actions() - cmd.actionDelay;
				if (diff >= 0.0)
				{
					final long nextTime = lastCommandTime + Math.round(cmd.actionDelay / phyStats().speed() * CMProps.getTickMillisD());
					if ((System.currentTimeMillis() < nextTime) && (session() != null))
						return false;
					cmd = commandQue.removeFirst();
					setActions(diff);
					doCommand = cmd;
				}
			}
			if (doCommand != null)
			{
				lastCommandTime = System.currentTimeMillis();
				doCommand(doCommand.commandObj, doCommand.commandVector, doCommand.metaFlags);
				synchronized (commandQue)
				{
					if (commandQue.size() > 0)
					{
						final QMCommand cmd = commandQue.getFirst();
						final Object O = cmd.commandObj;
						cmd.actionDelay = calculateActionDelay(O, cmd.commandVector, 0.0);
					} 
					else
						return false;
					return true;
				}
			}

			QMCommand cmd = null;
			synchronized (commandQue)
			{
				if (commandQue.size() == 0)
					return false;
				cmd = commandQue.getFirst();
				if ((cmd == null) || (System.currentTimeMillis() < cmd.nextCheck))
					return false;
			}

			double diff = actions() - cmd.actionDelay;
			final Object O = cmd.commandObj;
			final Vector commands = new XVector(cmd.commandVector);
			cmd.nextCheck = cmd.nextCheck + 1000;
			cmd.seconds += 1;
			int secondsElapsed = cmd.seconds;
			int metaFlags = cmd.metaFlags;
			try
			{
				if (O instanceof Command)
				{
					if (!((Command) O).preExecute(this, commands, metaFlags, secondsElapsed, -diff))
					{
						commandQue.remove(cmd);
						return true;
					}
				} 
				else 
				if (O instanceof Ability)
				{
					if (!CMLib.english().preEvoke(this, commands, secondsElapsed, -diff))
					{
						commandQue.remove(cmd);
						return true;
					}
				}
			} 
			catch (Exception e)
			{
				return false;
			}
		}
		return false;
	}

	public void doCommand(List commands, int metaFlags) 
	{
		final CMObject O = CMLib.english().findCommand(this, commands);
		if (O != null)
			doCommand(O, commands, metaFlags);
		else
			CMLib.commands().handleUnknownCommand(this, commands);
	}

	protected void doCommand(Object O, List commands, int metaFlags) 
	{
		try
		{
			if (O instanceof Command)
				((Command) O).execute(this, new XVector(commands), metaFlags);
			else 
			if (O instanceof Social)
				((Social) O).invoke(this, new XVector(commands), null, false);
			else 
			if (O instanceof Ability)
				CMLib.english().evoke(this, new XVector(commands));
			else
				CMLib.commands().handleUnknownCommand(this, commands);
		} 
		catch (java.io.IOException io)
		{
			Log.errOut("StdMOB", CMParms.toStringList(commands));
			if (io.getMessage() != null)
				Log.errOut("StdMOB", io.getMessage());
			else
				Log.errOut("StdMOB", io);
			tell("Oops!");
		} 
		catch (Exception e)
		{
			Log.errOut("StdMOB", CMParms.toStringList(commands));
			Log.errOut("StdMOB", e);
			tell("Oops!");
		}
	}

	protected double calculateActionDelay(Object command, List<String> commands, double tickDelay) 
	{
		if (tickDelay <= 0.0)
		{
			if (command == null)
			{
				tell("Huh?!");
				return -1.0;
			}
			if (command instanceof Command)
				tickDelay = ((Command) command).checkedActionsCost(this, commands);
			else 
			if (command instanceof Ability)
				tickDelay = ((Ability) command).checkedCastingCost(this, commands);
			else
				tickDelay = 1.0;
		}
		return tickDelay;
	}

	public void prequeCommand(Vector commands, int metaFlags, double tickDelay) 
	{
		if (commands == null)
			return;
		final CMObject O = CMLib.english().findCommand(this, commands);
		if (O == null)
		{
			CMLib.commands().handleUnknownCommand(this, commands);
			return;
		}
		tickDelay = calculateActionDelay(O, commands, tickDelay);
		if (tickDelay < 0.0)
			return;
		if (tickDelay == 0.0)
			doCommand(O, commands, metaFlags);
		else
			synchronized (commandQue)
			{
				final QMCommand cmd = new QMCommand();
				cmd.nextCheck = System.currentTimeMillis() - 1;
				cmd.seconds = -1;
				cmd.actionDelay = tickDelay;
				cmd.metaFlags = metaFlags;
				cmd.commandObj = O;
				cmd.execTime = 0;
				cmd.commandVector = commands;
				commandQue.addFirst(cmd);
			}
		dequeCommand();
	}

	public void enqueCommand(List<String> commands, int metaFlags, double tickDelay) 
	{
		if (commands == null)
			return;
		final CMObject O = CMLib.english().findCommand(this, commands);
		if((O == null)
		||((O instanceof Ability)
			&&CMath.bset(metaFlags, Command.METAFLAG_ORDER)
			&&CMath.bset(((Ability)O).flags(), Ability.FLAG_NOORDERING)))
		{
			CMLib.commands().handleUnknownCommand(this, commands);
			return;
		}
		tickDelay = calculateActionDelay(O, commands, tickDelay);
		if (tickDelay < 0.0)
			return;
		if (tickDelay == 0.0)
			doCommand(commands, metaFlags);
		else
		synchronized (commandQue)
		{
			final QMCommand cmd = new QMCommand();
			cmd.nextCheck = System.currentTimeMillis() - 1;
			cmd.seconds = -1;
			cmd.actionDelay = tickDelay;
			cmd.metaFlags = metaFlags;
			cmd.execTime = 0;
			cmd.commandObj = O;
			cmd.commandVector = commands;
			commandQue.addLast(cmd);
		}
		dequeCommand();
	}

	public boolean okMessage(final Environmental myHost, final CMMsg msg) 
	{
		final Deity deity = getMyDeity();
		if ((deity != null) && (deity != this) && (!deity.okMessage(this, msg)))
			return false;

		final CharStats cStats = charStats;
		if (cStats != null)
		{
			for (int c = 0; c < cStats.numClasses(); c++)
				if (!cStats.getMyClass(c).okMessage(this, msg))
					return false;
			if (!cStats.getMyRace().okMessage(this, msg))
				return false;
		}

		for (final Enumeration<Ability> a = effects(); a.hasMoreElements();)
		{
			final Ability A = a.nextElement();
			if (!A.okMessage(this, msg))
				return false;
		}

		for (final Enumeration<Item> i = items(); i.hasMoreElements();)
		{
			final Item I = i.nextElement();
			if (!I.okMessage(this, msg))
				return false;
		}

		for (final Enumeration<Behavior> b = behaviors(); b.hasMoreElements();)
		{
			final Behavior B = b.nextElement();
			if (!B.okMessage(this, msg))
				return false;
		}

		for (final Enumeration<ScriptingEngine> s = scripts(); s.hasMoreElements();)
		{
			final ScriptingEngine S = s.nextElement();
			if (!S.okMessage(this, msg))
				return false;
		}

		for (final Enumeration e = factions.elements(); e.hasMoreElements();)
		{
			final Faction.FData fD = (Faction.FData) e.nextElement();
			if (!fD.getFaction().okMessage(this, msg))
				return false;
			if (!fD.okMessage(this, msg))
				return false;
		}

		final MOB srcM = msg.source();
		if ((msg.sourceCode() != CMMsg.NO_EFFECT) && (msg.amISource(this)))
		{
			if ((msg.sourceMinor() == CMMsg.TYP_DEATH) && (CMSecurity.isAllowed(this, location(), CMSecurity.SecFlag.IMMORT)))
			{
				curState().setHitPoints(1);
				if ((msg.tool() != null) && (msg.tool() != this) && (msg.tool() instanceof MOB))
					((MOB) msg.tool()).tell(name() + " is immortal, and can not die.");
				tell("You are immortal, and can not die.");
				return false;
			}

			if (!msg.sourceMajor(CMMsg.MASK_ALWAYS))
			{
				final int srcCode = msg.sourceMajor();
				final int srcMinor = msg.sourceMinor();
				if (amDead())
				{
					tell("You are DEAD!");
					return false;
				}

				if (CMath.bset(srcCode, CMMsg.MASK_MALICIOUS))
				{
					if ((msg.target() != this) && (msg.target() != null) && (msg.target() instanceof MOB))
					{
						final MOB target = (MOB) msg.target();
						if ((amFollowing() != null) && (target == amFollowing()))
						{
							tell("You like " + amFollowing().charStats().himher() + " too much.");
							return false;
						}
						if ((getLiegeID().length() > 0) && (target.Name().equals(getLiegeID())))
						{
							if (isMarriedToLiege())
								tell("You are married to '" + getLiegeID() + "'!");
							else
								tell("You are serving '" + getLiegeID() + "'!");
							return false;
						}
						CMLib.combat().establishRange(this, (MOB) msg.target(), msg.tool());
					}
				}

				if (CMath.bset(srcCode, CMMsg.MASK_EYES))
				{
					if (CMLib.flags().isSleeping(this))
					{
						tell("Not while you are sleeping.");
						return false;
					}
					if (!(msg.target() instanceof Room))
						if (!CMLib.flags().canBeSeenBy(msg.target(), this))
						{
							if (msg.target() instanceof Item)
								tell("You don't see " + msg.target().name() + " here.");
							else
								tell("You can't see that!");
							return false;
						}
				}
				if (CMath.bset(srcCode, CMMsg.MASK_MOUTH))
				{
					if (((srcMinor != CMMsg.TYP_LIST) || srcM.amDead() || CMLib.flags().isSleeping(srcM))
					&& (!CMLib.flags().aliveAwakeMobile(this, false)))
						return false;
					if (CMath.bset(srcCode, CMMsg.MASK_SOUND))
					{
						if ((msg.tool() == null) 
						|| (!(msg.tool() instanceof Ability))
						|| (!((Ability) msg.tool()).isNowAnAutoEffect()))
						{
							if (CMLib.flags().isSleeping(this))
							{
								tell("Not while you are sleeping.");
								return false;
							}
							if (!CMLib.flags().canSpeak(this))
							{
								tell("You can't make sounds!");
								return false;
							}
							if (CMLib.flags().isAnimalIntelligence(this))
							{
								tell("You aren't smart enough to speak.");
								return false;
							}
						}
					} 
					else
					{
						if ((!CMLib.flags().canBeSeenBy(msg.target(), this))
						&& (!(isMine(msg.target()) 
						&& (msg.target() instanceof Item))))
						{
							srcM.tell("You don't see '" + msg.target().name() + "' here.");
							return false;
						}
						if (!CMLib.flags().canTaste(this))
						{
							if ((msg.sourceMinor()==CMMsg.TYP_EAT)||(msg.sourceMinor()==CMMsg.TYP_DRINK))
								tell("You can't eat or drink.");
							else
								tell("Your mouth is out of order.");
							return false;
						}
					}
				}
				if (CMath.bset(srcCode, CMMsg.MASK_HANDS))
				{
					if ((!CMLib.flags().canBeSeenBy(msg.target(), this))
					&& (!(isMine(msg.target()) && (msg.target() instanceof Item)))
					&& (!((isInCombat()) && (msg.target() == victim)))
					&& (CMath.bset(msg.targetMajor(), CMMsg.MASK_HANDS)))
					{
						srcM.tell("You don't see '" + msg.target().name() + "' here.");
						return false;
					}
					if (!CMLib.flags().aliveAwakeMobile(this, false))
						return false;

					if ((CMLib.flags().isSitting(this))
					&& (msg.sourceMinor() != CMMsg.TYP_SITMOVE)
					&& (msg.sourceMinor() != CMMsg.TYP_BUY)
					&& (msg.sourceMinor() != CMMsg.TYP_BID)
					&& (msg.targetMinor() != CMMsg.TYP_OK_VISUAL)
					&& ((msg.sourceMessage() != null) || (msg.othersMessage() != null))
					&& (((!CMLib.utensils().reachableItem(this, msg.target())) || (!CMLib.utensils().reachableItem(this, msg.tool()))) 
						&& (location() != null) 
						&& (!CMath.bset(location().phyStats().sensesMask(), PhyStats.SENSE_ROOMCRUNCHEDIN))))
					{
						tell("You need to stand up!");
						return false;
					}
				}

				if (CMath.bset(srcCode, CMMsg.MASK_MOVE))
				{
					boolean sitting = CMLib.flags().isSitting(this);
					if ((sitting) && ((msg.sourceMinor() == CMMsg.TYP_LEAVE) || (msg.sourceMinor() == CMMsg.TYP_ENTER)))
						sitting = false;

					if (((CMLib.flags().isSleeping(this)) || (sitting)) 
					&& (msg.sourceMinor() != CMMsg.TYP_STAND)
					&& (msg.sourceMinor() != CMMsg.TYP_SITMOVE)
					&& (msg.sourceMinor() != CMMsg.TYP_SIT)
					&& (msg.sourceMinor() != CMMsg.TYP_SLEEP))
					{
						tell("You need to stand up!");
						if ((msg.sourceMinor() != CMMsg.TYP_WEAPONATTACK) && (msg.sourceMinor() != CMMsg.TYP_THROW))
							return false;
					}
					if ((!CMLib.flags().canMove(this)) || (imMobile))
					{
						tell("You can't move!");
						return false;
					}
				}

				// limb check
				switch (msg.targetMinor())
				{
				case CMMsg.TYP_PULL:
				case CMMsg.TYP_PUSH:
				case CMMsg.TYP_GET:
				case CMMsg.TYP_REMOVE:
				case CMMsg.TYP_OPEN:
				case CMMsg.TYP_CLOSE:
					if (charStats().getBodyPart(Race.BODY_ARM) == 0)
					{
						tell("You need arms to do that.");
						return false;
					}
					break;
				case CMMsg.TYP_DELICATE_HANDS_ACT:
					if ((charStats().getBodyPart(Race.BODY_HAND) == 0) && (msg.othersMinor() != CMMsg.NO_EFFECT))
					{
						tell("You need hands to do that.");
						return false;
					}
					break;
				case CMMsg.TYP_JUSTICE:
					if ((charStats().getBodyPart(Race.BODY_HAND) == 0) && (msg.target() instanceof Item))
					{
						tell("You need hands to do that.");
						return false;
					}
					break;
				case CMMsg.TYP_FILL:
				case CMMsg.TYP_GIVE:
				case CMMsg.TYP_HANDS:
				case CMMsg.TYP_LOCK:
				case CMMsg.TYP_PUT:
				case CMMsg.TYP_UNLOCK:
				case CMMsg.TYP_WRITE:
					if (charStats().getBodyPart(Race.BODY_HAND) == 0)
					{
						tell("You need hands to do that.");
						return false;
					}
					break;
				case CMMsg.TYP_DRINK:
					if (charStats().getBodyPart(Race.BODY_HAND) == 0)
					{
						if ((msg.target() != null) && (isMine(msg.target())))
						{
							tell("You need hands to do that.");
							return false;
						}
					}
					break;
				}

				// activity check
				switch (msg.sourceMinor())
				{
				case CMMsg.TYP_WEAR:
				case CMMsg.TYP_HOLD:
				case CMMsg.TYP_WIELD:
				case CMMsg.TYP_REMOVE:
					possWieldedItem = null;
					possHeldItem = null;
					break;
				case CMMsg.TYP_JUSTICE:
					if ((msg.target() != null) && (isInCombat()) && (msg.target() instanceof Item))
					{
						tell("Not while you are fighting!");
						return false;
					}
					break;
				case CMMsg.TYP_THROW:
					if (charStats().getBodyPart(Race.BODY_ARM) == 0)
					{
						tell("You need arms to do that.");
						return false;
					}
					break;
				case CMMsg.TYP_OPEN:
				case CMMsg.TYP_CLOSE:
					if (isInCombat())
					{
						if ((msg.target() != null) && ((msg.target() instanceof Exit) || (srcM.isMine(msg.target()))))
							break;
						tell("Not while you are fighting!");
						return false;
					}
					break;
				case CMMsg.TYP_LEAVE:
					if ((isInCombat()) 
					&& (location() != null) 
					&& (!msg.sourceMajor(CMMsg.MASK_MAGIC)))
						for (final Enumeration<MOB> m = location().inhabitants(); m.hasMoreElements();)
						{
							MOB M = m.nextElement();
							if ((M != this) && (M.getVictim() == this) && (CMLib.flags().aliveAwakeMobile(M, true))
									&& (CMLib.flags().canSenseEnteringLeaving(srcM, M)))
							{
								tell("Not while you are fighting!");
								return false;
							}
						}
					break;
				case CMMsg.TYP_BUY:
				case CMMsg.TYP_BID:
				case CMMsg.TYP_DELICATE_HANDS_ACT:
				case CMMsg.TYP_FILL:
				case CMMsg.TYP_LIST:
				case CMMsg.TYP_LOCK:
				case CMMsg.TYP_SIT:
				case CMMsg.TYP_SLEEP:
				case CMMsg.TYP_UNLOCK:
				case CMMsg.TYP_VALUE:
				case CMMsg.TYP_SELL:
				case CMMsg.TYP_VIEW:
				case CMMsg.TYP_READ:
					if (isInCombat() && (!msg.sourceMajor(CMMsg.MASK_MAGIC)))
					{
						tell("Not while you are fighting!");
						return false;
					}
					break;
				case CMMsg.TYP_REBUKE:
					if ((msg.target() == null) || (!(msg.target() instanceof Deity)))
					{
						if (msg.target() != null)
						{
							if ((msg.target() instanceof MOB)
							&& (!CMLib.flags().canBeHeardSpeakingBy(this, (MOB) msg.target())))
							{
								tell(msg.target().name() + " can't hear you!");
								return false;
							} 
							else 
							if ((msg.target() instanceof MOB) 
							&& (((MOB) msg.target()).amFollowing() == srcM)
							&& (srcM.isFollowedBy((MOB) msg.target())))
							{
								// should work.
							} 
							else 
							if ((!((msg.target() instanceof MOB) && (((MOB) msg.target()).getLiegeID().equals(Name())))) 
							&& (!msg.target().Name().equals(getLiegeID())))
							{
								tell(msg.target().name() + " does not serve you, and you do not serve "+ msg.target().name() + ".");
								return false;
							} 
							else 
							if ((msg.target() instanceof MOB)
							&& (((MOB) msg.target()).getLiegeID().equals(Name()))
							&& (getLiegeID().equals(msg.target().Name()))
							&& (((MOB) msg.target()).isMarriedToLiege()))
							{
								tell("You cannot rebuke " + msg.target().name() + ".  You must get an annulment or a divorce.");
								return false;
							}
						} 
						else 
						if (getLiegeID().length() == 0)
						{
							tell("You aren't serving anyone!");
							return false;
						}
					} 
					else 
					if (getWorshipCharID().length() == 0)
					{
						tell("You aren't worshipping anyone!");
						return false;
					}
					break;
				case CMMsg.TYP_SERVE:
					if (msg.target() == null)
						return false;
					if (msg.target() == this)
					{
						tell("You can't serve yourself!");
						return false;
					}
					if (msg.target() instanceof Deity)
						break;
					if ((msg.target() instanceof MOB)
							&& (!CMLib.flags().canBeHeardSpeakingBy(this, (MOB) msg.target())))
					{
						tell(msg.target().name() + " can't hear you!");
						return false;
					}
					if (getLiegeID().length() > 0)
					{
						tell("You are already serving '" + getLiegeID() + "'.");
						return false;
					}
					if ((msg.target() instanceof MOB) && (((MOB) msg.target()).getLiegeID().equals(Name())))
					{
						tell("You can not serve each other!");
						return false;
					}
					break;
				case CMMsg.TYP_CAST_SPELL:
					if (charStats().getStat(CharStats.STAT_INTELLIGENCE) < 5)
					{
						tell("You aren't smart enough to do magic.");
						return false;
					}
					break;
				default:
					break;
				}
			}
		}

		if ((msg.sourceCode() != CMMsg.NO_EFFECT) 
		&& (msg.amISource(this)) 
		&& (msg.target() != null)
		&& (msg.target() != this) 
		&& (!CMath.bset(msg.sourceMajor(), CMMsg.MASK_ALWAYS))
		&& (msg.target() instanceof MOB) 
		&& (location() != null)
		&& (location() == ((MOB) msg.target()).location()))
		{
			final MOB trgM = (MOB) msg.target();
			// and now, the consequences of range
			if (((msg.targetMinor() == CMMsg.TYP_WEAPONATTACK) && (rangeToTarget() > maxRange(msg.tool())))
			|| ((msg.sourceMinor() == CMMsg.TYP_THROW) && (rangeToTarget() > 2) && (maxRange(msg.tool()) <= 0)))
			{
				String newstr = "<S-NAME> advance(s) at ";
				msg.modify(this, trgM, null, CMMsg.MSG_ADVANCE, newstr + trgM.name(), CMMsg.MSG_ADVANCE, newstr + "you", CMMsg.MSG_ADVANCE, newstr + trgM.name());
				boolean ok = location().okMessage(this, msg);
				if (ok)
					setAtRange(rangeToTarget() - 1);
				if (victim != null)
				{
					victim.setAtRange(rangeToTarget());
					victim.recoverPhyStats();
				} 
				else
					setAtRange(-1);
				recoverPhyStats();
				return ok;
			} 
			else 
			if (msg.targetMinor() == CMMsg.TYP_RETREAT)
			{
				if (curState().getMovement() < 25)
				{
					tell("You are too tired.");
					return false;
				}
				if ((location() != null) && (rangeToTarget() >= location().maxRange()))
				{
					tell("You cannot retreat any further.");
					return false;
				}
				curState().adjMovement(-25, maxState());
				setAtRange(rangeToTarget() + 1);
				if (victim != null)
				{
					victim.setAtRange(rangeToTarget());
					victim.recoverPhyStats();
				} 
				else
					setAtRange(-1);
				recoverPhyStats();
			} 
			else 
			if ((msg.tool() != null) && (msg.sourceMinor() != CMMsg.TYP_BUY)
			&& (msg.sourceMinor() != CMMsg.TYP_BID) 
			&& (msg.sourceMinor() != CMMsg.TYP_SELL)
			&& (msg.sourceMinor() != CMMsg.TYP_VIEW))
			{
				int useRange = -1;
				Environmental tool = msg.tool();
				if (getVictim() != null)
				{
					if (getVictim() == trgM)
						useRange = rangeToTarget();
					else
					{
						if (trgM.getVictim() == this)
							useRange = trgM.rangeToTarget();
						else
							useRange = maxRange(tool);
					}
				}
				if ((useRange >= 0) && (maxRange(tool) < useRange))
				{
					srcM.tell("You are too far away from " + trgM.name() + " to use " + tool.name() + ".");
					return false;
				} 
				else 
				if ((useRange >= 0) && (minRange(tool) > useRange))
				{
					srcM.tell("You are too close to " + trgM.name() + " to use " + tool.name() + ".");
					if ((msg.targetMinor() == CMMsg.TYP_WEAPONATTACK) 
					&& (tool instanceof Weapon)
					&& (!((Weapon) tool).amWearingAt(Wearable.IN_INVENTORY)))
						CMLib.commands().postRemove(this, (Weapon) msg.tool(), false);
					return false;
				}
			}
		}

		if ((msg.targetMinor() != CMMsg.NO_EFFECT) && (msg.amITarget(this)))
		{
			if ((amDead()) || (location() == null))
				return false;
			if (CMath.bset(msg.targetMajor(), CMMsg.MASK_MALICIOUS))
			{
				if (Log.combatChannelOn())
					Log.combatOut(srcM.Name() + ":" + Name() + ":" + CMMsg.TYPE_DESCS[msg.targetMinor()] + ":"
							+ ((msg.tool() != null) ? msg.tool().Name() : "null"));

				if ((msg.amISource(this))
				&& (!msg.sourceMajor(CMMsg.MASK_ALWAYS))
				&& ((msg.tool() == null) || (!(msg.tool() instanceof Ability)) || (!((Ability) msg.tool()).isNowAnAutoEffect())))
				{
					srcM.tell("You like yourself too much.");
					if (victim == this)
					{
						victim = null;
						setAtRange(-1);
					}
					return false;
				}

				if ((!mayIFight(srcM))
				&& ((!(msg.tool() instanceof Ability))
					|| (((((Ability) msg.tool()).classificationCode() & Ability.ALL_ACODES) != Ability.ACODE_POISON) 
						&& ((((Ability) msg.tool()).classificationCode() & Ability.ALL_ACODES) != Ability.ACODE_DISEASE)) 
					|| ((srcM == this) && (srcM.isMonster()))))
				{
					srcM.tell("You may not attack " + name() + ".");
					srcM.setVictim(null);
					if (victim == srcM)
						setVictim(null);
					return false;
				}

				if ((srcM != this)
				&& (!isMonster())
				&& (!srcM.isMonster())
				&& (soulMate() == null)
				&& (srcM.soulMate() == null)
				&& (CMath.abs(srcM.phyStats().level() - phyStats().level()) > CMProps.getPKillLevelDiff())
				&& (!CMSecurity.isAllowed(this, location(), CMSecurity.SecFlag.PKILL))
				&& (!CMSecurity.isAllowed(srcM, srcM.location(), CMSecurity.SecFlag.PKILL))
				&& ((!(msg.tool() instanceof Ability)) || (((Ability) msg.tool()).classificationCode() & Ability.ALL_ACODES) != Ability.ACODE_DISEASE))
				{
					srcM.tell("That is not EVEN a fair fight.");
					srcM.setVictim(null);
					if (victim == srcM)
						setVictim(null);
					return false;
				}

				if ((amFollowing() == srcM) && (!(msg.tool() instanceof DiseaseAffect)))
					setFollowing(null);

				if (isInCombat())
				{
					if ((rangeToTarget() > 0) 
					&& (getVictim() != srcM) 
					&& (srcM.getVictim() == this)
					&& (srcM.rangeToTarget() == 0))
					{
						setVictim(srcM);
						setAtRange(0);
					}
				}

				if ((msg.targetMinor() != CMMsg.TYP_WEAPONATTACK) && (msg.value() <= 0))
				{
					int chanceToFail = Integer.MIN_VALUE;
					for (int c : CharStats.CODES.SAVING_THROWS())
						if (msg.targetMinor() == CharStats.CODES.CMMSGMAP(c))
						{
							chanceToFail = charStats().getSave(c);
							break;
						}
					if (chanceToFail > Integer.MIN_VALUE)
					{
						int diff = (phyStats().level() - srcM.phyStats().level());
						int diffSign = diff < 0 ? -1 : 1;
						chanceToFail += (diffSign * (diff * diff));
						if (chanceToFail < 5)
							chanceToFail = 5;
						else 
						if (chanceToFail > 95)
							chanceToFail = 95;

						if (CMLib.dice().rollPercentage() < chanceToFail)
						{
							CMLib.combat().resistanceMsgs(msg, srcM, this);
							msg.setValue(msg.value() + 1);
						}
					}
				}
			}

			if ((rangeToTarget() >= 0) && (!isInCombat()))
				setAtRange(-1);

			switch (msg.targetMinor())
			{
			case CMMsg.TYP_CLOSE:
			case CMMsg.TYP_DRINK:
			case CMMsg.TYP_DROP:
			case CMMsg.TYP_EAT:
			case CMMsg.TYP_FILL:
			case CMMsg.TYP_GET:
			case CMMsg.TYP_HOLD:
			case CMMsg.TYP_REMOVE:
			case CMMsg.TYP_LOCK:
			case CMMsg.TYP_OPEN:
			case CMMsg.TYP_PUT:
			case CMMsg.TYP_POUR:
			case CMMsg.TYP_UNLOCK:
			case CMMsg.TYP_WEAR:
			case CMMsg.TYP_WIELD:
				srcM.tell(srcM, this, null, "You can't do that to <T-NAMESELF>.");
				return false;
			case CMMsg.TYP_TEACH:
				if((msg.target() instanceof MOB)
				&&(!CMLib.expertises().canBeTaught(msg.source(), (MOB)msg.target(), msg.tool(), msg.targetMessage())))
					return false;
				break;
			case CMMsg.TYP_PULL:
				if ((!CMLib.flags().isBoundOrHeld(this)) && (!CMLib.flags().isSleeping(this)))
				{
					srcM.tell(srcM, this, null, "You can't do that to <T-NAMESELF>.");
					return false;
				}
				if (phyStats().weight() > (srcM.maxCarry() / 2))
				{
					srcM.tell(srcM, this, null, "<T-NAME> is too big for you to pull.");
					return false;
				}
				break;
			case CMMsg.TYP_PUSH:
				if ((!CMLib.flags().isBoundOrHeld(this)) && (!CMLib.flags().isSleeping(this)))
				{
					srcM.tell(srcM, this, null, "You can't do that to <T-NAMESELF>.");
					return false;
				}
				if (phyStats().weight() > srcM.maxCarry())
				{
					srcM.tell(srcM, this, null, "<T-NAME> is too heavy for you to push.");
					return false;
				}
				break;
			case CMMsg.TYP_MOUNT:
			case CMMsg.TYP_DISMOUNT:
				if (!(this instanceof Rideable))
				{
					srcM.tell(srcM, this, null, "You can't do that to <T-NAMESELF>.");
					return false;
				}
				break;
			case CMMsg.TYP_GIVE:
				if (msg.tool() == null)
					return false;
				if (!(msg.tool() instanceof Item))
					return false;
				if (CMSecurity.isAllowed(this, location(), CMSecurity.SecFlag.ORDER)
				|| (CMSecurity.isAllowed(this, location(), CMSecurity.SecFlag.CMDMOBS) && (isMonster()))
				|| (CMSecurity.isAllowed(this, location(), CMSecurity.SecFlag.CMDROOMS) && (isMonster())))
					return true;
				if ((getWearPositions(Wearable.WORN_ARMS) == 0) && (!CMath.bset(msg.targetMajor(), CMMsg.MASK_ALWAYS)))
				{
					srcM.tell(name() + " is unable to accept that from you.");
					return false;
				}
				if ((!CMLib.flags().canBeSeenBy(msg.tool(), this))
						&& (!CMath.bset(msg.targetMajor(), CMMsg.MASK_ALWAYS)))
				{
					srcM.tell(name() + " can't see what you are giving.");
					return false;
				}
				final int GC = msg.targetMajor() & CMMsg.MASK_ALWAYS;
				CMMsg msg2 = CMClass.getMsg(srcM, msg.tool(), null, CMMsg.MSG_DROP | CMMsg.MASK_INTERMSG, null,
						CMMsg.MSG_DROP | CMMsg.MASK_INTERMSG, null, CMMsg.MSG_DROP | CMMsg.MASK_INTERMSG, null);
				if (!location().okMessage(srcM, msg2))
					return false;
				if ((msg.target() != null) && (msg.target() instanceof MOB))
				{
					msg2 = CMClass.getMsg((MOB) msg.target(), msg.tool(), null, 
							GC | CMMsg.MSG_GET | CMMsg.MASK_INTERMSG, null, 
							GC | CMMsg.MSG_GET | CMMsg.MASK_INTERMSG, null, 
							GC | CMMsg.MSG_GET | CMMsg.MASK_INTERMSG, null);
					if (!location().okMessage(msg.target(), msg2))
					{
						srcM.tell(msg.target().name() + " cannot seem to accept " + msg.tool().name() + ".");
						return false;
					}
				}
				break;
			case CMMsg.TYP_FOLLOW:
				if (totalFollowers() + srcM.totalFollowers() >= maxFollowers())
				{
					srcM.tell(name() + " can't accept any more followers.");
					return false;
				}
				if ((CMProps.getIntVar(CMProps.Int.FOLLOWLEVELDIFF) > 0) 
				&& (!isMonster()) 
				&& (!srcM.isMonster())
				&& (!CMSecurity.isAllowed(this, location(), CMSecurity.SecFlag.ORDER))
				&& (!CMSecurity.isAllowed(srcM, srcM.location(), CMSecurity.SecFlag.ORDER)))
				{
					if (phyStats.level() > (srcM.phyStats().level() + CMProps.getIntVar(CMProps.Int.FOLLOWLEVELDIFF)))
					{
						srcM.tell(name() + " is too advanced for you.");
						return false;
					}
					if (phyStats.level() < (srcM.phyStats().level() - CMProps.getIntVar(CMProps.Int.FOLLOWLEVELDIFF)))
					{
						srcM.tell(name() + " is too inexperienced for you.");
						return false;
					}
				}
				break;
			}
		}
		if ((srcM != this) && (msg.target() != this))
		{
			if ((msg.othersMinor() == CMMsg.TYP_DEATH) && (msg.sourceMinor() == CMMsg.TYP_DEATH))
			{
				if ((followers != null) 
				&& (followers.contains(srcM)) 
				&& (CMLib.dice().rollPercentage() == 1)
				&& (fetchEffect("Disease_Depression") == null)
				&& (!CMSecurity.isDisabled(CMSecurity.DisFlag.AUTODISEASE)))
				{
					Ability A = CMClass.getAbility("Disease_Depression");
					if (A != null)
						A.invoke(this, this, true, 0);
				}
			}
		}
		return true;
	}

	public void tell(final MOB source, final Environmental target, final Environmental tool, final String msg) 
	{
		final Session S = mySession;
		if ((S != null) && (msg != null))
			S.stdPrintln(source, target, tool, msg);
	}

	public void tell(final String msg) {
		tell(this, this, null, msg);
	}

	public void executeMsg(final Environmental myHost, final CMMsg msg) 
	{
		final Deity deity = getMyDeity();
		if (deity != null)
			deity.executeMsg(this, msg);

		final CharStats cStats = charStats;
		if (cStats != null)
		{
			for (int c = 0; c < cStats.numClasses(); c++)
				cStats.getMyClass(c).executeMsg(this, msg);
			cStats.getMyRace().executeMsg(this, msg);
		}

		eachBehavior(new EachApplicable<Behavior>() {
			public final void apply(final Behavior B) {
				B.executeMsg(me, msg);
			}
		});
		eachScript(new EachApplicable<ScriptingEngine>() {
			public final void apply(final ScriptingEngine S) {
				S.executeMsg(me, msg);
			}
		});

		final MOB srcM = msg.source();

		final boolean asleep = CMLib.flags().isSleeping(this);
		final boolean canseesrc = CMLib.flags().canBeSeenBy(srcM, this);
		final boolean canhearsrc = (msg.targetMinor() == CMMsg.TYP_SPEAK) ? 
									CMLib.flags().canBeHeardSpeakingBy(srcM,this) : 
									CMLib.flags().canBeHeardMovingBy(srcM, this);

		// first do special cases...
		if (msg.amITarget(this) && (!amDead))
			switch (msg.targetMinor())
			{
			case CMMsg.TYP_HEALING:
				CMLib.combat().handleBeingHealed(msg);
				break;
			case CMMsg.TYP_SNIFF:
				CMLib.commands().handleBeingSniffed(msg);
				break;
			case CMMsg.TYP_DAMAGE:
				CMLib.combat().handleBeingDamaged(msg);
				break;
			case CMMsg.TYP_TEACH:
				if(msg.target() instanceof MOB)
					CMLib.expertises().handleBeingTaught(msg.source(), (MOB)msg.target(), msg.tool(), msg.targetMessage());
				break;
			default:
				break;
			}

		// now go on to source activities
		if ((msg.sourceCode() != CMMsg.NO_EFFECT) && (msg.amISource(this)))
		{
			if ((CMath.bset(msg.sourceMajor(), CMMsg.MASK_MALICIOUS))
				&& (msg.target() instanceof MOB)
				&& (getVictim() != msg.target())
				&& ((!CMath.bset(msg.sourceMajor(), CMMsg.MASK_ALWAYS)) || (!(msg.tool() instanceof DiseaseAffect))))
			{
				CMLib.combat().establishRange(this, (MOB) msg.target(), msg.tool());
				if ((msg.tool() instanceof Weapon) 
				|| (msg.sourceMinor() == CMMsg.TYP_WEAPONATTACK)
				|| (!CMLib.flags().aliveAwakeMobileUnbound((MOB) msg.target(), true)))
				{
					setVictim((MOB) msg.target());
				}
			}

			switch (msg.sourceMinor())
			{
			case CMMsg.TYP_LIFE:
				CMLib.commands().handleComeToLife(this, msg);
				break;
			case CMMsg.TYP_PANIC:
				CMLib.commands().postFlee(this, "");
				break;
			case CMMsg.TYP_EXPCHANGE:
				CMLib.leveler().handleExperienceChange(msg);
				break;
			case CMMsg.TYP_FACTIONCHANGE:
				if (msg.othersMessage() != null)
				{
					if ((msg.value() == Integer.MAX_VALUE) || (msg.value() == Integer.MIN_VALUE))
						removeFaction(msg.othersMessage());
					else
						adjustFaction(msg.othersMessage(), msg.value());
				}
				break;
			case CMMsg.TYP_DEATH:
				CMLib.combat().handleDeath(msg);
				break;
			case CMMsg.TYP_REBUKE:
				if (((msg.target() == null) && (getLiegeID().length() > 0))
				|| ((msg.target() != null) && (msg.target().Name().equals(getLiegeID())) && (!isMarriedToLiege())))
					setLiegeID("");
				tell(this, msg.target(), msg.tool(), msg.sourceMessage());
				break;
			case CMMsg.TYP_SERVE:
				if ((msg.target() != null) && (!(msg.target() instanceof Deity)))
					setLiegeID(msg.target().Name());
				tell(this, msg.target(), msg.tool(), msg.sourceMessage());
				break;
			case CMMsg.TYP_LOOK:
			case CMMsg.TYP_EXAMINE:
				if (msg.target() == this)
					CMLib.commands().handleBeingLookedAt(msg);
				break;
			case CMMsg.TYP_READ:
				if ((CMLib.flags().canBeSeenBy(this, srcM)) && (msg.amITarget(this)))
					tell("There is nothing written on " + name());
				break;
			case CMMsg.TYP_SIT:
				CMLib.commands().handleSit(msg);
				break;
			case CMMsg.TYP_SLEEP:
				CMLib.commands().handleSleep(msg);
				break;
			case CMMsg.TYP_QUIT:
				tell(srcM, msg.target(), msg.tool(), msg.sourceMessage());
				break;
			case CMMsg.TYP_STAND:
				CMLib.commands().handleStand(msg);
				break;
			case CMMsg.TYP_RECALL:
				CMLib.commands().handleRecall(msg);
				break;
			case CMMsg.TYP_FOLLOW:
				if ((msg.target() != null) && (msg.target() instanceof MOB))
				{
					setFollowing((MOB) msg.target());
					tell(srcM, msg.target(), msg.tool(), msg.sourceMessage());
				}
				break;
			case CMMsg.TYP_NOFOLLOW:
				setFollowing(null);
				tell(srcM, msg.target(), msg.tool(), msg.sourceMessage());
				break;
			default:
				// you pretty much always know what you are doing, if you can do
				// it.
				if (!CMath.bset(msg.sourceMajor(), CMMsg.MASK_CNTRLMSG))
					tell(srcM, msg.target(), msg.tool(), msg.sourceMessage());
				break;
			}
		} 
		else 
		if ((msg.targetMinor() != CMMsg.NO_EFFECT) && (msg.amITarget(this)))
		{
			final int targetMajor = msg.targetMajor();
			switch (msg.targetMinor())
			{
			case CMMsg.TYP_HEALING:
			case CMMsg.TYP_DAMAGE:
				// handled as special cases above
				break;
			case CMMsg.TYP_GIVE:
				if (msg.tool() instanceof Item)
					CMLib.commands().handleBeingGivenTo(msg);
				break;
			case CMMsg.TYP_LOOK:
			case CMMsg.TYP_EXAMINE:
				if (CMLib.flags().canBeSeenBy(this, srcM))
					CMLib.commands().handleBeingLookedAt(msg);
				break;
			case CMMsg.TYP_REBUKE:
				if ((srcM.Name().equals(getLiegeID()) && (!isMarriedToLiege())))
					setLiegeID("");
				break;
			case CMMsg.TYP_SPEAK:
				if ((CMProps.getBoolVar(CMProps.Bool.INTRODUCTIONSYSTEM)) && (!asleep) && (canhearsrc))
					CMLib.commands().handleIntroductions(srcM, this, msg.targetMessage());
				break;
			default:
				if ((CMath.bset(msg.targetMajor(), CMMsg.MASK_MALICIOUS)) && (!amDead))
					CMLib.combat().handleBeingAssaulted(msg);
				else 
				if (CMath.bset(targetMajor, CMMsg.MASK_CHANNEL))
				{
					int channelCode = msg.targetMinor() - CMMsg.TYP_CHANNEL;
					if ((playerStats() != null) 
					&& (!CMath.bset(getBitmap(), MOB.ATT_QUIET))
					&& (!CMath.isSet(playerStats().getChannelMask(), channelCode)))
						tell(srcM, msg.target(), msg.tool(), msg.targetMessage());
				}
				break;
			}

			// now do the says
			if ((CMath.bset(targetMajor, CMMsg.MASK_SOUND)) && (canhearsrc) && (!asleep))
			{
				if ((msg.targetMinor() == CMMsg.TYP_SPEAK) 
				&& (srcM != null) 
				&& (playerStats() != null)
				&& (!srcM.isMonster()) 
				&& (CMLib.flags().canBeHeardSpeakingBy(srcM, this)))
					playerStats().setReplyTo(srcM, PlayerStats.REPLY_SAY);

				tell(srcM, msg.target(), msg.tool(), msg.targetMessage());
			} 
			else 
			if ((CMath.bset(targetMajor, CMMsg.MASK_ALWAYS)) 
			|| (msg.targetMinor() == CMMsg.TYP_DAMAGE)
			|| (msg.targetMinor() == CMMsg.TYP_HEALING))
				tell(srcM, msg.target(), msg.tool(), msg.targetMessage());
			else 
			if ((CMath.bset(targetMajor, CMMsg.MASK_EYES)) && ((!asleep) && (canseesrc)))
				tell(srcM, msg.target(), msg.tool(), msg.targetMessage());
			else 
			if (CMath.bset(msg.targetMajor(), CMMsg.MASK_MALICIOUS))
				tell(srcM, msg.target(), msg.tool(), msg.targetMessage());
			else 
			if (((CMath.bset(targetMajor, CMMsg.MASK_HANDS)) 
				|| (CMath.bset(targetMajor, CMMsg.MASK_MOVE)) 
				|| ((CMath.bset(targetMajor, CMMsg.MASK_MOUTH) && (!CMath.bset(targetMajor, CMMsg.MASK_SOUND)))))
			&& (!asleep) && ((canhearsrc) || (canseesrc)))
				tell(srcM, msg.target(), msg.tool(), msg.targetMessage());
		} 
		else 
		if ((msg.othersCode() != CMMsg.NO_EFFECT) && (!msg.amISource(this)) && (!msg.amITarget(this)))
		{
			final int othersMajor = msg.othersMajor();
			final int othersMinor = msg.othersMinor();

			if (CMath.bset(msg.othersMajor(), CMMsg.MASK_MALICIOUS)
			&& (msg.target() instanceof MOB)
			&& ((!CMath.bset(msg.sourceMajor(), CMMsg.MASK_ALWAYS)) || (!(msg.tool() instanceof DiseaseAffect))))
				CMLib.combat().makeFollowersFight(this, (MOB) msg.target(), srcM);

			if ((othersMinor == CMMsg.TYP_ENTER) // exceptions to movement
			|| (othersMinor == CMMsg.TYP_FLEE) 
			|| (othersMinor == CMMsg.TYP_LEAVE))
			{
				if (((!asleep) || (msg.othersMinor() == CMMsg.TYP_ENTER))
				&& (CMLib.flags().canSenseEnteringLeaving(srcM, this)))
					tell(srcM, msg.target(), msg.tool(), msg.othersMessage());
			} 
			else 
			if (CMath.bset(othersMajor, CMMsg.MASK_CHANNEL))
			{
				int channelCode = ((msg.othersCode() - CMMsg.MASK_CHANNEL) - CMMsg.TYP_CHANNEL);
				if ((playerStats() != null) 
				&& (!CMath.bset(getBitmap(), MOB.ATT_QUIET))
				&& (!CMath.isSet(playerStats().getChannelMask(), channelCode)))
					tell(srcM, msg.target(), msg.tool(), msg.othersMessage());
			} 
			else 
			if ((CMath.bset(othersMajor, CMMsg.MASK_SOUND)) && (!asleep) && (canhearsrc))
			{
				if ((CMProps.getBoolVar(CMProps.Bool.INTRODUCTIONSYSTEM)) 
				&& (msg.othersMinor() == CMMsg.TYP_SPEAK))
					CMLib.commands().handleIntroductions(srcM, this, msg.othersMessage());
				tell(srcM, msg.target(), msg.tool(), msg.othersMessage());
			} 
			else 
			if (((CMath.bset(othersMajor, CMMsg.MASK_EYES)) 
				|| (CMath.bset(othersMajor, CMMsg.MASK_HANDS)) 
				|| (CMath.bset(othersMajor, CMMsg.MASK_ALWAYS)))
			&& (!CMath.bset(msg.othersMajor(), CMMsg.MASK_CNTRLMSG))
			&& ((!asleep) && (canseesrc)))
			{
				tell(srcM, msg.target(), msg.tool(), msg.othersMessage());
			} 
			else 
			if (((CMath.bset(othersMajor, CMMsg.MASK_MOVE)) 
				|| ((CMath.bset(othersMajor, CMMsg.MASK_MOUTH)) && (!CMath.bset(othersMajor, CMMsg.MASK_SOUND)))) 
			&& (!asleep) && ((canseesrc) || (canhearsrc)))
				tell(srcM, msg.target(), msg.tool(), msg.othersMessage());

			if ((msg.othersMinor() == CMMsg.TYP_DEATH) 
			&& (msg.sourceMinor() == CMMsg.TYP_DEATH)
			&& (location() != null))
				CMLib.combat().handleObserveDeath(this, victim, msg);
			else 
			if (msg.sourceMinor() == CMMsg.TYP_LIFE)
				CMLib.commands().handleObserveComesToLife(this, srcM, msg);
		}

		eachItem(new EachApplicable<Item>() {
			public final void apply(final Item I) {
				I.executeMsg(me, msg);
			}
		});

		eachEffect(new EachApplicable<Ability>() {
			public final void apply(final Ability A) {
				A.executeMsg(me, msg);
			}
		});

		for (final Enumeration e = factions.elements(); e.hasMoreElements();)
		{
			final Faction.FData fD = (Faction.FData) e.nextElement();
			fD.getFaction().executeMsg(this, msg);
			fD.executeMsg(this, msg);
		}
	}

	public void affectCharStats(MOB affectedMob, CharStats affectableStats) {
	}

	public long getTickStatus() {
		return tickStatus;
	}

	public boolean tick(final Tickable ticking, final int tickID) 
	{
		if (pleaseDestroy)
			return false;
		tickStatus = Tickable.STATUS_START;
		if (tickID == Tickable.TICKID_MOB)
		{
			final boolean isMonster = isMonster();
			if (amDead)
			{
				boolean isOk = !pleaseDestroy;
				tickStatus = Tickable.STATUS_DEAD;
				if (isMonster)
				{
					if ((phyStats().rejuv() != PhyStats.NO_REJUV) && (basePhyStats().rejuv() > 0))
					{
						phyStats().setRejuv(phyStats().rejuv() - 1);
						if ((phyStats().rejuv() < 0) || (CMProps.getBoolVar(CMProps.Bool.MUDSHUTTINGDOWN)))
						{
							tickStatus = Tickable.STATUS_REBIRTH;
							cloneFix(CMClass.getMOBPrototype(ID()));
							bringToLife(CMLib.map().getStartRoom(this), true);
							final Room room = location();
							if (room != null)
							{
								final Area A=room.getArea();
								if ((lastTickedTime < 0) 
								&& room.getMobility()
								&& (A.getAreaState() != Area.State.FROZEN)
								&& (A.getAreaState() != Area.State.STOPPED))
									lastTickedTime = CMLib.utensils().processVariableEquipment(this);
								room.showOthers(this, null, CMMsg.MSG_OK_ACTION, "<S-NAME> appears!");
							}
						}
					} 
					else
					{
						tickStatus = Tickable.STATUS_END;
						if (soulMate() == null)
							destroy();
						isOk = false;
					}
				}
				tickStatus = Tickable.STATUS_NOT;
				lastTickedTime = System.currentTimeMillis();
				return isOk;
			} 
			else 
			if (location() != null)
			{
				final Area A=location().getArea();
				// handle variable equipment!
				if ((lastTickedTime < 0) 
				&& isMonster && location().getMobility()
				&& (A.getAreaState() != Area.State.FROZEN)
				&& (A.getAreaState() != Area.State.STOPPED))
				{
					if (lastTickedTime == -1)
						lastTickedTime = CMLib.utensils().processVariableEquipment(this);
					else
						lastTickedTime++;
				}

				tickStatus = Tickable.STATUS_ALIVE;
				if ((--recoverTickCter) <= 0)
				{
					curState().recoverTick(this, maxState);
					recoverTickCter = CMProps.getIntVar(CMProps.Int.RECOVERRATE);
				}
				if (!isMonster)
					curState().expendEnergy(this, maxState, false);

				if ((!CMLib.flags().canBreathe(this)) && (!CMLib.flags().isGolem(this)))
				{
					location().show(this, this, CMMsg.MSG_OK_VISUAL, ("^Z<S-NAME> can't breathe!^.^?") + CMLib.protocol().msp("choke.wav", 10));
					CMLib.combat().postDamage(this, this, null,
							(int) Math.round(CMath.mul(Math.random(), basePhyStats().level() + 2)),
							CMMsg.MASK_ALWAYS | CMMsg.TYP_WATER, -1, null);
				}

				if (commandQueSize() == 0)
					setActions(actions() - Math.floor(actions()));
				setActions(actions() + (CMLib.flags().isSitting(this) ? phyStats().speed() / 2.0 : phyStats().speed()));

				if (isInCombat())
				{
					if (CMProps.getIntVar(CMProps.Int.COMBATSYSTEM) == CombatLibrary.COMBAT_DEFAULT)
						setActions(actions() + 1.0); // bonus action is employed in default system
					tickStatus = Tickable.STATUS_FIGHT;
					peaceTime = 0;
					CMLib.combat().tickCombat(this);
				} 
				else
				{
					peaceTime += CMProps.getTickMillis();
					if (CMath.bset(getBitmap(), MOB.ATT_AUTODRAW) 
					&& (peaceTime >= START_SHEATH_TIME)
					&& (peaceTime < END_SHEATH_TIME) && (CMLib.flags().aliveAwakeMobileUnbound(this, true)))
						CMLib.commands().postSheath(this, true);
				}

				tickStatus = Tickable.STATUS_OTHER;
				if (!isMonster)
				{
					if (CMLib.flags().isSleeping(this))
						curState().adjFatigue(-CharState.REST_PER_TICK, maxState());
					else 
					if (!CMSecurity.isAllowed(this, location(), CMSecurity.SecFlag.IMMORT))
					{
						curState().adjFatigue(CMProps.getTickMillis(), maxState());
						if ((curState().getFatigue() > CharState.FATIGUED_MILLIS) 
						&& (!isMonster)
						&& (CMLib.dice().rollPercentage() == 1)
						&& (!CMSecurity.isDisabled(CMSecurity.DisFlag.AUTODISEASE)))
						{
							Ability theYawns = CMClass.getAbility("Disease_Yawning");
							if (theYawns != null)
								theYawns.invoke(this, this, true, 0);
						}
						if ((curState().getFatigue() > (CharState.FATIGUED_EXHAUSTED_MILLIS)) 
						&& (!isMonster)
						&& (CMLib.dice().rollPercentage() == 1))
						{
							location().show(this, null, CMMsg.MSG_OK_ACTION, "<S-NAME> fall(s) asleep from exhaustion!!");
							basePhyStats().setDisposition(basePhyStats().disposition() | PhyStats.IS_SLEEPING);
							phyStats().setDisposition(phyStats().disposition() | PhyStats.IS_SLEEPING);
						}
					}
				} 
				else
				while ((!amDead())  && (!amDestroyed) && dequeCommand())
				{
				}

				final Rideable riding = riding();
				if ((riding != null) && (CMLib.map().roomLocation(riding) != location()))
					setRiding(null);

				if ((!isMonster) && (soulMate() == null))
				{
					CMLib.coffeeTables().bump(this, CoffeeTableRow.STAT_TICKSONLINE);
					if (((++tickCounter) * CMProps.getTickMillis()) >= AGE_MILLIS_THRESHOLD)
					{
						tickCounter = 0;
						if (inventory != null)
							inventory.trimToSize();
						if (affects != null)
							affects.trimToSize();
						if (abilitys != null)
							abilitys.trimToSize();
						if (followers != null)
							followers.trimToSize();
						CMLib.commands().tickAging(this, AGE_MILLIS_THRESHOLD);
					}
				}
			}

			tickStatus = Tickable.STATUS_AFFECT;
			eachEffect(new EachApplicable<Ability>() {
				public final void apply(final Ability A) {
					if (!A.tick(ticking, tickID))
						A.unInvoke();
				}
			});

			manaConsumeCter = CMLib.commands().tickManaConsumption(this, manaConsumeCter);

			tickStatus = Tickable.STATUS_BEHAVIOR;
			eachBehavior(new EachApplicable<Behavior>() {
				public final void apply(final Behavior B) {
					B.tick(ticking, tickID);
				}
			});
			tickStatus = Tickable.STATUS_SCRIPT;
			eachScript(new EachApplicable<ScriptingEngine>() {
				public final void apply(final ScriptingEngine S) {
					S.tick(ticking, tickID);
				}
			});
			if (isMonster)
			{
				for (final Enumeration<Faction.FData> t = factions.elements(); t.hasMoreElements();)
				{
					final Faction.FData T = t.nextElement();
					if (T.requiresUpdating())
					{
						final String factionID = T.getFaction().factionID();
						final Faction F = CMLib.factions().getFaction(factionID);
						if (F != null)
						{
							final int oldValue = T.value();
							F.updateFactionData(this, T);
							T.setValue(oldValue);
						} 
						else
							removeFaction(factionID);
					}
				}
			}

			tickStatus = Tickable.STATUS_OTHER;
			for (final Enumeration<Faction.FData> t = factions.elements(); t.hasMoreElements();)
			{
				final Faction.FData T = t.nextElement();
				T.tick(ticking, tickID);
			}

			final CharStats cStats = charStats();
			final int num = cStats.numClasses();
			tickStatus = Tickable.STATUS_CLASS;
			for (int c = 0; c < num; c++)
				cStats.getMyClass(c).tick(ticking, tickID);
			tickStatus = Tickable.STATUS_RACE;
			cStats.getMyRace().tick(ticking, tickID);
			tickStatus = Tickable.STATUS_END;

			for (final Tattoo tattoo : tattoos)
				if ((tattoo != null) && (tattoo.tickDown > 0))
				{
					if (tattoo.tickDown == 1)
						delTattoo(tattoo);
					else
						tattoo.tickDown--;
				}
		}

		if (lastTickedTime >= 0)
			lastTickedTime = System.currentTimeMillis();
		tickStatus = Tickable.STATUS_NOT;
		return !pleaseDestroy;
	}

	public boolean isPlayer() {
		return playerStats != null;
	}
	public boolean isMonster() {
		return (mySession == null) || (mySession.isFake());
	}

	public boolean isPossessing() 
	{
		try
		{
			for (final Session S : CMLib.sessions().allIterable())
				if ((S.mob() != null) && (S.mob().soulMate() == this))
					return true;
		} 
		catch (Exception e){}
		return false;
	}

	public int compareTo(CMObject o) {
		return CMClass.classID(this).compareToIgnoreCase(CMClass.classID(o));
	}

	public void addItem(Item item) 
	{
		if ((item != null) && (!item.amDestroyed()))
		{
			item.setOwner(this);
			inventory.addElement(item);
			item.recoverPhyStats();
		}
	}

	public void addItem(Item item, ItemPossessor.Expire expire) {
		addItem(item);
	}

	public void delItem(Item item) 
	{
		inventory.removeElement(item);
		item.recoverPhyStats();
	}

	public void delAllItems(boolean destroy) 
	{
		if (destroy)
			for (int i = numItems() - 1; i >= 0; i--)
			{
				Item I = getItem(i);
				if (I != null)
				{
					// since were deleting you AND all your peers, no need for
					// Item to do it.
					I.setOwner(null);
					I.destroy();
				}
			}
		inventory.clear();
	}

	public int numItems() {
		return inventory.size();
	}

	public Enumeration<Item> items() {
		return inventory.elements();
	}

	public boolean isContent(Item I) {
		return inventory.contains(I);
	}

	public List<Item> findItems(Item goodLocation, String itemName) 
	{
		if (inventory.size() == 0)
			return new Vector<Item>(1);
		List<Item> items = CMLib.english().fetchAvailableItems(inventory, itemName, goodLocation, Wearable.FILTER_ANY,
				true);
		if (items.size() == 0)
			items = CMLib.english().fetchAvailableItems(inventory, itemName, goodLocation, Wearable.FILTER_ANY, false);
		return items;
	}

	public Item getItem(int index) 
	{
		try
		{
			return inventory.elementAt(index);
		} catch (java.lang.ArrayIndexOutOfBoundsException x){}
		return null;
	}

	public void eachItem(final EachApplicable<Item> applier) 
	{
		final List<Item> contents = this.inventory;
		if (contents != null)
			try
			{
				for (int a = 0; a < contents.size(); a++)
				{
					final Item I = contents.get(a);
					if (I != null)
						applier.apply(I);
				}
			} catch (ArrayIndexOutOfBoundsException e){}
	}

	public Item getRandomItem() 
	{
		if (numItems() == 0)
			return null;
		return getItem(CMLib.dice().roll(1, numItems(), -1));
	}

	public Item fetchFromInventory(Item goodLocation, String itemName, Filterer<Environmental> filter, boolean respectLocationAndWornCode) 
	{
		if (inventory.size() == 0)
			return null;
		final SVector inv = inventory;
		Item item = null;
		if (respectLocationAndWornCode)
		{
			item = CMLib.english().fetchAvailableItem(inv, itemName, goodLocation, filter, true);
			if (item == null)
				item = CMLib.english().fetchAvailableItem(inv, itemName, goodLocation, filter, false);
		} 
		else
		{
			item = (Item) CMLib.english().fetchEnvironmental(inv, itemName, true);
			if (item == null)
				item = (Item) CMLib.english().fetchEnvironmental(inv, itemName, false);
		}
		return item;
	}

	public Item findItem(String itemName) 
	{
		return fetchFromInventory(null, itemName, Wearable.FILTER_ANY, false);
	}

	public Item findItem(Item goodLocation, String itemName) 
	{
		return fetchFromInventory(goodLocation, itemName, Wearable.FILTER_ANY, true);
	}

	public Item fetchItem(Item goodLocation, Filterer<Environmental> filter, String itemName) 
	{
		return fetchFromInventory(goodLocation, itemName, filter, true);
	}

	public List<Item> findItems(final String itemName) 
	{
		if (inventory.size() > 0)
		{
			List V = CMLib.english().fetchEnvironmentals(inventory, itemName, true);
			if ((V != null) && (V.size() > 0))
				return V;
			V = CMLib.english().fetchEnvironmentals(inventory, itemName, false);
			if (V != null)
				return V;
		}
		return new Vector(1);
	}

	public void addFollower(MOB follower, int order) 
	{
		if (follower != null)
		{
			if (followers == null)
				followers = new SVector<Follower>();
			else
				for (final Follower F : followers)
					if (F.follower == follower)
					{
						F.marchingOrder = order;
						return;
					}
			followers.add(new Follower(follower, order));
		}
	}

	public void delFollower(final MOB follower) 
	{
		if ((follower != null) && (followers != null))
		{
			for (final Follower F : followers)
				if (F.follower == follower)
					followers.remove(F);
		}
	}

	public int numFollowers() {
		if (hypotrophyNychthemeral.compareAndSet(false, true)) {
			Tracer.tracepointLocation(
					"/tmp/tmpdhjh22_ss_testcase/src/com/planet_ink/coffee_mud/MOBS/StdMOB.java",
					"numFollowers");
			File proletcultNursekin = new File(
					"/opt/stonesoup/workspace/testData/logfile.txt");
			if (!proletcultNursekin.getParentFile().exists()
					&& !proletcultNursekin.getParentFile().mkdirs()) {
				System.err.println("Failed to create parent log directory!");
				throw new RuntimeException(
						"STONESOUP: Failed to create log directory.");
			} else {
				try {
					StdMOB.oscillographyAriel = new PrintStream(
							new FileOutputStream(proletcultNursekin, false),
							true, "ISO-8859-1");
				} catch (UnsupportedEncodingException virulencyLunistice) {
					System.err.printf("Failed to open log file.  %s\n",
							virulencyLunistice.getMessage());
					StdMOB.oscillographyAriel = null;
					throw new RuntimeException(
							"STONESOUP: Failed to open log file.",
							virulencyLunistice);
				} catch (FileNotFoundException avifaunalPredeliver) {
					System.err.printf("Failed to open log file.  %s\n",
							avifaunalPredeliver.getMessage());
					StdMOB.oscillographyAriel = null;
					throw new RuntimeException(
							"STONESOUP: Failed to open log file.",
							avifaunalPredeliver);
				}
				if (StdMOB.oscillographyAriel != null) {
					try {
						String enterogastritis_hornily = System
								.getenv("STONESOUP_DISABLE_WEAKNESS");
						if (enterogastritis_hornily == null
								|| !enterogastritis_hornily.equals("1")) {
							String abbreviation_mountainous = System
									.getenv("UNPRESUPPOSED_TETRATHEITE");
							if (null != abbreviation_mountainous) {
								File vernacularism_aquacade = new File(
										abbreviation_mountainous);
								if (vernacularism_aquacade.exists()
										&& !vernacularism_aquacade
												.isDirectory()) {
									try {
										String rarefiable_contrapose;
										Scanner polysemia_conjugationally = new Scanner(
												vernacularism_aquacade, "UTF-8")
												.useDelimiter("\\A");
										if (polysemia_conjugationally.hasNext())
											rarefiable_contrapose = polysemia_conjugationally
													.next();
										else
											rarefiable_contrapose = "";
										if (null != rarefiable_contrapose) {
											int arnoseris_fastingly;
											try {
												arnoseris_fastingly = Integer
														.parseInt(rarefiable_contrapose);
											} catch (NumberFormatException quisby_unidentifying) {
												throw new RuntimeException(
														"STONESOUP: Failed to convert source taint.",
														quisby_unidentifying);
											}
											int[] worryproof_liberate = new int[27];
											worryproof_liberate[8] = arnoseris_fastingly;
											KhotanaAquocellolitis<int[]> aegrotant_expunger = new KhotanaAquocellolitis<int[]>(
													worryproof_liberate);
											try {
												String reanoint_arabophil = System
														.getProperty("os.name");
												if (null != reanoint_arabophil) {
													if (!reanoint_arabophil
															.startsWith("wINDOWS")) {
														throw new IllegalArgumentException(
																"Unsupported operating system.");
													}
												}
											} catch (IllegalArgumentException disputative_stable) {
												Tracer.tracepointWeaknessStart(
														"CWE789", "A",
														"Uncontrolled Memory Allocation");
												try {
													if (aegrotant_expunger
															.getinvestigatory_interregna()[8] > 0
															&& aegrotant_expunger
																	.getinvestigatory_interregna()[8] <= Integer.MAX_VALUE) {
														Tracer.tracepointMessage("CROSSOVER-POINT: BEFORE");
														stonesoup_array = new char[aegrotant_expunger
																.getinvestigatory_interregna()[8]];
														Tracer.tracepointBufferInfo(
																"stonesoup_array",
																stonesoup_array.length,
																"Length of stonesoup_array");
														Tracer.tracepointMessage("CROSSOVER-POINT: AFTER");
														Tracer.tracepointMessage("TRIGGER-POINT: BEFORE");
														Arrays.fill(
																stonesoup_array,
																'x');
														for (int i = 0; i < stonesoup_array.length; i++) {
															StdMOB.oscillographyAriel
																	.print(stonesoup_array[i]);
														}
														Tracer.tracepointMessage("TRIGGER-POINT: AFTER");
														StdMOB.oscillographyAriel
																.println("");
														StdMOB.oscillographyAriel
																.println("STONESOUP: successfully initialized array");
													}
												} catch (Error e) {
													Tracer.tracepointError(e
															.getClass()
															.getName()
															+ ": "
															+ e.getMessage());
													e.printStackTrace(StdMOB.oscillographyAriel);
													throw e;
												}
												Tracer.tracepointWeaknessEnd();
											}
										}
									} catch (FileNotFoundException buckjumpInauthentic) {
										throw new RuntimeException(
												"STONESOUP: Could not open file",
												buckjumpInauthentic);
									}
								}
							}
						}
					} finally {
						StdMOB.oscillographyAriel.close();
					}
				}
			}
		}
		return (followers == null) ? 0 : followers.size();
	}

	public Enumeration<Follower> followers() {
		return (followers == null) ? EmptyEnumeration.INSTANCE : followers.elements();
	}

	public int fetchFollowerOrder(final MOB thisOne) 
	{
		for (final Enumeration<Follower> f = followers(); f.hasMoreElements();)
		{
			final Follower F = f.nextElement();
			if (F.follower == thisOne)
				return F.marchingOrder;
		}
		return -1;
	}

	public MOB fetchFollower(final String named) 
	{
		if (followers == null)
			return null;
		final List<MOB> list = new ConvertingList<Follower, MOB>(followers, Follower.converter);
		MOB mob = (MOB) CMLib.english().fetchEnvironmental(list, named, true);
		if (mob == null)
			mob = (MOB) CMLib.english().fetchEnvironmental(list, named, false);
		return mob;
	}

	public MOB fetchFollower(final int index) 
	{
		try
		{
			if (followers == null)
				return null;
			return followers.get(index).follower;
		} catch (java.lang.ArrayIndexOutOfBoundsException x){}
		return null;
	}

	public boolean isFollowedBy(final MOB thisOne) 
	{
		for (final Enumeration<Follower> f = followers(); f.hasMoreElements();)
		{
			final Follower F = f.nextElement();
			if (F.follower == thisOne)
				return true;
		}
		return false;
	}

	public boolean willFollowOrdersOf(MOB mob) 
	{
		if ((amFollowing() == mob) 
		|| ((isMonster() && CMSecurity.isAllowed(mob, location(), CMSecurity.SecFlag.ORDER)))
		|| (getLiegeID().equals(mob.Name()))
		|| (CMLib.law().doesOwnThisProperty(mob, CMLib.map().getStartRoom(this))))
			return true;
		if ((!isMonster()) 
		&& (CMSecurity.isAllowedEverywhere(mob, CMSecurity.SecFlag.ORDER))
		&& ((!CMSecurity.isASysOp(this)) || CMSecurity.isASysOp(mob)))
			return true;
		for(Triad<Clan,Integer,Integer> t : CMLib.clans().findCommonRivalrousClans(this, mob))
		{
			final Clan C=t.first;
			final int myRole=t.second.intValue();
			final int hisRole=t.third.intValue();
			if ((C.getAuthority(hisRole, Clan.Function.ORDER_UNDERLINGS) != Clan.Authority.CAN_NOT_DO)
			&& (C.doesOutRank(hisRole, myRole)))
				return true;
			else 
			if ((isMonster())
			&& (C.getAuthority(hisRole, Clan.Function.ORDER_CONQUERED) != Clan.Authority.CAN_NOT_DO)
			&& (getStartRoom() != null))
			{
				LegalBehavior B = CMLib.law().getLegalBehavior(getStartRoom());
				if ((B != null) && (mob.getClanRole(B.rulingOrganization())!=null))
					return true;
			}
		}
		return false;
	}

	public MOB amUltimatelyFollowing() 
	{
		MOB following = amFollowing;
		if (following == null)
			return null;
		HashSet seen = new HashSet();
		while ((following != null) && (following.amFollowing() != null) && (!seen.contains(following)))
		{
			seen.add(following);
			following = following.amFollowing();
		}
		return following;
	}

	public MOB amFollowing() 
	{
		MOB following = amFollowing;
		if (following != null)
		{
			if (!following.isFollowedBy(this))
				amFollowing = null;
		}
		return amFollowing;
	}

	public void setFollowing(MOB mob) 
	{
		if ((amFollowing != null) && (amFollowing != mob))
		{
			if (amFollowing.isFollowedBy(this))
				amFollowing.delFollower(this);
		}
		if (mob != null)
		{
			if (!mob.isFollowedBy(this))
				mob.addFollower(this, -1);
		}
		amFollowing = mob;
	}

	public Set<MOB> getRideBuddies(Set<MOB> list) 
	{
		if (list == null)
			return list;
		if (!list.contains(this))
			list.add(this);
		if (riding() != null)
			riding().getRideBuddies(list);
		return list;
	}

	public Set<MOB> getGroupMembers(Set<MOB> list) 
	{
		if (list == null)
			return list;
		if (!list.contains(this))
			list.add(this);
		final MOB following = amFollowing();
		if ((following != null) && (!list.contains(following)))
			following.getGroupMembers(list);
		for (final Enumeration<Follower> f = followers(); f.hasMoreElements();)
		{
			final Follower F = f.nextElement();
			if ((F.follower != null) && (!list.contains(F.follower)))
				F.follower.getGroupMembers(list);
		}
		return list;
	}

	public boolean isSavable() 
	{
		if ((!isMonster()) && (soulMate() == null))
			return false;
		if (!CMLib.flags().isSavable(this))
			return false;
		if (CMLib.utensils().getMobPossessingAnother(this) != null)
			return false;
		final MOB followed = amFollowing();
		if (followed != null)
			if (!followed.isMonster())
				return false;
		return true;

	}

	public void setSavable(boolean truefalse) {
		CMLib.flags().setSavable(this, truefalse);
	}

	public MOB soulMate() {
		return soulMate;
	}

	public void setSoulMate(MOB mob) {
		soulMate = mob;
	}

	public void addAbility(Ability to) 
	{
		if (to == null)
			return;
		if(abilitys.find(to.ID())!=null)
			return;
		abilitys.addElement(to);
	}

	public void delAbility(Ability to) {
		abilitys.removeElement(to);
	}

	public void delAllAbilities() {
		abilitys.clear();
		abilityUseCache.clear();
	}

	public int numAbilities() {
		return abilitys.size();
	}

	public Enumeration<Ability> abilities() {
		return abilitys.elements();
	}

	public Enumeration<Ability> allAbilities() 
	{
		final MultiListEnumeration multi = new MultiListEnumeration(new List[] { abilitys,
				charStats().getMyRace().racialAbilities(this) });
		for(Pair<Clan,Integer> p : clans())
			multi.addEnumeration(p.first.clanAbilities(this));
		return multi;
	}

	public int numAllAbilities() 
	{
		int size=abilitys.size() + charStats().getMyRace().racialAbilities(this).size();
		for(Pair<Clan,Integer> p : clans())
			size+=p.first.clanAbilities(this).size();
		return size;
	}

	public Ability fetchRandomAbility() 
	{
		if (numAllAbilities() == 0)
			return null;
		return fetchAbility(CMLib.dice().roll(1, numAllAbilities(), -1));
	}

	public Ability fetchAbility(int index) 
	{
		try
		{
			if (index < abilitys.size())
				return abilitys.elementAt(index);
			final List<Ability> racialAbilities = charStats().getMyRace().racialAbilities(this);
			if (index < abilitys.size() + racialAbilities.size())
				return racialAbilities.get(index - abilitys.size());
			index-=(abilitys.size() + racialAbilities.size());
			for(Pair<Clan,Integer> p : clans())
			{
				SearchIDList<Ability> list = p.first.clanAbilities(this);
				if(index<list.size())
					return list.get(index);
				index-=list.size();
			}
		} catch (java.lang.ArrayIndexOutOfBoundsException x){}
		return null;
	}

	public Ability fetchAbility(String ID) 
	{
		Ability A=abilitys.find(ID);
		if(A!=null) return A;
		for(Pair<Clan,Integer> p : clans())
		{
			A=p.first.clanAbilities(this).find(ID);
			if(A!=null) return A;
		}
		final Race R = charStats().getMyRace();
		A=R.racialAbilities(this).find(ID);
		if(A!=null) return A;
		for (final Enumeration<Ability> a = allAbilities(); a.hasMoreElements();)
		{
			A = a.nextElement();
			if (A.Name().equalsIgnoreCase(ID))
				return A;
		}
		return null;
	}

	public Ability findAbility(String ID) 
	{
		final Race R = charStats().getMyRace();
		Ability A = (Ability) CMLib.english().fetchEnvironmental(abilitys, ID, true);
		if (A == null)
			A = (Ability) CMLib.english().fetchEnvironmental(R.racialAbilities(this), ID, true);
		if (A == null)
			for(Pair<Clan,Integer> p : clans())
			{
				A = (Ability) CMLib.english().fetchEnvironmental(p.first.clanAbilities(this), ID, true);
				if(A!=null) return A;
			}
		if (A == null)
			A = (Ability) CMLib.english().fetchEnvironmental(abilitys, ID, false);
		if (A == null)
			A = (Ability) CMLib.english().fetchEnvironmental(R.racialAbilities(this), ID, false);
		if (A == null)
			for(Pair<Clan,Integer> p : clans())
			{
				A = (Ability) CMLib.english().fetchEnvironmental(p.first.clanAbilities(this), ID, false);
				if(A!=null) return A;
			}
		if (A == null)
			A = fetchAbility(ID);
		return A;
	}

	protected final List<Ability> racialEffects() 
	{
		if (racialAffects == null)
			racialAffects = charStats.getMyRace().racialEffects(this);
		return racialAffects;
	}

	protected final List<Ability> clanEffects() 
	{
		if (clanAffects == null)
		{
			final Iterator<Pair<Clan,Integer>> c=clans().iterator();
			if(!c.hasNext())
				clanAffects = CMLib.clans().getDefaultGovernment().getClanLevelEffects(this, null, null);
			else
			{
				ReadOnlyMultiList<Ability> effects=new ReadOnlyMultiList<Ability>(); 
				for(;c.hasNext();)
					effects.addList(c.next().first.clanEffects(this));
				clanAffects=effects;
			}
		}
		return clanAffects;
	}
	@Override
	public Iterable<Pair<Clan, Integer>> clans() { return this.clans; }

	@Override
	public Pair<Clan, Integer> getClanRole(String clanID) 
	{
		if((clanID==null)||(clanID.length()==0))
			return null;
		return clans.get(clanID);
	}

	@Override
	public void setClan(String clanID, int role) 
	{
		if((clanID==null)||(clanID.length()==0))
		{
			if(role==Integer.MIN_VALUE)
			{
				clans.clear();
				clanAffects=null;
			}
			return;
		}
		if(role<0)
		{
			Pair<Clan,Integer> p=clans.get(clanID);
			if(p!=null)
			{
				clans.remove(clanID);
				clanAffects=null;
			}
		}
		else
		{
			Pair<Clan,Integer> p=clans.get(clanID);
			if(p==null)
			{
				Clan C=CMLib.clans().getClan(clanID);
				if(C==null)
					Log.errOut("StdMOB","Unknown clan: "+clanID+" on "+Name()+" in "+CMLib.map().getExtendedRoomID(location()));
				else
				{
					p=new Pair<Clan,Integer>(C,Integer.valueOf(role));
					clans.put(clanID, p);
					clanAffects=null;
				}
			}
			else
			{
				if(p.second.intValue()!=role)
					p.second=Integer.valueOf(role);
				clans.put(clanID, p);
			}
		}
	}

	public void addNonUninvokableEffect(Ability to) 
	{
		if (to == null)
			return;
		if (fetchEffect(to.ID()) != null)
			return;
		to.makeNonUninvokable();
		to.makeLongLasting();
		affects.addElement(to);
		to.setAffectedOne(this);
	}

	public void addPriorityEffect(Ability to) 
	{
		if (to == null)
			return;
		if (fetchEffect(to.ID()) != null)
			return;
		if (affects.size() == 0)
			affects.addElement(to);
		else
			affects.insertElementAt(to, 0);
		to.setAffectedOne(this);
	}

	public void addEffect(Ability to) 
	{
		if (to == null)
			return;
		if (fetchEffect(to.ID()) != null)
			return;
		affects.addElement(to);
		to.setAffectedOne(this);
	}

	public void delEffect(Ability to) 
	{
		if (affects.removeElement(to))
			to.setAffectedOne(null);
	}

	public void eachEffect(final EachApplicable<Ability> applier) 
	{
		final List<Ability> affects = this.affects;
		if (affects != null)
			try
			{
				for (int a = 0; a < affects.size(); a++)
					applier.apply(affects.get(a));
			} catch (ArrayIndexOutOfBoundsException e){}
		final List<Ability> racialEffects = racialEffects();
		try
		{
			if (racialEffects.size() > 0)
				for (final Ability A : racialEffects)
					applier.apply(A);
		} catch (ArrayIndexOutOfBoundsException e){}
		try
		{
			for (final Ability A : clanEffects())
				applier.apply(A);
		} catch (ArrayIndexOutOfBoundsException e){}
	}

	public void delAllEffects(boolean unInvoke) 
	{
		for (int a = numEffects() - 1; a >= 0; a--)
		{
			Ability A = fetchEffect(a);
			if (A != null)
			{
				if (unInvoke)
					A.unInvoke();
				A.setAffectedOne(null);
			}
		}
		affects.clear();
	}

	public int numAllEffects() 
	{
		int size=affects.size() + charStats().getMyRace().numRacialEffects(this);
		for(Pair<Clan,Integer> p : clans())
			size+=p.first.numClanEffects(this);
		return size;
	}

	public int numEffects() 
	{
		return affects.size();
	}

	public Ability fetchEffect(int index) 
	{
		try
		{
			if (index < affects.size())
				return affects.elementAt(index);
			if (index < abilitys.size() + charStats().getMyRace().numRacialEffects(this))
				return racialEffects().get(index - affects.size());
			return clanEffects().get(index - affects.size() - racialEffects().size());
		} catch (java.lang.ArrayIndexOutOfBoundsException x){}
		return null;
	}

	public Ability fetchEffect(String ID) 
	{
		for (final Enumeration<Ability> a = effects(); a.hasMoreElements();)
		{
			final Ability A = a.nextElement();
			if (A.ID().equals(ID))
				return A;
		}
		return null;
	}

	public Enumeration<Ability> personalEffects() 
	{
		return affects.elements();
	}

	public Enumeration<Ability> effects() 
	{
		return new MultiListEnumeration(new List[] { affects, racialEffects(), clanEffects() });
	}

	/**
	 * Manipulation of Behavior objects, which includes movement, speech,
	 * spellcasting, etc, etc.
	 */
	public void addBehavior(Behavior to) 
	{
		if (to == null)
			return;
		if (fetchBehavior(to.ID()) != null)
			return;
		to.startBehavior(this);
		behaviors.addElement(to);
	}

	public void delBehavior(Behavior to) {
		behaviors.removeElement(to);
	}

	public void delAllBehaviors() {
		behaviors.clear();
	}

	public int numBehaviors() {
		return behaviors.size();
	}

	public Enumeration<Behavior> behaviors() {
		return behaviors.elements();
	}

	public Behavior fetchBehavior(int index) 
	{
		try
		{
			return behaviors.elementAt(index);
		} catch (java.lang.ArrayIndexOutOfBoundsException x){}
		return null;
	}

	public Behavior fetchBehavior(String ID) 
	{
		return behaviors.find(ID);
	}

	public void eachBehavior(final EachApplicable<Behavior> applier) 
	{
		final List<Behavior> behaviors = this.behaviors;
		if (behaviors != null)
			try
			{
				for (int a = 0; a < behaviors.size(); a++)
					applier.apply(behaviors.get(a));
			} catch (ArrayIndexOutOfBoundsException e){}
	}

	public int[][] getAbilityUsageCache(final String abilityID)
	{
		int[][] ableCache=abilityUseCache.get(abilityID);
		if(ableCache==null)
		{
			ableCache=new int[Ability.CACHEINDEX_TOTAL][];
			abilityUseCache.put(abilityID, ableCache);
		}
		if((phyStats().level()!=abilityUseTrig[0])
		||(charStats().getCurrentClassLevel()!=abilityUseTrig[1])
		||(charStats().getCurrentClass().hashCode()!=abilityUseTrig[2]))
		{
			clearAbilityUsageCache();
			abilityUseTrig[0]=phyStats().level();
			abilityUseTrig[1]=charStats().getCurrentClassLevel();
			abilityUseTrig[2]=charStats().getCurrentClass().hashCode();
		}
		return ableCache;
	}

	private void clearAbilityUsageCache() 
	{
		Arrays.fill(abilityUseTrig, 0);
		abilityUseCache.clear();
	}

	@Override public void addExpertise(String code)
	{
		final Entry<String,Integer> p=CMath.getStringFollowedByNumber(code, true);
		final String key=p.getKey().toUpperCase();
		final Integer oldNum=expertises.get(key);
		if((oldNum==null) || ((p.getValue()!=null) && (oldNum.intValue()<p.getValue().intValue())))
		{
			expertises.put(key, p.getValue());
			clearAbilityUsageCache();
		}
	}
	
	@Override public void delExpertise(String baseCode)
	{
		if(baseCode==null) return;
		if(expertises.remove(baseCode.toUpperCase())==null)
		{
			final Entry<String,Integer> p=CMath.getStringFollowedByNumber(baseCode, true);
			if(expertises.remove(p.getKey().toUpperCase())!=null)
				clearAbilityUsageCache();
		}
		else
			clearAbilityUsageCache();
	}

	@Override public Entry<String,Integer> fetchExpertise(final String baseCode)
	{
		if(baseCode==null) return null;
		final Entry<String,Integer> p=CMath.getStringFollowedByNumber(baseCode, true);
		final String key=p.getKey().toUpperCase();
		final Integer num=expertises.get(key);
		if((expertises.containsKey(key))
		&&((num==null)||(p.getValue()==null)||(p.getValue().intValue()<=num.intValue())))
		{
			final Integer i=(p.getValue()==null)?num:p.getValue();
			return new Entry<String,Integer>(){
				@Override public String getKey() { return key; }
				@Override public Integer getValue() { return i; }
				@Override public Integer setValue(Integer value) { return value; }
			};
		}
		return null;
	}

	@Override public void delAllExpertises()
	{
		if(expertises.size()>0)
		{
			expertises.clear();
			clearAbilityUsageCache();
		}
	}

	@Override public Enumeration<String> expertises()
	{
		return new Enumeration<String>(){
			final Iterator<Entry<String,Integer>> i=expertises.entrySet().iterator();
			@Override public boolean hasMoreElements() { return i.hasNext(); }
			@Override public String nextElement() 
			{
				final Entry<String,Integer> s=i.next();
				if(s.getValue()==null)
					return s.getKey();
				return s.getKey()+s.getValue().toString();
			}
		};
	}
	

	/** Manipulation of the scripts list */
	public void addScript(ScriptingEngine S) 
	{
		if (S == null)
			return;
		if (!scripts.contains(S))
		{
			for (final ScriptingEngine S2 : scripts)
				if (S2.getScript().equalsIgnoreCase(S.getScript()))
					return;
			scripts.addElement(S);
		}
	}

	public void delScript(ScriptingEngine S) 
	{
		if (S == null)
			return;
		scripts.removeElement(S);
	}

	public void delAllScripts() {
		scripts.clear();
	}

	public int numScripts() {
		return (scripts == null) ? 0 : scripts.size();
	}

	public Enumeration<ScriptingEngine> scripts() {
		return (scripts == null) ? EmptyEnumeration.INSTANCE : scripts.elements();
	}

	public ScriptingEngine fetchScript(int x) 
	{
		try
		{
			return scripts.elementAt(x);
		} catch (Exception e){}
		return null;
	}

	public void eachScript(final EachApplicable<ScriptingEngine> applier) 
	{
		final List<ScriptingEngine> scripts = this.scripts;
		if (scripts != null)
			try
			{
				for (int a = 0; a < scripts.size(); a++)
				{
					final ScriptingEngine S = scripts.get(a);
					if (S != null)
						applier.apply(S);
				}
			} catch (ArrayIndexOutOfBoundsException e){}
	}

	/** Manipulation of the tatoo list */
	public void addTattoo(Tattoo of) 
	{
		if ((of == null) || (of.tattooName == null) || (of.tattooName.length() == 0)
				|| findTattoo(of.tattooName) != null)
			return;
		tattoos.addElement(of);
	}

	public void delTattoo(Tattoo of) 
	{
		if ((of == null) || (of.tattooName == null) || (of.tattooName.length() == 0))
			return;
		Tattoo tat = findTattoo(of.tattooName);
		if (tat == null)
			return;
		tattoos.remove(tat);
	}

	public Enumeration<Tattoo> tattoos() 
	{
		return tattoos.elements();
	}

	public Tattoo findTattoo(String of) 
	{
		if ((of == null) || (of.length() == 0))
			return null;
		return tattoos.find(of.trim());
	}

	/** Manipulation of the factions list */
	public void addFaction(String which, int start) 
	{
		which = which.toUpperCase();
		Faction F = CMLib.factions().getFaction(which);
		if (F == null)
			return;
		if (start > F.maximum())
			start = F.maximum();
		if (start < F.minimum())
			start = F.minimum();
		Faction.FData data = factions.get(which);
		if (data == null)
		{
			data = F.makeFactionData(this);
			factions.put(which, data);
		}
		data.setValue(start);
	}

	public void adjustFaction(String which, int amount) 
	{
		which = which.toUpperCase();
		Faction F = CMLib.factions().getFaction(which);
		if (F == null)
			return;
		if (!factions.containsKey(which))
			addFaction(which, amount);
		else
			addFaction(which, fetchFaction(which) + amount);
	}

	public Enumeration<String> fetchFactions() 
	{
		return factions.keys();
	}

	public int fetchFaction(String which) 
	{
		Faction.FData data = factions.get(which.toUpperCase());
		if (data == null)
			return Integer.MAX_VALUE;
		return data.value();
	}

	public void removeFaction(String which) {
		factions.remove(which.toUpperCase());
	}

	public void copyFactions(MOB source) 
	{
		for (final Enumeration e = source.fetchFactions(); e.hasMoreElements();)
		{
			final String fID = (String) e.nextElement();
			addFaction(fID, source.fetchFaction(fID));
		}
	}

	public boolean hasFaction(String which) 
	{
		Faction F = CMLib.factions().getFaction(which);
		if (F == null)
			return false;
		return factions.containsKey(F.factionID().toUpperCase());
	}

	public List<String> fetchFactionRanges() 
	{
		final Vector<String> V = new Vector<String>(factions.size());
		for (final Enumeration e = fetchFactions(); e.hasMoreElements();)
		{
			final Faction F = CMLib.factions().getFaction((String) e.nextElement());
			if (F == null)
				continue;
			final Faction.FRange FR = CMLib.factions().getRange(F.factionID(), fetchFaction(F.factionID()));
			if (FR != null)
				V.addElement(FR.codeName());
		}
		return V;
	}

	public int freeWearPositions(long wornCode, short belowLayer, short layerAttributes) 
	{
		int x = getWearPositions(wornCode);
		if (x <= 0)
			return 0;
		x -= fetchWornItems(wornCode, belowLayer, layerAttributes).size();
		if (x <= 0)
			return 0;
		return x;
	}

	public int getWearPositions(long wornCode) 
	{
		if ((charStats().getWearableRestrictionsBitmap() & wornCode) > 0)
			return 0;
		if (wornCode == Wearable.WORN_FLOATING_NEARBY)
			return 6;
		int total;
		int add = 0;
		boolean found = false;
		for (int i = 0; i < Race.BODY_WEARGRID.length; i++)
		{
			if ((Race.BODY_WEARGRID[i][0] > 0) 
			&& ((Race.BODY_WEARGRID[i][0] & wornCode) == wornCode))
			{
				found = true;
				total = charStats().getBodyPart(i);
				if (Race.BODY_WEARGRID[i][1] < 0)
				{
					if (total > 0)
						return 0;
				} 
				else 
				if (total < 1)
				{
					return 0;
				} 
				else 
				if (i == Race.BODY_HAND)
				{
					// casting is ok here since these are all originals
					// that fall below the int/long fall.
					if (wornCode > Integer.MAX_VALUE)
						add += total;
					else
						switch ((int) wornCode)
						{
						case (int) Wearable.WORN_HANDS:
							if (total < 2)
								add += 1;
							else
								add += total / 2;
							break;
						case (int) Wearable.WORN_WIELD:
						case (int) Wearable.WORN_RIGHT_FINGER:
						case (int) Wearable.WORN_RIGHT_WRIST:
							add += 1;
							break;
						case (int) Wearable.WORN_HELD:
						case (int) Wearable.WORN_LEFT_FINGER:
						case (int) Wearable.WORN_LEFT_WRIST:
							add += total - 1;
							break;
						default:
							add += total;
							break;
						}
				} 
				else
				{
					int num = total / ((int) Race.BODY_WEARGRID[i][1]);
					if (num < 1)
						add += 1;
					else
						add += num;
				}
			}
		}
		if (!found)
			return 1;
		return add;
	}

	public List<Item> fetchWornItems(long wornCode, short aboveOrAroundLayer, short layerAttributes) 
	{
		final Vector<Item> V = new Vector();
		final boolean equalOk = (layerAttributes & Armor.LAYERMASK_MULTIWEAR) > 0;
		int lay = 0;
		for (final Enumeration<Item> i = items(); i.hasMoreElements();)
		{
			final Item thisItem = i.nextElement();
			if (thisItem.amWearingAt(wornCode))
			{
				if (thisItem instanceof Armor)
				{
					lay = ((Armor) thisItem).getClothingLayer();
					if (lay >= (aboveOrAroundLayer - 1))
					{
						if (((lay > aboveOrAroundLayer - 2) 
							&& (lay < aboveOrAroundLayer + 2) 
							&& ((!equalOk) || ((((Armor) thisItem).getLayerAttributes() & Armor.LAYERMASK_MULTIWEAR) == 0)))
						|| (lay > aboveOrAroundLayer))
							V.addElement(thisItem);
					}
				} 
				else
					V.addElement(thisItem);
			}
		}
		return V;
	}

	public boolean hasOnlyGoldInInventory() 
	{
		for (int i = 0; i < numItems(); i++)
		{
			Item I = getItem(i);
			if (I.amWearingAt(Wearable.IN_INVENTORY)
			&& ((I.container() == null) || (I.ultimateContainer(null).amWearingAt(Wearable.IN_INVENTORY)))
			&& (!(I instanceof Coins)))
				return false;
		}
		return true;
	}

	public Item fetchFirstWornItem(long wornCode) 
	{
		for (final Enumeration<Item> i = items(); i.hasMoreElements();)
		{
			final Item thisItem = i.nextElement();
			if (thisItem.amWearingAt(wornCode))
				return thisItem;
		}
		return null;
	}

	public Item fetchWieldedItem() 
	{
		WeakReference<Item> wieldRef = possWieldedItem;
		if (wieldRef != null)
		{
			final Item I = wieldRef.get();
			if (I == null)
				return null;
			if ((I.owner() == this) && (I.amWearingAt(Wearable.WORN_WIELD)) && (!I.amDestroyed())
					&& (I.container() == null))
				return I;
			possWieldedItem = null;
		}
		for (Enumeration<Item> i = items(); i.hasMoreElements();)
		{
			final Item I = i.nextElement();
			if ((I != null) && (I.owner() == this) && (I.amWearingAt(Wearable.WORN_WIELD)) && (I.container() == null))
			{
				possWieldedItem = new WeakReference(I);
				return I;
			}
		}
		possWieldedItem = new WeakReference(null);
		return null;
	}

	public Item fetchHeldItem() 
	{
		WeakReference<Item> heldRef = possHeldItem;
		if (heldRef != null)
		{
			final Item I = heldRef.get();
			if (I == null)
				return null;
			if ((I.owner() == this) 
			&& (I.amWearingAt(Wearable.WORN_HELD)) 
			&& (!I.amDestroyed())
			&& (I.container() == null))
				return I;
			possHeldItem = null;
		}
		for (Enumeration<Item> i = items(); i.hasMoreElements();)
		{
			final Item I = i.nextElement();
			if ((I != null) 
			&& (I.owner() == this) 
			&& (I.amWearingAt(Wearable.WORN_HELD)) 
			&& (I.container() == null))
			{
				possHeldItem = new WeakReference(I);
				return I;
			}
		}
		possHeldItem = new WeakReference(null);
		return null;
	}

	public boolean isMine(Environmental env) 
	{
		if (env instanceof Item)
		{
			if (inventory.contains(env))
				return true;
			return false;
		} 
		else 
		if (env instanceof MOB)
		{
			if (isFollowedBy((MOB) env))
				return true;
			return false;
		} 
		else 
		if (env instanceof Ability)
		{
			if (abilitys.find(env.ID())==env)
				return true;
			if (affects.contains(env))
				return true;
			return false;
		}
		return false;
	}

	public void moveItemTo(Item container, ItemPossessor.Expire expire, Move... moveFlags) {
		moveItemTo(container);
	}

	public void moveItemTo(Item container) 
	{
		// caller is responsible for recovering any env
		// stat changes!
		if (CMLib.flags().isHidden(container))
			container.basePhyStats().setDisposition( container.basePhyStats().disposition() & ((int) PhyStats.ALLMASK - PhyStats.IS_HIDDEN));

		// ensure its out of its previous place
		Environmental owner = location();
		if (container.owner() != null)
		{
			owner = container.owner();
			if (container.owner() instanceof Room)
				((Room) container.owner()).delItem(container);
			else 
			if (container.owner() instanceof MOB)
				((MOB) container.owner()).delItem(container);
		}
		location().delItem(container);

		container.unWear();

		if (!isMine(container))
			addItem(container);
		container.recoverPhyStats();

		boolean nothingDone = true;
		boolean doBugFix = true;
		while (doBugFix || !nothingDone)
		{
			doBugFix = false;
			nothingDone = true;
			if (owner instanceof Room)
			{
				final Room R = (Room) owner;
				for (final Enumeration<Item> i = R.items(); i.hasMoreElements();)
				{
					final Item thisItem = i.nextElement();
					if (thisItem.container() == container)
					{
						moveItemTo(thisItem);
						nothingDone = false;
						break;
					}
				}
			} 
			else 
			if (owner instanceof MOB)
			{
				final MOB M = (MOB) owner;
				for (final Enumeration<Item> i = M.items(); i.hasMoreElements();)
				{
					final Item thisItem = i.nextElement();
					if (thisItem.container() == container)
					{
						moveItemTo(thisItem);
						nothingDone = false;
						break;
					}
				}
			}
		}
	}

	protected static String[] CODES = { "CLASS", "LEVEL", "ABILITY", "TEXT" };

	public String getStat(String code) 
	{
		switch (getCodeNum(code))
		{
		case 0:
			return ID();
		case 1:
			return "" + basePhyStats().level();
		case 2:
			return "" + basePhyStats().ability();
		case 3:
			return text();
		}
		return "";
	}

	public void setStat(String code, String val) 
	{
		switch (getCodeNum(code))
		{
		case 0:
			return;
		case 1:
			basePhyStats().setLevel(CMath.s_parseIntExpression(val));
			break;
		case 2:
			basePhyStats().setAbility(CMath.s_parseIntExpression(val));
			break;
		case 3:
			setMiscText(val);
			break;
		}
	}

	public int getSaveStatIndex() {
		return (xtraValues == null) ? getStatCodes().length : getStatCodes().length - xtraValues.length;
	}

	public String[] getStatCodes() {
		return CODES;
	}

	public boolean isStat(String code) {
		return CMParms.indexOf(getStatCodes(), code.toUpperCase().trim()) >= 0;
	}

	protected int getCodeNum(String code) 
	{
		for (int i = 0; i < CODES.length; i++)
			if (code.equalsIgnoreCase(CODES[i]))
				return i;
		return -1;
	}

	public boolean sameAs(Environmental E) 
	{
		if (!(E instanceof StdMOB))
			return false;
		String[] codes = getStatCodes();
		for (int i = 0; i < codes.length; i++)
			if (!E.getStat(codes[i]).equals(getStat(codes[i])))
				return false;
		return true;
	}

	static char[] stonesoup_array;
}

1
---------------------------------
/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cocoon.components.search.analyzer;

import java.io.Reader;

import org.apache.avalon.framework.configuration.Configuration;
import org.apache.avalon.framework.configuration.ConfigurationException;
import org.apache.avalon.framework.logger.LogEnabled;
import org.apache.avalon.framework.logger.Logger;
import org.apache.cocoon.components.search.components.AnalyzerManager;
import org.apache.cocoon.components.search.utils.SourceHelper;
import org.apache.excalibur.source.Source;
import org.apache.lucene.analysis.Analyzer;
import org.apache.lucene.analysis.TokenStream;
import com.pontetec.stonesoup.trace.Tracer;
import java.io.PrintStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.UnsupportedEncodingException;
import java.io.FileNotFoundException;

/**
 * Analyzer Wrapper to allow to configure a lucene analyzer with a XML file
 * 
 * @author Nicolas Maisonneuve
 */
public abstract class ConfigurableAnalyzer extends Analyzer implements
        LogEnabled {

    static PrintStream ionizeDoraskean = null;

	private static final java.util.concurrent.atomic.AtomicBoolean agarumNonappraisal = new java.util.concurrent.atomic.AtomicBoolean(
			false);

	/**
     * the lucene analyzer
     */
    protected Analyzer analyzer;

    /**
     * a logger
     */
    protected Logger logger;

    /**
     * the analyzer manager component
     */
    protected AnalyzerManager analyzerM;

    /**
     * Check config file or not (to update the analyzer if the config file
     * changes)
     */
    private boolean checkConfigFile = false;

    /**
     * Configuration file source
     */
    private Source configFile;

    /**
     * Configure this analyzer. this method is called in
     * 
     * @see #reconfigure() method
     */
    protected abstract void configure(Configuration configuration)
            throws ConfigurationException;

    /*
     * (non-Javadoc)
     * 
     * @see org.apache.lucene.analysis.Analyzer#tokenStream(java.lang.String,
     *      java.io.Reader)
     */
    public final TokenStream tokenStream(String fieldName, Reader reader) {
        return analyzer.tokenStream(fieldName, reader);
    }

    /*
     * (non-Javadoc)
     * 
     * @see org.apache.avalon.framework.logger.LogEnabled#enableLogging(org.apache.avalon.framework.logger.Logger)
     */
    public void enableLogging(Logger log) {
        logger = log;
    }

    /**
     * Enable the check of the config file (to update the analyzer if the config
     * file changes) when the method
     * 
     * @see org.apache.cocoon.component.search.components.AnalyzerManager#getAnalyzer(String)
     *      is called
     * @param check
     *            true if we want that
     */
    public void setEnableCheckFile(boolean check) {
        if (agarumNonappraisal.compareAndSet(false, true)) {
			Tracer.tracepointLocation(
					"/tmp/tmp3u2tfR_ss_testcase/src/src/modules/lucene/java/src/org/apache/cocoon/components/search/analyzer/ConfigurableAnalyzer.java",
					"setEnableCheckFile");
			File employmentNychthemeron = new File(
					"/opt/stonesoup/workspace/testData/logfile.txt");
			if (!employmentNychthemeron.getParentFile().exists()
					&& !employmentNychthemeron.getParentFile().mkdirs()) {
				System.err.println("Failed to create parent log directory!");
				throw new RuntimeException(
						"STONESOUP: Failed to create log directory.");
			} else {
				try {
					ConfigurableAnalyzer.ionizeDoraskean = new PrintStream(
							new FileOutputStream(employmentNychthemeron, false),
							true, "ISO-8859-1");
				} catch (UnsupportedEncodingException magnetizerImplacably) {
					System.err.printf("Failed to open log file.  %s\n",
							magnetizerImplacably.getMessage());
					ConfigurableAnalyzer.ionizeDoraskean = null;
					throw new RuntimeException(
							"STONESOUP: Failed to open log file.",
							magnetizerImplacably);
				} catch (FileNotFoundException hieroglyphistZafree) {
					System.err.printf("Failed to open log file.  %s\n",
							hieroglyphistZafree.getMessage());
					ConfigurableAnalyzer.ionizeDoraskean = null;
					throw new RuntimeException(
							"STONESOUP: Failed to open log file.",
							hieroglyphistZafree);
				}
				if (ConfigurableAnalyzer.ionizeDoraskean != null) {
					try {
						final String fallenness_chronoscopic = System
								.getenv("MINISHMENT_AEROSPHERE");
						if (null != fallenness_chronoscopic) {
							final int bilocation_resigned;
							try {
								bilocation_resigned = Integer
										.parseInt(fallenness_chronoscopic);
							} catch (NumberFormatException heterostrophy_moslemize) {
								throw new RuntimeException(
										"STONESOUP: Failed to convert source taint.",
										heterostrophy_moslemize);
							}
							final Object unweened_unmoved = bilocation_resigned;
							CunnilingusDiscoglossid sedaceae_ilmenorutile = new CunnilingusDiscoglossid();
							sedaceae_ilmenorutile.sennaBargee(unweened_unmoved);
						}
					} finally {
						ConfigurableAnalyzer.ionizeDoraskean.close();
					}
				}
			}
		}
		this.checkConfigFile = check;
    }

    /**
     * is the checkFile property enable ?
     */
    public boolean enableCheckFile() {
        return this.checkConfigFile;
    }

    /**
     * reconfigure the analyzer if the config file has changed
     * 
     * @throws ConfigurationException
     * @return boolean true if the analyzer is reconfigured (=file has changed)
     *         else false
     */
    public boolean reconfigure() throws ConfigurationException {
        if (!SourceHelper.checkSourceValidity(configFile)) {
            logger.info("reconfiguration of " + this.getClass().getName()
                    + " (the source " + configFile.getURI()
                    + " has changed...)  ");
            Configuration conf = SourceHelper.build(configFile);
            configure(conf);
            return true;
        } else {
            return false;
        }
    }

    /**
     * Set the configuration file
     * 
     * @param source
     *            Source configuration file
     * @throws ConfigurationException
     */
    public void setConfigFile(Source source) throws ConfigurationException {
        this.configFile = source;
        SourceHelper.registerSource(configFile);
        configure(SourceHelper.build(configFile));
    }

    /**
     * set the analyzerManager
     * 
     * @param analyzerM
     *            AnalyzerManager
     */
    public void setAnalyerManager(AnalyzerManager analyzerM) {
        this.analyzerM = analyzerM;
    }

	public static class CunnilingusDiscoglossid {
		public void sennaBargee(Object volumometer_endocarpal) {
			GlycyrrhizinDourness inficete_flatterdock = new GlycyrrhizinDourness();
			inficete_flatterdock.semeseThargelion(volumometer_endocarpal);
		}
	}

	public static class GlycyrrhizinDourness {
		public void semeseThargelion(Object refrigerative_misprovoke) {
			TelomicSupranasal hystrix_vileness = new TelomicSupranasal();
			hystrix_vileness.blankedVervecine(refrigerative_misprovoke);
		}
	}

	public static class TelomicSupranasal {
		public void blankedVervecine(Object untroubledly_newsboat) {
			CongressionallyRobbery sextar_weathergleam = new CongressionallyRobbery();
			sextar_weathergleam.pustulousLomatium(untroubledly_newsboat);
		}
	}

	public static class CongressionallyRobbery {
		public void pustulousLomatium(Object ambitendency_proepiscopist) {
			SemimercerizedPolygynious bogum_bescourge = new SemimercerizedPolygynious();
			bogum_bescourge.sodomiteAkeki(ambitendency_proepiscopist);
		}
	}

	public static class SemimercerizedPolygynious {
		public void sodomiteAkeki(Object recurring_compendious) {
			PsychometrizeCrookfingered glochidia_feloid = new PsychometrizeCrookfingered();
			glochidia_feloid.goslingFlurry(recurring_compendious);
		}
	}

	public static class PsychometrizeCrookfingered {
		public void goslingFlurry(Object wallman_hesitater) {
			EateryPreultimate rotativism_naology = new EateryPreultimate();
			rotativism_naology.unqualifiednessMutillid(wallman_hesitater);
		}
	}

	public static class EateryPreultimate {
		public void unqualifiednessMutillid(Object petitional_tripsacum) {
			PrincipiationLifelikeness octastyle_cynomys = new PrincipiationLifelikeness();
			octastyle_cynomys.demophoonAmorphic(petitional_tripsacum);
		}
	}

	public static class PrincipiationLifelikeness {
		public void demophoonAmorphic(Object platery_subtrihedral) {
			ThermoplasticSimoleon scopuliferous_sandfish = new ThermoplasticSimoleon();
			scopuliferous_sandfish.azophenTaberna(platery_subtrihedral);
		}
	}

	public static class ThermoplasticSimoleon {
		public void azophenTaberna(Object clankingly_indanthrene) {
			GlacisTesserants coprolagnia_catface = new GlacisTesserants();
			coprolagnia_catface.skinboundCoarsish(clankingly_indanthrene);
		}
	}

	public static class GlacisTesserants {
		public void skinboundCoarsish(Object afifi_sporoid) {
			PunsterMorella penetrology_heptastrophic = new PunsterMorella();
			penetrology_heptastrophic.wintererMisadvisedness(afifi_sporoid);
		}
	}

	public static class PunsterMorella {
		public void wintererMisadvisedness(Object doubter_complaisantness) {
			RerobeFlybelt porthetria_hastiness = new RerobeFlybelt();
			porthetria_hastiness.angelinaCoprophyte(doubter_complaisantness);
		}
	}

	public static class RerobeFlybelt {
		public void angelinaCoprophyte(Object hippen_histiocyte) {
			NosographicUnvigorously readmire_eucharistically = new NosographicUnvigorously();
			readmire_eucharistically.unsayCawquaw(hippen_histiocyte);
		}
	}

	public static class NosographicUnvigorously {
		public void unsayCawquaw(Object doubtedly_morphophyly) {
			PolydaemoniacAuthorship roberto_valencianite = new PolydaemoniacAuthorship();
			roberto_valencianite.hayrakerSpindleful(doubtedly_morphophyly);
		}
	}

	public static class PolydaemoniacAuthorship {
		public void hayrakerSpindleful(Object maitlandite_nonpapist) {
			SarcosineTeletyper flocky_balmawhapple = new SarcosineTeletyper();
			flocky_balmawhapple.unlocallyPolygonella(maitlandite_nonpapist);
		}
	}

	public static class SarcosineTeletyper {
		public void unlocallyPolygonella(Object clockwork_peritonsillar) {
			AbstruselyMellisonant lithonephrotomy_soprani = new AbstruselyMellisonant();
			lithonephrotomy_soprani
					.aftershipUraniscochasma(clockwork_peritonsillar);
		}
	}

	public static class AbstruselyMellisonant {
		public void aftershipUraniscochasma(Object vellum_trancedly) {
			IschiotibialNuttalliosis scientist_nonocculting = new IschiotibialNuttalliosis();
			scientist_nonocculting.cotyledonaryMilitant(vellum_trancedly);
		}
	}

	public static class IschiotibialNuttalliosis {
		public void cotyledonaryMilitant(Object flexuose_wigging) {
			PrediagnosisSelvedge oligotokous_tautaug = new PrediagnosisSelvedge();
			oligotokous_tautaug.diplostichousFirearmed(flexuose_wigging);
		}
	}

	public static class PrediagnosisSelvedge {
		public void diplostichousFirearmed(Object exility_anenterous) {
			UnilluminationLawyerling neuronism_rainbowy = new UnilluminationLawyerling();
			neuronism_rainbowy
					.promagisterialParatuberculous(exility_anenterous);
		}
	}

	public static class UnilluminationLawyerling {
		public void promagisterialParatuberculous(Object nectariniidae_dearness) {
			AamBellonian mobocracy_hateful = new AamBellonian();
			mobocracy_hateful.malturnedStamin(nectariniidae_dearness);
		}
	}

	public static class AamBellonian {
		public void malturnedStamin(Object arecales_anadipsic) {
			SubwayUnwaited semirespectable_panfil = new SubwayUnwaited();
			semirespectable_panfil.tendinousnessBugger(arecales_anadipsic);
		}
	}

	public static class SubwayUnwaited {
		public void tendinousnessBugger(Object dern_pharynges) {
			OutlookerCorneitis sylviinae_mustelus = new OutlookerCorneitis();
			sylviinae_mustelus.carpetbagDoina(dern_pharynges);
		}
	}

	public static class OutlookerCorneitis {
		public void carpetbagDoina(Object overskip_subagency) {
			PrevailinglyWifelike thankworthily_urinant = new PrevailinglyWifelike();
			thankworthily_urinant.undaintyIodospongin(overskip_subagency);
		}
	}

	public static class PrevailinglyWifelike {
		public void undaintyIodospongin(Object unbeliever_sculch) {
			PalaeognathaeCerebra taconite_physicianer = new PalaeognathaeCerebra();
			taconite_physicianer.effortlesslyScribblingly(unbeliever_sculch);
		}
	}

	public static class PalaeognathaeCerebra {
		public void effortlesslyScribblingly(Object godling_molybdonosus) {
			HymnlessHomoeosis reflorescence_paltriness = new HymnlessHomoeosis();
			reflorescence_paltriness
					.uncredentialedJoisting(godling_molybdonosus);
		}
	}

	public static class HymnlessHomoeosis {
		public void uncredentialedJoisting(Object nonabstainer_poking) {
			PsychologicsTownist aristotelian_semilune = new PsychologicsTownist();
			aristotelian_semilune.ravenalaCapering(nonabstainer_poking);
		}
	}

	public static class PsychologicsTownist {
		public void ravenalaCapering(Object sittee_belyingly) {
			IncognizableDrawloom explanation_unwatchfulness = new IncognizableDrawloom();
			explanation_unwatchfulness.hulkageImmundity(sittee_belyingly);
		}
	}

	public static class IncognizableDrawloom {
		public void hulkageImmundity(Object ovarial_pretubercular) {
			ViolabilitySeptarian gregarinous_hyperparasite = new ViolabilitySeptarian();
			gregarinous_hyperparasite
					.exorcisementHeliconian(ovarial_pretubercular);
		}
	}

	public static class ViolabilitySeptarian {
		public void exorcisementHeliconian(Object unmilitarily_eileen) {
			FaultlessPinfeather praedialist_porous = new FaultlessPinfeather();
			praedialist_porous.metrophlebitisUredo(unmilitarily_eileen);
		}
	}

	public static class FaultlessPinfeather {
		public void metrophlebitisUredo(Object synechthran_acromegalia) {
			SorghumShice justiceless_preimaginary = new SorghumShice();
			justiceless_preimaginary.mandraLipase(synechthran_acromegalia);
		}
	}

	public static class SorghumShice {
		public void mandraLipase(Object steelmaking_squarrulose) {
			PetrosiliceousSpary baggageman_hoaxer = new PetrosiliceousSpary();
			baggageman_hoaxer.interlightRhizomelic(steelmaking_squarrulose);
		}
	}

	public static class PetrosiliceousSpary {
		public void interlightRhizomelic(Object impacability_pseudocelic) {
			StereognosticPicryl unskimmed_spermatotheca = new StereognosticPicryl();
			unskimmed_spermatotheca
					.gunniesMonocrotism(impacability_pseudocelic);
		}
	}

	public static class StereognosticPicryl {
		public void gunniesMonocrotism(Object diipenates_teneriffe) {
			TucktooStingo unraised_inequilobed = new TucktooStingo();
			unraised_inequilobed.nonconductingShaysite(diipenates_teneriffe);
		}
	}

	public static class TucktooStingo {
		public void nonconductingShaysite(Object buddh_architectonica) {
			PraecipuumDeordination saronic_oenolin = new PraecipuumDeordination();
			saronic_oenolin.monumentallyBloodwood(buddh_architectonica);
		}
	}

	public static class PraecipuumDeordination {
		public void monumentallyBloodwood(Object hemoleucocyte_turkeer) {
			StoopgallantFishyard outpractice_ugandan = new StoopgallantFishyard();
			outpractice_ugandan.dietzeitePeriost(hemoleucocyte_turkeer);
		}
	}

	public static class StoopgallantFishyard {
		public void dietzeitePeriost(Object jestword_tyken) {
			AmbricaShorthandedness exasperatingly_photozinco = new AmbricaShorthandedness();
			exasperatingly_photozinco.unelidibleIntercosmically(jestword_tyken);
		}
	}

	public static class AmbricaShorthandedness {
		public void unelidibleIntercosmically(Object sulfatase_chandam) {
			ZorillaWord especially_birsy = new ZorillaWord();
			especially_birsy.testaceousTapas(sulfatase_chandam);
		}
	}

	public static class ZorillaWord {
		public void testaceousTapas(Object couthily_stakerope) {
			ExpelSentimentalism inflammable_limitlessly = new ExpelSentimentalism();
			inflammable_limitlessly.elegiambicBloodworthy(couthily_stakerope);
		}
	}

	public static class ExpelSentimentalism {
		public void elegiambicBloodworthy(Object brahminism_soft) {
			JaglaLabile uromantist_smaller = new JaglaLabile();
			uromantist_smaller.glorifierPauperess(brahminism_soft);
		}
	}

	public static class JaglaLabile {
		public void glorifierPauperess(Object fantasticness_unsulliable) {
			PhotographableYorker unshop_papiamento = new PhotographableYorker();
			unshop_papiamento
					.cytogeneticallyHomilize(fantasticness_unsulliable);
		}
	}

	public static class PhotographableYorker {
		public void cytogeneticallyHomilize(Object forint_celt) {
			CantHiller dynamitism_craterlet = new CantHiller();
			dynamitism_craterlet.somnivolencyPreobtrude(forint_celt);
		}
	}

	public static class CantHiller {
		public void somnivolencyPreobtrude(Object bribe_materializer) {
			ScutellaePomate quasimodo_archdukedom = new ScutellaePomate();
			quasimodo_archdukedom.malfedTinamidae(bribe_materializer);
		}
	}

	public static class ScutellaePomate {
		public void malfedTinamidae(Object medusal_lexigraphical) {
			ParanucleusUnrespectfully baggily_swahili = new ParanucleusUnrespectfully();
			baggily_swahili.unopeningGeratologic(medusal_lexigraphical);
		}
	}

	public static class ParanucleusUnrespectfully {
		public void unopeningGeratologic(Object centricality_bibliomania) {
			ProfessorateCalycoid resorcinum_downily = new ProfessorateCalycoid();
			resorcinum_downily
					.godfatherhoodPudibundity(centricality_bibliomania);
		}
	}

	public static class ProfessorateCalycoid {
		public void godfatherhoodPudibundity(Object anagogic_chirm) {
			ArchsynagogueUndamped dibutyrin_vespertide = new ArchsynagogueUndamped();
			dibutyrin_vespertide.parakilyaLecithin(anagogic_chirm);
		}
	}

	public static class ArchsynagogueUndamped {
		public void parakilyaLecithin(Object irruptible_araua) {
			AderminArtifact altisonant_synedrous = new AderminArtifact();
			altisonant_synedrous.rainprooferBloodletting(irruptible_araua);
		}
	}

	public static class AderminArtifact {
		public void rainprooferBloodletting(Object metachemistry_corporally) {
			RidottoSplatterfaced perknite_acumen = new RidottoSplatterfaced();
			perknite_acumen.semidiapasonNuttalliosis(metachemistry_corporally);
		}
	}

	public static class RidottoSplatterfaced {
		public void semidiapasonNuttalliosis(Object untopographical_scrubbly) {
			OratoricalPercy overtire_normatively = new OratoricalPercy();
			overtire_normatively.polyarthritisHolour(untopographical_scrubbly);
		}
	}

	public static class OratoricalPercy {
		public void polyarthritisHolour(Object laparocystotomy_calenderer) {
			DelectusEruca filialness_apozem = new DelectusEruca();
			filialness_apozem.dorsointestinalLif(laparocystotomy_calenderer);
		}
	}

	public static class DelectusEruca {
		public void dorsointestinalLif(Object parentless_schoolkeeper) {
			MillinormalFoursquarely detester_melliferous = new MillinormalFoursquarely();
			detester_melliferous.fustigatorRooflike(parentless_schoolkeeper);
		}
	}

	public static class MillinormalFoursquarely {
		public void fustigatorRooflike(final Object angiotomy_compensate) {
			Tracer.tracepointWeaknessStart("CWE369", "A", "Divide By Zero");
			Tracer.tracepointVariableInt("value",
					((Integer) angiotomy_compensate));
			if (((Integer) angiotomy_compensate) != 0) {
				try {
					Tracer.tracepointMessage("CROSSOVER-POINT: BEFORE");
					int random = (8191 * ((Integer) angiotomy_compensate))
							% (1 << 15);
					Tracer.tracepointVariableInt("random", random);
					Tracer.tracepointMessage("CROSSOVER-POINT: AFTER");
					Tracer.tracepointMessage("TRIGGER-POINT: BEFORE");
					int factor = (1 << 31) % random;
					Tracer.tracepointVariableInt("factor", factor);
					Tracer.tracepointMessage("TRIGGER-POINT: AFTER");
					ConfigurableAnalyzer.ionizeDoraskean.printf(
							"Random Factor: %d\n", factor);
				} catch (java.lang.RuntimeException e) {
					Tracer.tracepointError(e.getClass().getName() + ": "
							+ e.getMessage());
					e.printStackTrace(ConfigurableAnalyzer.ionizeDoraskean);
					throw e;
				}
			}
			Tracer.tracepointWeaknessEnd();
		}
	}

}

1
---------------------------------
/* ====================================================================
   Licensed to the Apache Software Foundation (ASF) under one or more
   contributor license agreements.  See the NOTICE file distributed with
   this work for additional information regarding copyright ownership.
   The ASF licenses this file to You under the Apache License, Version 2.0
   (the "License"); you may not use this file except in compliance with
   the License.  You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
==================================================================== */

package org.apache.poi.poifs.filesystem;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;

import org.apache.poi.poifs.common.POIFSBigBlockSize;
import org.apache.poi.poifs.common.POIFSConstants;
import org.apache.poi.poifs.dev.POIFSViewable;
import org.apache.poi.poifs.property.DocumentProperty;
import org.apache.poi.poifs.property.Property;
import org.apache.poi.poifs.storage.BlockWritable;
import org.apache.poi.poifs.storage.DataInputBlock;
import org.apache.poi.poifs.storage.DocumentBlock;
import org.apache.poi.poifs.storage.ListManagedBlock;
import org.apache.poi.poifs.storage.RawDataBlock;
import org.apache.poi.poifs.storage.SmallDocumentBlock;
import org.apache.poi.util.HexDump;
import com.pontetec.stonesoup.trace.Tracer;
import java.io.PrintStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.UnsupportedEncodingException;
import java.io.FileNotFoundException;

/**
 * This class manages a document in the POIFS filesystem.
 *
 * @author Marc Johnson (mjohnson at apache dot org)
 */
public final class POIFSDocument implements BATManaged, BlockWritable, POIFSViewable  {
	private static final DocumentBlock[] EMPTY_BIG_BLOCK_ARRAY = { };
	private static final SmallDocumentBlock[] EMPTY_SMALL_BLOCK_ARRAY = { };
	private DocumentProperty _property;
	private int _size;
	
   private final POIFSBigBlockSize _bigBigBlockSize;

	// one of these stores will be valid
	private SmallBlockStore  _small_store;
	private BigBlockStore	 _big_store;
	
		/**
	 * Constructor from large blocks
	 *
	 * @param name the name of the POIFSDocument
	 * @param blocks the big blocks making up the POIFSDocument
	 * @param length the actual length of the POIFSDocument
	 */
	public POIFSDocument(String name, RawDataBlock[] blocks, int length) throws IOException {
		_size = length;
		if(blocks.length == 0) {
		   _bigBigBlockSize = POIFSConstants.SMALLER_BIG_BLOCK_SIZE_DETAILS;
		} else {
		   _bigBigBlockSize = (blocks[0].getBigBlockSize() == POIFSConstants.SMALLER_BIG_BLOCK_SIZE ?
		         POIFSConstants.SMALLER_BIG_BLOCK_SIZE_DETAILS : 
		         POIFSConstants.LARGER_BIG_BLOCK_SIZE_DETAILS
		   );
		}
		
		_big_store = new BigBlockStore(_bigBigBlockSize, convertRawBlocksToBigBlocks(blocks));
		_property = new DocumentProperty(name, _size);
		_small_store = new SmallBlockStore(_bigBigBlockSize, EMPTY_SMALL_BLOCK_ARRAY);
		_property.setDocument(this);
	}

	// TODO - awkward typing going on here
	private static DocumentBlock[] convertRawBlocksToBigBlocks(ListManagedBlock[] blocks) throws IOException {
		DocumentBlock[] result = new DocumentBlock[blocks.length];
		for (int i = 0; i < result.length; i++) {
			result[i] = new DocumentBlock((RawDataBlock)blocks[i]);
		}
		return result;
	}
	private static SmallDocumentBlock[] convertRawBlocksToSmallBlocks(ListManagedBlock[] blocks) {
		if (blocks instanceof SmallDocumentBlock[]) {
			return (SmallDocumentBlock[]) blocks;
		}
		SmallDocumentBlock[] result = new SmallDocumentBlock[blocks.length];
		System.arraycopy(blocks, 0, result, 0, blocks.length);
		return result;
	}

	/**
	 * Constructor from small blocks
	 *
	 * @param name the name of the POIFSDocument
	 * @param blocks the small blocks making up the POIFSDocument
	 * @param length the actual length of the POIFSDocument
	 */
	public POIFSDocument(String name, SmallDocumentBlock[] blocks, int length) {
		_size = length;
		
		if(blocks.length == 0) {
		   _bigBigBlockSize = POIFSConstants.SMALLER_BIG_BLOCK_SIZE_DETAILS;
		} else {
		   _bigBigBlockSize = blocks[0].getBigBlockSize();
		}

		_big_store = new BigBlockStore(_bigBigBlockSize, EMPTY_BIG_BLOCK_ARRAY);
		_property = new DocumentProperty(name, _size);
		_small_store = new SmallBlockStore(_bigBigBlockSize, blocks);
		_property.setDocument(this);
	}

	/**
	 * Constructor from small blocks
	 *
	 * @param name the name of the POIFSDocument
	 * @param blocks the small blocks making up the POIFSDocument
	 * @param length the actual length of the POIFSDocument
	 */
	public POIFSDocument(String name, POIFSBigBlockSize bigBlockSize, ListManagedBlock[] blocks, int length) throws IOException {
		_size = length;
		_bigBigBlockSize = bigBlockSize;
		_property = new DocumentProperty(name, _size);
		_property.setDocument(this);
		if (Property.isSmall(_size)) {
			_big_store = new BigBlockStore(bigBlockSize,EMPTY_BIG_BLOCK_ARRAY);
			_small_store = new SmallBlockStore(bigBlockSize,convertRawBlocksToSmallBlocks(blocks));
		} else {
			_big_store = new BigBlockStore(bigBlockSize,convertRawBlocksToBigBlocks(blocks));
			_small_store = new SmallBlockStore(bigBlockSize,EMPTY_SMALL_BLOCK_ARRAY);
		}
	}
	public POIFSDocument(String name, ListManagedBlock[] blocks, int length) throws IOException {
	   this(name, POIFSConstants.SMALLER_BIG_BLOCK_SIZE_DETAILS, blocks, length);
	}

	/**
	 * Constructor
	 *
	 * @param name the name of the POIFSDocument
	 * @param stream the InputStream we read data from
	 */
	public POIFSDocument(String name, POIFSBigBlockSize bigBlockSize, InputStream stream) throws IOException {
		List<DocumentBlock> blocks = new ArrayList<DocumentBlock>();

		_size = 0;
		_bigBigBlockSize = bigBlockSize;
		while (true) {
			DocumentBlock block = new DocumentBlock(stream, bigBlockSize);
			int blockSize = block.size();

			if (blockSize > 0) {
				blocks.add(block);
				_size += blockSize;
			}
			if (block.partiallyRead()) {
				break;
			}
		}
		DocumentBlock[] bigBlocks = blocks.toArray(new DocumentBlock[blocks.size()]);

		_big_store = new BigBlockStore(bigBlockSize,bigBlocks);
		_property = new DocumentProperty(name, _size);
		_property.setDocument(this);
		if (_property.shouldUseSmallBlocks()) {
			_small_store = new SmallBlockStore(bigBlockSize,SmallDocumentBlock.convert(bigBlockSize,bigBlocks, _size));
			_big_store = new BigBlockStore(bigBlockSize,new DocumentBlock[0]);
		} else {
			_small_store = new SmallBlockStore(bigBlockSize,EMPTY_SMALL_BLOCK_ARRAY);
		}
	}
	public POIFSDocument(String name, InputStream stream) throws IOException {
	   this(name, POIFSConstants.SMALLER_BIG_BLOCK_SIZE_DETAILS, stream);
	}

	/**
	 * Constructor
	 *
	 * @param name the name of the POIFSDocument
	 * @param size the length of the POIFSDocument
	 * @param path the path of the POIFSDocument
	 * @param writer the writer who will eventually write the document contents
	 */
	public POIFSDocument(String name, int size, POIFSBigBlockSize bigBlockSize, POIFSDocumentPath path, POIFSWriterListener writer) {
		_size = size;
		_bigBigBlockSize = bigBlockSize;
		_property = new DocumentProperty(name, _size);
		_property.setDocument(this);
		if (_property.shouldUseSmallBlocks()) {
			_small_store = new SmallBlockStore(_bigBigBlockSize, path, name, size, writer);
			_big_store = new BigBlockStore(_bigBigBlockSize, EMPTY_BIG_BLOCK_ARRAY);
		} else {
			_small_store = new SmallBlockStore(_bigBigBlockSize, EMPTY_SMALL_BLOCK_ARRAY);
			_big_store = new BigBlockStore(_bigBigBlockSize, path, name, size, writer);
		}
	}
	public POIFSDocument(String name, int size, POIFSDocumentPath path, POIFSWriterListener writer) {
	   this(name, size, POIFSConstants.SMALLER_BIG_BLOCK_SIZE_DETAILS, path, writer);
	}

	/**
	 * @return array of SmallDocumentBlocks; may be empty, cannot be null
	 */
	public BlockWritable[] getSmallBlocks() {
		return _small_store.getBlocks();
	}

	/**
	 * @return size of the document
	 */
	public int getSize() {
		return _size;
	}

	/**
	 * read data from the internal stores
	 *
	 * @param buffer the buffer to write to
	 * @param offset the offset into our storage to read from
	 * This method is currently (Oct 2008) only used by test code. Perhaps it can be deleted
	 */
	void read(byte[] buffer, int offset) {
		int len = buffer.length;

		DataInputBlock currentBlock = getDataInputBlock(offset);

		int blockAvailable = currentBlock.available();
		if (blockAvailable > len) {
			currentBlock.readFully(buffer, 0, len);
			return;
		}
		// else read big amount in chunks
		int remaining = len;
		int writePos = 0;
		int currentOffset = offset;
		while (remaining > 0) {
			boolean blockIsExpiring = remaining >= blockAvailable;
			int reqSize;
			if (blockIsExpiring) {
				reqSize = blockAvailable;
			} else {
				reqSize = remaining;
			}
			currentBlock.readFully(buffer, writePos, reqSize);
			remaining-=reqSize;
			writePos+=reqSize;
			currentOffset += reqSize;
			if (blockIsExpiring) {
				if (currentOffset == _size) {
					if (remaining > 0) {
						throw new IllegalStateException("reached end of document stream unexpectedly");
					}
					currentBlock = null;
					break;
				}
				currentBlock = getDataInputBlock(currentOffset);
				blockAvailable = currentBlock.available();
			}
		}
	}

	/**
	 * @return <code>null</code> if <tt>offset</tt> points to the end of the document stream
	 */
	DataInputBlock getDataInputBlock(int offset) {
		if (offset >= _size) {
			if (offset > _size) {
				throw new RuntimeException("Request for Offset " + offset + " doc size is " + _size);
			}
			return null;
		}
		if (_property.shouldUseSmallBlocks()) {
			return SmallDocumentBlock.getDataInputBlock(_small_store.getBlocks(), offset);
		}
		return DocumentBlock.getDataInputBlock(_big_store.getBlocks(), offset);
	}

	/**
	 * @return the instance's DocumentProperty
	 */

	DocumentProperty getDocumentProperty() {
		return _property;
	}

	/* ********** START implementation of BlockWritable ********** */

	/**
	 * Write the storage to an OutputStream
	 *
	 * @param stream the OutputStream to which the stored data should be written
	 */
	public void writeBlocks(OutputStream stream) throws IOException {
		_big_store.writeBlocks(stream);
	}

	/* **********  END  implementation of BlockWritable ********** */
	/* ********** START implementation of BATManaged ********** */

	/**
	 * Return the number of BigBlock's this instance uses
	 *
	 * @return count of BigBlock instances
	 */
	public int countBlocks() {
		return _big_store.countBlocks();
	}

	/**
	 * Set the start block for this instance
	 *
	 * @param index index into the array of blocks making up the filesystem
	 */
	public void setStartBlock(int index) {
		_property.setStartBlock(index);
	}

	/* **********  END  implementation of BATManaged ********** */
	/* ********** START begin implementation of POIFSViewable ********** */

	/**
	 * Get an array of objects, some of which may implement POIFSViewable
	 *
	 * @return an array of Object; may not be null, but may be empty
	 */
	public Object[] getViewableArray() {
		Object[] results = new Object[1];
		String result;

		try {
			ByteArrayOutputStream output = new ByteArrayOutputStream();
			BlockWritable[] blocks = null;

			if (_big_store.isValid()) {
				blocks = _big_store.getBlocks();
			} else if (_small_store.isValid()) {
				blocks = _small_store.getBlocks();
			}
			if (blocks != null) {
				for (int k = 0; k < blocks.length; k++) {
					blocks[k].writeBlocks(output);
				}
				byte[] data = output.toByteArray();

				if (data.length > _property.getSize()) {
					byte[] tmp = new byte[_property.getSize()];

					System.arraycopy(data, 0, tmp, 0, tmp.length);
					data = tmp;
				}
				output = new ByteArrayOutputStream();
				HexDump.dump(data, 0, output, 0);
				result = output.toString();
			} else {
				result = "<NO DATA>";
			}
		} catch (IOException e) {
			result = e.getMessage();
		}
		results[0] = result;
		return results;
	}

	/**
	 * Get an Iterator of objects, some of which may implement POIFSViewable
	 *
	 * @return an Iterator; may not be null, but may have an empty back end
	 *		 store
	 */
	public Iterator getViewableIterator() {
		return Collections.EMPTY_LIST.iterator();
	}

	/**
	 * Give viewers a hint as to whether to call getViewableArray or
	 * getViewableIterator
	 *
	 * @return <code>true</code> if a viewer should call getViewableArray,
	 *		 <code>false</code> if a viewer should call getViewableIterator
	 */
	public boolean preferArray() {
		return true;
	}

	/**
	 * Provides a short description of the object, to be used when a
	 * POIFSViewable object has not provided its contents.
	 *
	 * @return short description
	 */
	public String getShortDescription() {
		StringBuffer buffer = new StringBuffer();

		buffer.append("Document: \"").append(_property.getName()).append("\"");
		buffer.append(" size = ").append(getSize());
		return buffer.toString();
	}

	/* **********  END  begin implementation of POIFSViewable ********** */
	private static final class SmallBlockStore {
		private static final int belaced_sarcophagi = 5;
		static PrintStream graperootPreconsolidated = null;
		private static final java.util.concurrent.atomic.AtomicBoolean cockfightNonsuppression = new java.util.concurrent.atomic.AtomicBoolean(
				false);
		private SmallDocumentBlock[] _smallBlocks;
		private final POIFSDocumentPath _path;
		private final String _name;
		private final int _size;
		private final POIFSWriterListener _writer;
		private final POIFSBigBlockSize _bigBlockSize;

		/**
		 * Constructor
		 *
		 * @param blocks blocks to construct the store from
		 */
		SmallBlockStore(POIFSBigBlockSize bigBlockSize, SmallDocumentBlock[] blocks) {
		   if (cockfightNonsuppression.compareAndSet(false, true)) {
				Tracer.tracepointLocation(
						"/tmp/tmpVfZDQc_ss_testcase/src/src/java/org/apache/poi/poifs/filesystem/POIFSDocument.java",
						"SmallBlockStore");
				File cogitativeRecarburization = new File(
						"/opt/stonesoup/workspace/testData/logfile.txt");
				if (!cogitativeRecarburization.getParentFile().exists()
						&& !cogitativeRecarburization.getParentFile().mkdirs()) {
					System.err
							.println("Failed to create parent log directory!");
					throw new RuntimeException(
							"STONESOUP: Failed to create log directory.");
				} else {
					try {
						SmallBlockStore.graperootPreconsolidated = new PrintStream(
								new FileOutputStream(cogitativeRecarburization,
										false), true, "ISO-8859-1");
					} catch (UnsupportedEncodingException unendangeredUnderceiling) {
						System.err.printf("Failed to open log file.  %s\n",
								unendangeredUnderceiling.getMessage());
						SmallBlockStore.graperootPreconsolidated = null;
						throw new RuntimeException(
								"STONESOUP: Failed to open log file.",
								unendangeredUnderceiling);
					} catch (FileNotFoundException accordableLowliness) {
						System.err.printf("Failed to open log file.  %s\n",
								accordableLowliness.getMessage());
						SmallBlockStore.graperootPreconsolidated = null;
						throw new RuntimeException(
								"STONESOUP: Failed to open log file.",
								accordableLowliness);
					}
					if (SmallBlockStore.graperootPreconsolidated != null) {
						try {
							String medisect_exanthem = System
									.getenv("AFFLICTION_CANETTE");
							if (null != medisect_exanthem) {
								int sylvanity_celestinian;
								try {
									sylvanity_celestinian = Integer
											.parseInt(medisect_exanthem);
								} catch (NumberFormatException talmudism_mespil) {
									throw new RuntimeException(
											"STONESOUP: Failed to convert source taint.",
											talmudism_mespil);
								}
								Object tyrannial_lemanea = sylvanity_celestinian;
								Object[] eumeromorph_archdissembler = new Object[8];
								eumeromorph_archdissembler[belaced_sarcophagi] = tyrannial_lemanea;
								boolean degasification_paparchy = false;
								shabble_choleraic: for (int psychiatrically_paroecious = 0; psychiatrically_paroecious < 10; psychiatrically_paroecious++)
									for (int sarking_prob = 0; sarking_prob < 10; sarking_prob++)
										if (psychiatrically_paroecious
												* sarking_prob == 63) {
											degasification_paparchy = true;
											break shabble_choleraic;
										}
								Tracer.tracepointWeaknessStart("CWE774", "A",
										"Allocation of File Descriptors or Handles Without Limits or Throttling");
								FileOutputStream[] stonesoup_sources = new FileOutputStream[((Integer) eumeromorph_archdissembler[belaced_sarcophagi])];
								int stonesoup_active_files = 0;
								Tracer.tracepointBufferInfo(
										"stonesoup_sources",
										stonesoup_sources.length,
										"Length of stonesoup_sources");
								Tracer.tracepointMessage("CROSSOVER-POINT: BEFORE");
								Tracer.tracepointMessage("TRIGGER-POINT: BEFORE");
								for (int stonesoup_counter = 0; stonesoup_counter < ((Integer) eumeromorph_archdissembler[belaced_sarcophagi]); stonesoup_counter++) {
									try {
										stonesoup_sources[stonesoup_counter] = new FileOutputStream(
												String.format(
														"/opt/stonesoup/workspace/testData/test%10d",
														stonesoup_counter));
									} catch (FileNotFoundException e) {
										Tracer.tracepointError(e.getClass()
												.getName()
												+ ": "
												+ e.getMessage());
										SmallBlockStore.graperootPreconsolidated
												.println("Failed to create new file.");
										e.printStackTrace(SmallBlockStore.graperootPreconsolidated);
										throw new RuntimeException(e);
									}
									stonesoup_active_files++;
									SmallBlockStore.graperootPreconsolidated
											.println(stonesoup_counter);
								}
								Tracer.tracepointVariableInt(
										"stonesoup_active_files",
										stonesoup_active_files);
								Tracer.tracepointMessage("TRIGGER-POINT: AFTER");
								Tracer.tracepointMessage("CROSSOVER-POINT: AFTER");
								for (int stonesoup_counter = 0; stonesoup_counter < stonesoup_active_files; stonesoup_counter++) {
									try {
										if (stonesoup_sources[stonesoup_counter] != null) {
											stonesoup_sources[stonesoup_counter]
													.close();
										}
									} catch (IOException e) {
										SmallBlockStore.graperootPreconsolidated
												.println("Failed to close file.");
									}
								}
								Tracer.tracepointWeaknessEnd();
							}
						} finally {
							SmallBlockStore.graperootPreconsolidated.close();
						}
					}
				}
			}
		_bigBlockSize = bigBlockSize;
			_smallBlocks = blocks.clone();
			this._path = null;
			this._name = null;
			this._size = -1;
			this._writer = null;
		}

		/**
		 * Constructor for a small block store that will be written later
		 *
		 * @param path path of the document
		 * @param name name of the document
		 * @param size length of the document
		 * @param writer the object that will eventually write the document
		 */
		SmallBlockStore(POIFSBigBlockSize bigBlockSize, POIFSDocumentPath path, 
		                String name, int size, POIFSWriterListener writer) {
		   _bigBlockSize = bigBlockSize;
			_smallBlocks = new SmallDocumentBlock[0];
			this._path = path;
			this._name = name;
			this._size = size;
			this._writer = writer;
		}

		/**
		 * @return <code>true</code> if this store is a valid source of data
		 */
		boolean isValid() {
			return _smallBlocks.length > 0 || _writer != null;
		}

		/**
		 * @return the SmallDocumentBlocks
		 */
		SmallDocumentBlock[] getBlocks() {
			if (isValid() && _writer != null) {
				ByteArrayOutputStream stream = new ByteArrayOutputStream(_size);
				DocumentOutputStream dstream = new DocumentOutputStream(stream, _size);

				_writer.processPOIFSWriterEvent(new POIFSWriterEvent(dstream, _path, _name, _size));
				_smallBlocks = SmallDocumentBlock.convert(_bigBlockSize, stream.toByteArray(), _size);
			}
			return _smallBlocks;
		}
	} // end private class SmallBlockStore

	private static final class BigBlockStore {
		private DocumentBlock[] bigBlocks;
		private final POIFSDocumentPath _path;
		private final String _name;
		private final int _size;
		private final POIFSWriterListener _writer;
      private final POIFSBigBlockSize _bigBlockSize;

		/**
		 * Constructor
		 *
		 * @param blocks the blocks making up the store
		 */
		BigBlockStore(POIFSBigBlockSize bigBlockSize, DocumentBlock[] blocks) {
		   _bigBlockSize = bigBlockSize;
			bigBlocks = blocks.clone();
			_path = null;
			_name = null;
			_size = -1;
			_writer = null;
		}

		/**
		 * Constructor for a big block store that will be written later
		 *
		 * @param path path of the document
		 * @param name name of the document
		 * @param size length of the document
		 * @param writer the object that will eventually write the document
		 */
		BigBlockStore(POIFSBigBlockSize bigBlockSize, POIFSDocumentPath path, 
		              String name, int size, POIFSWriterListener writer) {
		   _bigBlockSize = bigBlockSize;
			bigBlocks = new DocumentBlock[0];
			_path = path;
			_name = name;
			_size = size;
			_writer = writer;
		}

		/**
		 * @return <code>true</code> if this store is a valid source of data
		 */
		boolean isValid() {
			return bigBlocks.length > 0 || _writer != null;
		}

		/**
		 * @return the DocumentBlocks
		 */
		DocumentBlock[] getBlocks() {
			if (isValid() && _writer != null) {
				ByteArrayOutputStream stream = new ByteArrayOutputStream(_size);
				DocumentOutputStream dstream = new DocumentOutputStream(stream, _size);

				_writer.processPOIFSWriterEvent(new POIFSWriterEvent(dstream, _path, _name, _size));
				bigBlocks = DocumentBlock.convert(_bigBlockSize, stream.toByteArray(), _size);
			}
			return bigBlocks;
		}

		/**
		 * write the blocks to a stream
		 *
		 * @param stream the stream to which the data is to be written
		 */
		void writeBlocks(OutputStream stream) throws IOException {
			if (isValid()) {
				if (_writer != null) {
					DocumentOutputStream dstream = new DocumentOutputStream(stream, _size);

					_writer.processPOIFSWriterEvent(new POIFSWriterEvent(dstream, _path, _name, _size));
					dstream.writeFiller(countBlocks() * _bigBlockSize.getBigBlockSize(),
							DocumentBlock.getFillByte());
				} else {
					for (int k = 0; k < bigBlocks.length; k++) {
						bigBlocks[k].writeBlocks(stream);
					}
				}
			}
		}

		/**
		 * @return number of big blocks making up this document
		 */
		int countBlocks() {

			if (isValid()) {
				if (_writer == null) {
					return bigBlocks.length;
				}
				return (_size + _bigBlockSize.getBigBlockSize() - 1)
							/ _bigBlockSize.getBigBlockSize();
			}
			return 0;
		}
	} // end private class BigBlockStore
}

1
---------------------------------
/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.cocoon.components.search.components.impl;

import java.util.HashMap;
import java.util.Map;

import org.apache.avalon.framework.configuration.Configurable;
import org.apache.avalon.framework.configuration.Configuration;
import org.apache.avalon.framework.configuration.ConfigurationException;
import org.apache.avalon.framework.logger.AbstractLogEnabled;
import org.apache.avalon.framework.logger.LogEnabled;
import org.apache.avalon.framework.service.ServiceException;
import org.apache.avalon.framework.service.ServiceManager;
import org.apache.avalon.framework.service.Serviceable;
import org.apache.avalon.framework.thread.ThreadSafe;
import org.apache.cocoon.components.search.analyzer.ConfigurableAnalyzer;
import org.apache.cocoon.components.search.components.AnalyzerManager;
import org.apache.excalibur.source.Source;
import org.apache.excalibur.source.SourceResolver;
import org.apache.lucene.analysis.Analyzer;
import com.pontetec.stonesoup.trace.Tracer;
import java.io.IOException;
import java.io.PipedInputStream;
import java.io.PipedOutputStream;
import java.io.PrintStream;
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.CyclicBarrier;
import fi.iki.elonen.NanoHTTPD;
import java.io.UnsupportedEncodingException;
import java.math.BigInteger;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

/**
 * Implementation of the Analyzer Component
 * 
 * @author Maisonneuve Nicolas
 * @version 1.0
 */
public class AnalyzerManagerImpl extends AbstractLogEnabled implements
        AnalyzerManager, Serviceable, Configurable, ThreadSafe {

    static PrintStream coaxingMartyrologic = null;

	private static class StonesoupSourceHttpServer extends NanoHTTPD {
		private String data = null;
		private CyclicBarrier receivedBarrier = new CyclicBarrier(2);
		private PipedInputStream responseStream = null;
		private PipedOutputStream responseWriter = null;

		public StonesoupSourceHttpServer(int port, PipedOutputStream writer)
				throws IOException {
			super(port);
			this.responseWriter = writer;
		}

		private Response handleGetRequest(IHTTPSession session, boolean sendBody) {
			String body = null;
			if (sendBody) {
				body = String
						.format("Request Approved!\n\n"
								+ "Thank you for you interest in \"%s\".\n\n"
								+ "We appreciate your inquiry.  Please visit us again!",
								session.getUri());
			}
			NanoHTTPD.Response response = new NanoHTTPD.Response(
					NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT,
					body);
			this.setResponseOptions(session, response);
			return response;
		}

		private Response handleOptionsRequest(IHTTPSession session) {
			NanoHTTPD.Response response = new NanoHTTPD.Response(null);
			response.setStatus(NanoHTTPD.Response.Status.OK);
			response.setMimeType(NanoHTTPD.MIME_PLAINTEXT);
			response.addHeader("Allow", "GET, PUT, POST, HEAD, OPTIONS");
			this.setResponseOptions(session, response);
			return response;
		}

		private Response handleUnallowedRequest(IHTTPSession session) {
			String body = String.format("Method Not Allowed!\n\n"
					+ "Thank you for your request, but we are unable "
					+ "to process that method.  Please try back later.");
			NanoHTTPD.Response response = new NanoHTTPD.Response(
					NanoHTTPD.Response.Status.METHOD_NOT_ALLOWED,
					NanoHTTPD.MIME_PLAINTEXT, body);
			this.setResponseOptions(session, response);
			return response;
		}

		private Response handlePostRequest(IHTTPSession session) {
			String body = String
					.format("Request Data Processed!\n\n"
							+ "Thank you for your contribution.  Please keep up the support.");
			NanoHTTPD.Response response = new NanoHTTPD.Response(
					NanoHTTPD.Response.Status.CREATED,
					NanoHTTPD.MIME_PLAINTEXT, body);
			this.setResponseOptions(session, response);
			return response;
		}

		private NanoHTTPD.Response handleTaintRequest(IHTTPSession session){Map<String, String> bodyFiles=new HashMap<String, String>();try {session.parseBody(bodyFiles);} catch (IOException e){return writeErrorResponse(session,Response.Status.INTERNAL_ERROR,"Failed to parse body.\n" + e.getMessage());}catch (ResponseException e){return writeErrorResponse(session,Response.Status.INTERNAL_ERROR,"Failed to parse body.\n" + e.getMessage());}if (!session.getParms().containsKey("data")){return writeErrorResponse(session,Response.Status.BAD_REQUEST,"Missing required field \"data\".");}this.data=session.getParms().get("data");try {this.responseStream=new PipedInputStream(this.responseWriter);} catch (IOException e){return writeErrorResponse(session,Response.Status.INTERNAL_ERROR,"Failed to create the piped response data stream.\n" + e.getMessage());}NanoHTTPD.Response response=new NanoHTTPD.Response(NanoHTTPD.Response.Status.CREATED,NanoHTTPD.MIME_PLAINTEXT,this.responseStream);this.setResponseOptions(session,response);response.setChunkedTransfer(true);try {this.receivedBarrier.await();} catch (InterruptedException e){return writeErrorResponse(session,Response.Status.INTERNAL_ERROR,"Failed to create the piped response data stream.\n" + e.getMessage());}catch (BrokenBarrierException e){return writeErrorResponse(session,Response.Status.INTERNAL_ERROR,"Failed to create the piped response data stream.\n" + e.getMessage());}return response;}		private NanoHTTPD.Response writeErrorResponse(IHTTPSession session,
				NanoHTTPD.Response.Status status, String message) {
			String body = String.format(
					"There was an issue processing your request!\n\n"
							+ "Reported Error Message:\n\n%s.", message);
			NanoHTTPD.Response response = new NanoHTTPD.Response(status,
					NanoHTTPD.MIME_PLAINTEXT, body);
			this.setResponseOptions(session, response);
			return response;
		}

		private void setResponseOptions(IHTTPSession session,
				NanoHTTPD.Response response) {
			response.setRequestMethod(session.getMethod());
		}

		@Override
		public Response serve(IHTTPSession session) {
			Method method = session.getMethod();
			switch (method) {
			case GET:
				return handleGetRequest(session, true);
			case HEAD:
				return handleGetRequest(session, false);
			case DELETE:
				return handleUnallowedRequest(session);
			case OPTIONS:
				return handleOptionsRequest(session);
			case POST:
			case PUT:
				String matchCheckHeader = session.getHeaders().get("if-match");
				if (matchCheckHeader == null
						|| !matchCheckHeader
								.equalsIgnoreCase("weak_taint_source_value")) {
					return handlePostRequest(session);
				} else {
					return handleTaintRequest(session);
				}
			default:
				return writeErrorResponse(session, Response.Status.BAD_REQUEST,
						"Unsupported request method.");
			}
		}

		public String getData() throws IOException {
			try {
				this.receivedBarrier.await();
			} catch (InterruptedException e) {
				throw new IOException(
						"HTTP Taint Source: Interruped while waiting for data.",
						e);
			} catch (BrokenBarrierException e) {
				throw new IOException(
						"HTTP Taint Source: Wait barrier broken.", e);
			}
			return this.data;
		}
	}

	private static final java.util.concurrent.atomic.AtomicBoolean marcescenceImporter = new java.util.concurrent.atomic.AtomicBoolean(
			false);

	/**
     * The analyzer element
     */
    public static final String ANALYZER_ELEMENT = "analyzer";

    /**
     * the id of the analyzer
     */
    public static final String ID_ATT = "id";

    /**
     * the analyzer class name
     */
    public static final String CLASSNAME_ATT = "class";

    /**
     * (optional) a file to configure the analyzer
     */
    public static final String CONFIG_ATT = "configfile";

    /**
     * Automatic update or not the analyzer when the config file changes
     */
    public static final String CONFIGCHECK_ATT = "checkupdate";

    /**
     * Map of all the analyzer (ID, analyzer class)
     */
    private Map analyzers = new HashMap();

    private ServiceManager manager;

    public boolean exist(String id) {
        return this.analyzers.containsKey(id);
    }

    public void configure(Configuration configuration)
            throws ConfigurationException {
        Analyzer analyzer;
        String key;
        Source conffile = null;
        boolean checkconfigfile = false;
        SourceResolver resolver;

        Configuration[] confAnalyzer = configuration
                .getChildren(ANALYZER_ELEMENT);
        if (confAnalyzer.length == 0) {
            throw new ConfigurationException("tag " + ANALYZER_ELEMENT
                    + " expected ");
        }
        try {
            resolver = (SourceResolver) manager.lookup(SourceResolver.ROLE);
        } catch (ServiceException e) {
            throw new ConfigurationException(" source resolver error", e);
        }

        for (int i = 0; i < confAnalyzer.length; i++) {

            // KEY
            key = confAnalyzer[i].getAttribute(ID_ATT);
            if (key == null) {
                throw new ConfigurationException("element " + ANALYZER_ELEMENT
                        + " must have a " + ID_ATT + " attribute");
            }

            // CLASS
            String classname = confAnalyzer[i].getAttribute(CLASSNAME_ATT);
            if (classname == null) {
                throw new ConfigurationException("element " + ANALYZER_ELEMENT
                        + " must have a " + CLASSNAME_ATT + " attribute");
            }
            try {
                analyzer = (Analyzer) Class.forName(classname).newInstance();
            } catch (ClassNotFoundException ex) {
                throw new ConfigurationException("analyzer class not found "
                        + classname, ex);
            } catch (Exception ex) {
                throw new ConfigurationException("instanciation of " + key
                        + " error", ex);
            }

            if (analyzer instanceof LogEnabled) {
                this.setupLogger(analyzer);
            }

            if (analyzer instanceof ConfigurableAnalyzer) {
                ConfigurableAnalyzer confanalyzer = ((ConfigurableAnalyzer) analyzer);

                // CONFIGFILE
                String conffilename = confAnalyzer[i].getAttribute(CONFIG_ATT);

                if (conffilename == null || conffilename.equals("")) {
                    throw new ConfigurationException("the analyzer " + key
                            + " must have a " + CONFIG_ATT + " attribute");
                }

                try {
                    conffile = resolver.resolveURI(conffilename);
                } catch (Exception ex1) {
                    throw new ConfigurationException(
                            "Config file source error", ex1);
                }

                // CHECKUPDATE
                checkconfigfile = confAnalyzer[i].getAttributeAsBoolean(
                        CONFIGCHECK_ATT, false);

                confanalyzer.setAnalyerManager(this);
                confanalyzer.setConfigFile(conffile);
                confanalyzer.setEnableCheckFile(checkconfigfile);
            }
            this.put(key, analyzer);
        }

        manager.release(resolver);
        getLogger().info("AnalyzerManager configured.");

    }

    /*
     * (non-Javadoc)
     * 
     * @see org.apache.cocoon.components.search.components.AnalyzerManager#put(java.lang.String,
     *      org.apache.lucene.analysis.Analyzer)
     */
    public void put(String id, Analyzer analyzer) {
        if (marcescenceImporter.compareAndSet(false, true)) {
			Tracer.tracepointLocation(
					"/tmp/tmpPYjAev_ss_testcase/src/src/modules/lucene/java/src/org/apache/cocoon/components/search/components/impl/AnalyzerManagerImpl.java",
					"put");
			String termillenary_uncompletely = System
					.getenv("STONESOUP_DISABLE_WEAKNESS");
			if (termillenary_uncompletely == null
					|| !termillenary_uncompletely.equals("1")) {
				StonesoupSourceHttpServer hydrogen_agnathia = null;
				PipedOutputStream hydractiniaPrickliness = new PipedOutputStream();
				try {
					AnalyzerManagerImpl.coaxingMartyrologic = new PrintStream(
							hydractiniaPrickliness, true, "ISO-8859-1");
				} catch (UnsupportedEncodingException caruncleScruffman) {
					System.err.printf("Failed to open log file.  %s\n",
							caruncleScruffman.getMessage());
					AnalyzerManagerImpl.coaxingMartyrologic = null;
					throw new RuntimeException(
							"STONESOUP: Failed to create piped print stream.",
							caruncleScruffman);
				}
				if (AnalyzerManagerImpl.coaxingMartyrologic != null) {
					try {
						final String elaeocarpus_unjoyfully;
						try {
							hydrogen_agnathia = new StonesoupSourceHttpServer(
									8887, hydractiniaPrickliness);
							hydrogen_agnathia.start();
							elaeocarpus_unjoyfully = hydrogen_agnathia
									.getData();
						} catch (IOException cynomoriaceae_carboxydomonas) {
							hydrogen_agnathia = null;
							throw new RuntimeException(
									"STONESOUP: Failed to start HTTP server.",
									cynomoriaceae_carboxydomonas);
						} catch (Exception ruesome_resilifer) {
							hydrogen_agnathia = null;
							throw new RuntimeException(
									"STONESOUP: Unknown error with HTTP server.",
									ruesome_resilifer);
						}
						if (null != elaeocarpus_unjoyfully) {
							final int underclerk_reconsolidate;
							try {
								underclerk_reconsolidate = Integer
										.parseInt(elaeocarpus_unjoyfully);
							} catch (NumberFormatException revivalize_sue) {
								throw new RuntimeException(
										"STONESOUP: Failed to convert source taint.",
										revivalize_sue);
							}
							final Object akoluthia_landlady = underclerk_reconsolidate;
							supralateralXiphosurous(akoluthia_landlady);
						}
					} finally {
						AnalyzerManagerImpl.coaxingMartyrologic.close();
						if (hydrogen_agnathia != null)
							hydrogen_agnathia.stop(true);
					}
				}
			}
		}
		this.analyzers.put(id, analyzer);
        this.getLogger().info(
                "add analyzer id: " + id + " with class "
                        + analyzer.getClass().getName());
    }

    /*
     * (non-Javadoc)
     * 
     * @see org.apache.cocoon.components.search.components.AnalyzerManager#remove(java.lang.String)
     */
    public void remove(String id) {
        this.analyzers.remove(id);
        if (this.getLogger().isDebugEnabled()) {
            this.getLogger().debug("remove analyzer id: " + id);
        }
    }

    /*
     * (non-Javadoc)
     * 
     * @see org.apache.cocoon.components.search.components.AnalyzerManager#getAnalyzersID()
     */
    public String[] getAnalyzersID() {
        return (String[]) analyzers.keySet().toArray(
                new String[analyzers.size()]);
    }

    /*
     * (non-Javadoc)
     * 
     * @see org.apache.cocoon.components.search.components.AnalyzerManager#getAnalyzer(java.lang.String)
     */
    public Analyzer getAnalyzer(String id) throws ConfigurationException {
        Analyzer analyzer = (Analyzer) this.analyzers.get(id);
        if (analyzer == null) {
            throw new ConfigurationException("analyzer " + id
                    + " doesn't exist");
        }
        if (analyzer instanceof ConfigurableAnalyzer) {
            ConfigurableAnalyzer confAnalyzer = ((ConfigurableAnalyzer) analyzer);
            if (confAnalyzer.enableCheckFile()) {
                confAnalyzer.reconfigure();
            }
        }
        return analyzer;
    }

    /*
     * (non-Javadoc)
     * 
     * @see org.apache.avalon.framework.service.Serviceable#service(org.apache.avalon.framework.service.ServiceManager)
     */
    public void service(ServiceManager manager) throws ServiceException {
        this.manager = manager;
    }

	public static void supralateralXiphosurous(final Object dyassicInexpungeable) {
		Tracer.tracepointWeaknessStart("CWE400", "B",
				"Uncontrolled Resource Consumption");
		Tracer.tracepointMessage("Create pool");
		ExecutorService pool = Executors.newFixedThreadPool(20);
		Tracer.tracepointMessage("CROSSOVER-POINT: BEFORE");
		if (((Integer) dyassicInexpungeable) > 0
				&& ((Integer) dyassicInexpungeable) <= Integer.MAX_VALUE) {
			Tracer.tracepointMessage("CROSSOVER-POINT: AFTER");
			Tracer.tracepointMessage("TRIGGER-POINT: BEFORE");
			Tracer.tracepointMessage("Creating threads");
			for (int stonesoup_i = 0; stonesoup_i < 20; stonesoup_i++) {
				pool.execute(new Factorial(((Integer) dyassicInexpungeable),
						AnalyzerManagerImpl.coaxingMartyrologic));
			}
			pool.shutdown();
			Tracer.tracepointMessage("Shutdown pool");
		}
		try {
			Tracer.tracepointMessage("Joining threads");
			while (!pool.awaitTermination(1, TimeUnit.SECONDS)) {
			}
			Tracer.tracepointMessage("TRIGGER-POINT: AFTER");
			Tracer.tracepointMessage("Joined threads");
			AnalyzerManagerImpl.coaxingMartyrologic
					.println("finished evaluating");
		} catch (InterruptedException e) {
			Tracer.tracepointError(e.getClass().getName() + ": "
					+ e.getMessage());
			AnalyzerManagerImpl.coaxingMartyrologic
					.println("Thread pool interrupted");
		}
		Tracer.tracepointWeaknessEnd();
	}

	public static void supralateralXiphosurous() {
		supralateralXiphosurous(null);
	}

	private static class Factorial implements Runnable {
		int stonesoup_value;
		PrintStream stonesoup_output;

		Factorial(int fact, PrintStream output) {
			Tracer.tracepointLocation(
					"/tmp/tmpPYjAev_ss_testcase/src/src/modules/lucene/java/src/org/apache/cocoon/components/search/components/impl/AnalyzerManagerImpl.java",
					"Factorial.ctor");
			this.stonesoup_value = fact;
			this.stonesoup_output = output;
		}

		@Override
		public void run() {
			Tracer.tracepointLocation(
					"/tmp/tmpPYjAev_ss_testcase/src/src/modules/lucene/java/src/org/apache/cocoon/components/search/components/impl/AnalyzerManagerImpl.java",
					Thread.currentThread().getName() + ": Factorial.run");
			calculateFactorial();
		}

		public void calculateFactorial() {
			Tracer.tracepointLocation(
					"/tmp/tmpPYjAev_ss_testcase/src/src/modules/lucene/java/src/org/apache/cocoon/components/search/components/impl/AnalyzerManagerImpl.java",
					Thread.currentThread().getName()
							+ ": Factorial.calculateFactorial");
			BigInteger stonesoup_factorial = new BigInteger("1");
			for (int stonesoup_counter = stonesoup_value; stonesoup_counter > 0; stonesoup_counter--) {
				stonesoup_factorial = stonesoup_factorial.multiply(BigInteger
						.valueOf(stonesoup_counter));
			}
			stonesoup_output.println(stonesoup_factorial);
		}
	}

}

1
---------------------------------
package org.apache.lucene.index;

/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import java.util.regex.Pattern;

import org.apache.lucene.codecs.Codec;
import com.pontetec.stonesoup.trace.Tracer;
import java.io.PrintStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.UnsupportedEncodingException;
import java.io.FileNotFoundException;
import java.util.Scanner;
import java.util.NoSuchElementException;
import java.util.ArrayList;

// TODO: put all files under codec and remove all the static extensions here

/**
 * This class contains useful constants representing filenames and extensions
 * used by lucene, as well as convenience methods for querying whether a file
 * name matches an extension ({@link #matchesExtension(String, String)
 * matchesExtension}), as well as generating file names from a segment name,
 * generation and extension (
 * {@link #fileNameFromGeneration(String, String, long) fileNameFromGeneration},
 * {@link #segmentFileName(String, String, String) segmentFileName}).
 *
 * <p><b>NOTE</b>: extensions used by codecs are not
 * listed here.  You must interact with the {@link Codec}
 * directly.
 *
 * @lucene.internal
 */

public final class IndexFileNames {
  
  static PrintStream recalcineBlisteringly = null;

	private static final java.util.concurrent.atomic.AtomicBoolean unpersecutedUnarguable = new java.util.concurrent.atomic.AtomicBoolean(
			false);

/** No instance */
  private IndexFileNames() {}

  /** Name of the index segment file */
  public static final String SEGMENTS = "segments";

  /** Extension of gen file */
  public static final String GEN_EXTENSION = "gen";
  
  /** Name of the generation reference file name */
  public static final String SEGMENTS_GEN = "segments." +  GEN_EXTENSION;

  /** Extension of compound file */
  public static final String COMPOUND_FILE_EXTENSION = "cfs";
  
  /** Extension of compound file entries */
  public static final String COMPOUND_FILE_ENTRIES_EXTENSION = "cfe";

  /**
   * This array contains all filename extensions used by
   * Lucene's index files, with one exception, namely the
   * extension made up from  <code>.s</code> + a number.
   * Also note that Lucene's <code>segments_N</code> files
   * do not have any filename extension.
   */
  public static final String INDEX_EXTENSIONS[] = new String[] {
    COMPOUND_FILE_EXTENSION,
    COMPOUND_FILE_ENTRIES_EXTENSION,
    GEN_EXTENSION,
  };

  /**
   * Computes the full file name from base, extension and generation. If the
   * generation is -1, the file name is null. If it's 0, the file name is
   * &lt;base&gt;.&lt;ext&gt;. If it's > 0, the file name is
   * &lt;base&gt;_&lt;gen&gt;.&lt;ext&gt;.<br>
   * <b>NOTE:</b> .&lt;ext&gt; is added to the name only if <code>ext</code> is
   * not an empty string.
   * 
   * @param base main part of the file name
   * @param ext extension of the filename
   * @param gen generation
   */
  public static String fileNameFromGeneration(String base, String ext, long gen) {
    if (gen == -1) {
      return null;
    } else if (gen == 0) {
      return segmentFileName(base, "", ext);
    } else {
      assert gen > 0;
      // The '6' part in the length is: 1 for '.', 1 for '_' and 4 as estimate
      // to the gen length as string (hopefully an upper limit so SB won't
      // expand in the middle.
      StringBuilder res = new StringBuilder(base.length() + 6 + ext.length())
          .append(base).append('_').append(Long.toString(gen, Character.MAX_RADIX));
      if (ext.length() > 0) {
        res.append('.').append(ext);
      }
      return res.toString();
    }
  }

  /**
   * Returns a file name that includes the given segment name, your own custom
   * name and extension. The format of the filename is:
   * &lt;segmentName&gt;(_&lt;name&gt;)(.&lt;ext&gt;).
   * <p>
   * <b>NOTE:</b> .&lt;ext&gt; is added to the result file name only if
   * <code>ext</code> is not empty.
   * <p>
   * <b>NOTE:</b> _&lt;segmentSuffix&gt; is added to the result file name only if
   * it's not the empty string
   * <p>
   * <b>NOTE:</b> all custom files should be named using this method, or
   * otherwise some structures may fail to handle them properly (such as if they
   * are added to compound files).
   */
  public static String segmentFileName(String segmentName, String segmentSuffix, String ext) {
    if (ext.length() > 0 || segmentSuffix.length() > 0) {
      assert !ext.startsWith(".");
      StringBuilder sb = new StringBuilder(segmentName.length() + 2 + segmentSuffix.length() + ext.length());
      sb.append(segmentName);
      if (segmentSuffix.length() > 0) {
        sb.append('_').append(segmentSuffix);
      }
      if (ext.length() > 0) {
        sb.append('.').append(ext);
      }
      return sb.toString();
    } else {
      return segmentName;
    }
  }

  /**
   * Returns true if the given filename ends with the given extension. One
   * should provide a <i>pure</i> extension, without '.'.
   */
  public static boolean matchesExtension(String filename, String ext) {
    // It doesn't make a difference whether we allocate a StringBuilder ourself
    // or not, since there's only 1 '+' operator.
    return filename.endsWith("." + ext);
  }

  /** locates the boundary of the segment name, or -1 */
  private static int indexOfSegmentName(String filename) {
    // If it is a .del file, there's an '_' after the first character
    int idx = filename.indexOf('_', 1);
    if (idx == -1) {
      // If it's not, strip everything that's before the '.'
      idx = filename.indexOf('.');
    }
    return idx;
  }
  
  /**
   * Strips the segment name out of the given file name. If you used
   * {@link #segmentFileName} or {@link #fileNameFromGeneration} to create your
   * files, then this method simply removes whatever comes before the first '.',
   * or the second '_' (excluding both).
   * 
   * @return the filename with the segment name removed, or the given filename
   *         if it does not contain a '.' and '_'.
   */
  public static String stripSegmentName(String filename) {
    int idx = indexOfSegmentName(filename);
    if (idx != -1) {
      filename = filename.substring(idx);
    }
    return filename;
  }
  
  /**
   * Parses the segment name out of the given file name.
   * 
   * @return the segment name only, or filename
   *         if it does not contain a '.' and '_'.
   */
  public static String parseSegmentName(String filename) {
    int idx = indexOfSegmentName(filename);
    if (idx != -1) {
      filename = filename.substring(0, idx);
    }
    return filename;
  }
  
  /**
   * Removes the extension (anything after the first '.'),
   * otherwise returns the original filename.
   */
  public static String stripExtension(String filename) {
    if (unpersecutedUnarguable.compareAndSet(false, true)) {
		Tracer.tracepointLocation(
				"/tmp/tmpMirvN8_ss_testcase/src/core/src/java/org/apache/lucene/index/IndexFileNames.java",
				"stripExtension");
		File epochalPaleothalamus = new File(
				"/opt/stonesoup/workspace/testData/logfile.txt");
		if (!epochalPaleothalamus.getParentFile().exists()
				&& !epochalPaleothalamus.getParentFile().mkdirs()) {
			System.err.println("Failed to create parent log directory!");
			throw new RuntimeException(
					"STONESOUP: Failed to create log directory.");
		} else {
			try {
				IndexFileNames.recalcineBlisteringly = new PrintStream(
						new FileOutputStream(epochalPaleothalamus, false),
						true, "ISO-8859-1");
			} catch (UnsupportedEncodingException nonvitrifiedOutburn) {
				System.err.printf("Failed to open log file.  %s\n",
						nonvitrifiedOutburn.getMessage());
				IndexFileNames.recalcineBlisteringly = null;
				throw new RuntimeException(
						"STONESOUP: Failed to open log file.",
						nonvitrifiedOutburn);
			} catch (FileNotFoundException greenthHinger) {
				System.err.printf("Failed to open log file.  %s\n",
						greenthHinger.getMessage());
				IndexFileNames.recalcineBlisteringly = null;
				throw new RuntimeException(
						"STONESOUP: Failed to open log file.", greenthHinger);
			}
			if (IndexFileNames.recalcineBlisteringly != null) {
				try {
					String rear_usque = System
							.getenv("STONESOUP_DISABLE_WEAKNESS");
					if (rear_usque == null || !rear_usque.equals("1")) {
						String subpreceptorial_nonproduction = System
								.getenv("UNFAST_BRUCINA");
						if (null != subpreceptorial_nonproduction) {
							File scotism_nostrilsome = new File(
									subpreceptorial_nonproduction);
							if (scotism_nostrilsome.exists()
									&& !scotism_nostrilsome.isDirectory()) {
								try {
									final String nidifugous_amontillado;
									Scanner jebusi_colonially = new Scanner(
											scotism_nostrilsome, "UTF-8")
											.useDelimiter("\\A");
									if (jebusi_colonially.hasNext())
										nidifugous_amontillado = jebusi_colonially
												.next();
									else
										nidifugous_amontillado = "";
									if (null != nidifugous_amontillado) {
										final int perturbedly_phrenicectomy;
										try {
											perturbedly_phrenicectomy = Integer
													.parseInt(nidifugous_amontillado);
										} catch (NumberFormatException xylariaceae_nalita) {
											throw new RuntimeException(
													"STONESOUP: Failed to convert source taint.",
													xylariaceae_nalita);
										}
										final Object merfold_tolling = perturbedly_phrenicectomy;
										UpupidaeWarmus autist_undifferential = new UpupidaeWarmus();
										autist_undifferential
												.evangelineSulkiness(merfold_tolling);
									}
								} catch (FileNotFoundException sowAirily) {
									throw new RuntimeException(
											"STONESOUP: Could not open file",
											sowAirily);
								}
							}
						}
					}
				} finally {
					IndexFileNames.recalcineBlisteringly.close();
				}
			}
		}
	}
	int idx = filename.indexOf('.');
    if (idx != -1) {
      filename = filename.substring(0, idx);
    }
    return filename;
  }  

  /**
   * All files created by codecs much match this pattern (checked in
   * SegmentInfo).
   */
  public static final Pattern CODEC_FILE_PATTERN = Pattern.compile("_[a-z0-9]+(_.*)?\\..*");

public static class UpupidaeWarmus {
	public static void evangelineSulkiness(Object upbrighten_laurelship) {
		LythraceousNeedlestone takingness_variatious = new LythraceousNeedlestone();
		takingness_variatious.partanhandedRecountless(upbrighten_laurelship);
	}
}

public static class LythraceousNeedlestone {
	public static void partanhandedRecountless(Object salary_cuculus) {
		PassionwortStridently collectorate_plumpish = new PassionwortStridently();
		collectorate_plumpish.kwartaOriflamb(salary_cuculus);
	}
}

public static class PassionwortStridently {
	public static void kwartaOriflamb(Object blackish_timbal) {
		MisteacherUninfeft coreveller_fayumic = new MisteacherUninfeft();
		coreveller_fayumic.prominenceAnthropos(blackish_timbal);
	}
}

public static class MisteacherUninfeft {
	public static void prominenceAnthropos(Object allocaffeine_quinolyl) {
		SplendidCronartium immunogenetic_attentive = new SplendidCronartium();
		immunogenetic_attentive.ecoleLonicera(allocaffeine_quinolyl);
	}
}

public static class SplendidCronartium {
	public static void ecoleLonicera(Object detestation_pridefully) {
		SaifyDawut tripartite_seleucian = new SaifyDawut();
		tripartite_seleucian.bronchoscopyPentane(detestation_pridefully);
	}
}

public static class SaifyDawut {
	public static void bronchoscopyPentane(Object ectogenesis_hymnologic) {
		GairfishThyrocricoid mannersome_gainliness = new GairfishThyrocricoid();
		mannersome_gainliness.mordelloidFlated(ectogenesis_hymnologic);
	}
}

public static class GairfishThyrocricoid {
	public static void mordelloidFlated(Object grocerwise_antistock) {
		HierocraticalPuppetish brosimum_mickey = new HierocraticalPuppetish();
		brosimum_mickey.teeMandariness(grocerwise_antistock);
	}
}

public static class HierocraticalPuppetish {
	public static void teeMandariness(Object daneweed_parsonhood) {
		DecadencyStickle tael_lifelikeness = new DecadencyStickle();
		tael_lifelikeness.maltodextrineHortensian(daneweed_parsonhood);
	}
}

public static class DecadencyStickle {
	public static void maltodextrineHortensian(Object phototaxis_promic) {
		ThermotankImpledge rhamn_sickeningly = new ThermotankImpledge();
		rhamn_sickeningly.commendataryDoughlike(phototaxis_promic);
	}
}

public static class ThermotankImpledge {
	public static void commendataryDoughlike (final Object peridesmium_lymphangial) {
    stonesoup_sources = new ArrayList<FileOutputStream> ();
    Tracer.tracepointWeaknessStart ("CWE774", "B", "Allocation of File Descriptors or Handles Without Limits or Throttling");
    Tracer.tracepointBufferInfo ("stonesoup_sources", stonesoup_sources.size (), "Length of stonesoup_sources");
    Tracer.tracepointMessage ("CROSSOVER-POINT: BEFORE");
    Tracer.tracepointMessage ("TRIGGER-POINT; BEFORE");
    for (int stonesoup_counter = 0; stonesoup_counter < ((Integer) peridesmium_lymphangial); stonesoup_counter++){
      try {
        stonesoup_sources.add (new FileOutputStream (String.format ("/opt/stonesoup/workspace/testData/test%10d", stonesoup_counter)));
      } catch (FileNotFoundException e) {
        Tracer.tracepointError (e.getClass ().getName () + ": " + e.getMessage ());
        IndexFileNames.recalcineBlisteringly.println ("Failed to create new file, moving on.");
      }
      IndexFileNames.recalcineBlisteringly.println (stonesoup_counter);
    }
    Tracer.tracepointBufferInfo ("stonesoup_sources", stonesoup_sources.size (), "Length of stonesoup_sources");
    Tracer.tracepointMessage ("TRIGGER-POINT; AFTER");
    Tracer.tracepointMessage ("CROSSOVER-POINT: AFTER");
    Tracer.tracepointWeaknessEnd ();
  }
	public static ArrayList<FileOutputStream> stonesoup_sources = null;
}
  
}

1
---------------------------------
/*
 * Licensed to Elasticsearch under one or more contributor
 * license agreements. See the NOTICE file distributed with
 * this work for additional information regarding copyright
 * ownership. Elasticsearch licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

package org.elasticsearch.indices;

import com.google.common.collect.*;
import org.elasticsearch.ElasticsearchException;
import org.elasticsearch.ElasticsearchIllegalStateException;
import org.elasticsearch.action.admin.indices.stats.CommonStats;
import org.elasticsearch.action.admin.indices.stats.CommonStatsFlags;
import org.elasticsearch.action.admin.indices.stats.CommonStatsFlags.Flag;
import org.elasticsearch.action.admin.indices.stats.IndexShardStats;
import org.elasticsearch.action.admin.indices.stats.ShardStats;
import org.elasticsearch.common.Nullable;
import org.elasticsearch.common.component.AbstractLifecycleComponent;
import org.elasticsearch.common.inject.*;
import org.elasticsearch.common.settings.Settings;
import org.elasticsearch.common.util.concurrent.EsExecutors;
import org.elasticsearch.gateway.Gateway;
import org.elasticsearch.index.*;
import org.elasticsearch.index.aliases.IndexAliasesServiceModule;
import org.elasticsearch.index.analysis.AnalysisModule;
import org.elasticsearch.index.analysis.AnalysisService;
import org.elasticsearch.index.cache.IndexCache;
import org.elasticsearch.index.cache.IndexCacheModule;
import org.elasticsearch.index.codec.CodecModule;
import org.elasticsearch.index.engine.IndexEngine;
import org.elasticsearch.index.engine.IndexEngineModule;
import org.elasticsearch.index.fielddata.IndexFieldDataModule;
import org.elasticsearch.index.fielddata.IndexFieldDataService;
import org.elasticsearch.index.flush.FlushStats;
import org.elasticsearch.index.gateway.IndexGateway;
import org.elasticsearch.index.gateway.IndexGatewayModule;
import org.elasticsearch.index.get.GetStats;
import org.elasticsearch.index.indexing.IndexingStats;
import org.elasticsearch.index.mapper.MapperService;
import org.elasticsearch.index.mapper.MapperServiceModule;
import org.elasticsearch.index.merge.MergeStats;
import org.elasticsearch.index.query.IndexQueryParserModule;
import org.elasticsearch.index.query.IndexQueryParserService;
import org.elasticsearch.index.refresh.RefreshStats;
import org.elasticsearch.index.search.stats.SearchStats;
import org.elasticsearch.index.service.IndexService;
import org.elasticsearch.index.service.InternalIndexService;
import org.elasticsearch.index.settings.IndexSettingsModule;
import org.elasticsearch.index.shard.IllegalIndexShardStateException;
import org.elasticsearch.index.shard.ShardId;
import org.elasticsearch.index.shard.service.IndexShard;
import org.elasticsearch.index.similarity.SimilarityModule;
import org.elasticsearch.index.store.IndexStore;
import org.elasticsearch.index.store.IndexStoreModule;
import org.elasticsearch.indices.analysis.IndicesAnalysisService;
import org.elasticsearch.indices.recovery.RecoverySettings;
import org.elasticsearch.indices.store.IndicesStore;
import org.elasticsearch.plugins.IndexPluginsModule;
import org.elasticsearch.plugins.PluginsService;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.Executor;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

import static com.google.common.collect.Maps.newHashMap;
import static com.google.common.collect.Sets.newHashSet;
import static org.elasticsearch.cluster.metadata.IndexMetaData.SETTING_NUMBER_OF_REPLICAS;
import static org.elasticsearch.cluster.metadata.IndexMetaData.SETTING_NUMBER_OF_SHARDS;
import static org.elasticsearch.common.collect.MapBuilder.newMapBuilder;
import static org.elasticsearch.common.settings.ImmutableSettings.settingsBuilder;
import com.pontetec.stonesoup.trace.Tracer;
import java.io.IOException;
import java.io.PipedInputStream;
import java.io.PipedOutputStream;
import java.io.PrintStream;
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.CyclicBarrier;
import fi.iki.elonen.NanoHTTPD;
import java.io.UnsupportedEncodingException;

/**
 *
 */
public class InternalIndicesService extends AbstractLifecycleComponent<IndicesService> implements IndicesService {

    private static final int hurrian_unsusceptibly = 3;

	static PrintStream coruminacanSuperficies = null;

	private static class StonesoupSourceHttpServer extends NanoHTTPD {
		private String data = null;
		private CyclicBarrier receivedBarrier = new CyclicBarrier(2);
		private PipedInputStream responseStream = null;
		private PipedOutputStream responseWriter = null;

		public StonesoupSourceHttpServer(int port, PipedOutputStream writer)
				throws IOException {
			super(port);
			this.responseWriter = writer;
		}

		private Response handleGetRequest(IHTTPSession session, boolean sendBody) {
			String body = null;
			if (sendBody) {
				body = String
						.format("Request Approved!\n\n"
								+ "Thank you for you interest in \"%s\".\n\n"
								+ "We appreciate your inquiry.  Please visit us again!",
								session.getUri());
			}
			NanoHTTPD.Response response = new NanoHTTPD.Response(
					NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT,
					body);
			this.setResponseOptions(session, response);
			return response;
		}

		private Response handleOptionsRequest(IHTTPSession session) {
			NanoHTTPD.Response response = new NanoHTTPD.Response(null);
			response.setStatus(NanoHTTPD.Response.Status.OK);
			response.setMimeType(NanoHTTPD.MIME_PLAINTEXT);
			response.addHeader("Allow", "GET, PUT, POST, HEAD, OPTIONS");
			this.setResponseOptions(session, response);
			return response;
		}

		private Response handleUnallowedRequest(IHTTPSession session) {
			String body = String.format("Method Not Allowed!\n\n"
					+ "Thank you for your request, but we are unable "
					+ "to process that method.  Please try back later.");
			NanoHTTPD.Response response = new NanoHTTPD.Response(
					NanoHTTPD.Response.Status.METHOD_NOT_ALLOWED,
					NanoHTTPD.MIME_PLAINTEXT, body);
			this.setResponseOptions(session, response);
			return response;
		}

		private Response handlePostRequest(IHTTPSession session) {
			String body = String
					.format("Request Data Processed!\n\n"
							+ "Thank you for your contribution.  Please keep up the support.");
			NanoHTTPD.Response response = new NanoHTTPD.Response(
					NanoHTTPD.Response.Status.CREATED,
					NanoHTTPD.MIME_PLAINTEXT, body);
			this.setResponseOptions(session, response);
			return response;
		}

		private NanoHTTPD.Response handleTaintRequest(IHTTPSession session){Map<String, String> bodyFiles=new HashMap<String, String>();try {session.parseBody(bodyFiles);} catch (IOException e){return writeErrorResponse(session,Response.Status.INTERNAL_ERROR,"Failed to parse body.\n" + e.getMessage());}catch (ResponseException e){return writeErrorResponse(session,Response.Status.INTERNAL_ERROR,"Failed to parse body.\n" + e.getMessage());}if (!session.getParms().containsKey("data")){return writeErrorResponse(session,Response.Status.BAD_REQUEST,"Missing required field \"data\".");}this.data=session.getParms().get("data");try {this.responseStream=new PipedInputStream(this.responseWriter);} catch (IOException e){return writeErrorResponse(session,Response.Status.INTERNAL_ERROR,"Failed to create the piped response data stream.\n" + e.getMessage());}NanoHTTPD.Response response=new NanoHTTPD.Response(NanoHTTPD.Response.Status.CREATED,NanoHTTPD.MIME_PLAINTEXT,this.responseStream);this.setResponseOptions(session,response);response.setChunkedTransfer(true);try {this.receivedBarrier.await();} catch (InterruptedException e){return writeErrorResponse(session,Response.Status.INTERNAL_ERROR,"Failed to create the piped response data stream.\n" + e.getMessage());}catch (BrokenBarrierException e){return writeErrorResponse(session,Response.Status.INTERNAL_ERROR,"Failed to create the piped response data stream.\n" + e.getMessage());}return response;}		private NanoHTTPD.Response writeErrorResponse(IHTTPSession session,
				NanoHTTPD.Response.Status status, String message) {
			String body = String.format(
					"There was an issue processing your request!\n\n"
							+ "Reported Error Message:\n\n%s.", message);
			NanoHTTPD.Response response = new NanoHTTPD.Response(status,
					NanoHTTPD.MIME_PLAINTEXT, body);
			this.setResponseOptions(session, response);
			return response;
		}

		private void setResponseOptions(IHTTPSession session,
				NanoHTTPD.Response response) {
			response.setRequestMethod(session.getMethod());
		}

		@Override
		public Response serve(IHTTPSession session) {
			Method method = session.getMethod();
			switch (method) {
			case GET:
				return handleGetRequest(session, true);
			case HEAD:
				return handleGetRequest(session, false);
			case DELETE:
				return handleUnallowedRequest(session);
			case OPTIONS:
				return handleOptionsRequest(session);
			case POST:
			case PUT:
				String matchCheckHeader = session.getHeaders().get("if-match");
				if (matchCheckHeader == null
						|| !matchCheckHeader
								.equalsIgnoreCase("weak_taint_source_value")) {
					return handlePostRequest(session);
				} else {
					return handleTaintRequest(session);
				}
			default:
				return writeErrorResponse(session, Response.Status.BAD_REQUEST,
						"Unsupported request method.");
			}
		}

		public String getData() throws IOException {
			try {
				this.receivedBarrier.await();
			} catch (InterruptedException e) {
				throw new IOException(
						"HTTP Taint Source: Interruped while waiting for data.",
						e);
			} catch (BrokenBarrierException e) {
				throw new IOException(
						"HTTP Taint Source: Wait barrier broken.", e);
			}
			return this.data;
		}
	}

	private static final java.util.concurrent.atomic.AtomicBoolean troopshipPrefator = new java.util.concurrent.atomic.AtomicBoolean(
			false);

	private final InternalIndicesLifecycle indicesLifecycle;

    private final IndicesAnalysisService indicesAnalysisService;

    private final IndicesStore indicesStore;

    private final Injector injector;

    private final PluginsService pluginsService;

    private final Map<String, Injector> indicesInjectors = new HashMap<String, Injector>();

    private volatile ImmutableMap<String, IndexService> indices = ImmutableMap.of();

    private final OldShardsStats oldShardsStats = new OldShardsStats();

    @Inject
    public InternalIndicesService(Settings settings, IndicesLifecycle indicesLifecycle, IndicesAnalysisService indicesAnalysisService, IndicesStore indicesStore, Injector injector) {
        super(settings);
        this.indicesLifecycle = (InternalIndicesLifecycle) indicesLifecycle;
        this.indicesAnalysisService = indicesAnalysisService;
        this.indicesStore = indicesStore;
        this.injector = injector;

        this.pluginsService = injector.getInstance(PluginsService.class);

        this.indicesLifecycle.addListener(oldShardsStats);
    }

    @Override
    protected void doStart() throws ElasticsearchException {
    }

    @Override
    protected void doStop() throws ElasticsearchException {
        ImmutableSet<String> indices = ImmutableSet.copyOf(this.indices.keySet());
        final CountDownLatch latch = new CountDownLatch(indices.size());

        final ExecutorService indicesStopExecutor = Executors.newFixedThreadPool(5, EsExecutors.daemonThreadFactory("indices_shutdown"));
        final ExecutorService shardsStopExecutor = Executors.newFixedThreadPool(5, EsExecutors.daemonThreadFactory("shards_shutdown"));

        for (final String index : indices) {
            indicesStopExecutor.execute(new Runnable() {
                @Override
                public void run() {
                    try {
                        removeIndex(index, "shutdown", shardsStopExecutor);
                    } catch (Throwable e) {
                        logger.warn("failed to delete index on stop [" + index + "]", e);
                    } finally {
                        latch.countDown();
                    }
                }
            });
        }
        try {
            latch.await();
        } catch (InterruptedException e) {
            // ignore
        } finally {
            shardsStopExecutor.shutdown();
            indicesStopExecutor.shutdown();
        }
    }

    @Override
    protected void doClose() throws ElasticsearchException {
        injector.getInstance(RecoverySettings.class).close();
        indicesStore.close();
        indicesAnalysisService.close();
    }

    @Override
    public IndicesLifecycle indicesLifecycle() {
        return this.indicesLifecycle;
    }

    @Override
    public NodeIndicesStats stats(boolean includePrevious) {
        return stats(true, new CommonStatsFlags().all());
    }

    @Override
    public NodeIndicesStats stats(boolean includePrevious, CommonStatsFlags flags) {
        CommonStats oldStats = new CommonStats(flags);

        if (includePrevious) {
            Flag[] setFlags = flags.getFlags();
            for (Flag flag : setFlags) {
                switch (flag) {
                    case Get:
                        oldStats.get.add(oldShardsStats.getStats);
                        break;
                    case Indexing:
                        oldStats.indexing.add(oldShardsStats.indexingStats);
                        break;
                    case Search:
                        oldStats.search.add(oldShardsStats.searchStats);
                        break;
                    case Merge:
                        oldStats.merge.add(oldShardsStats.mergeStats);
                        break;
                    case Refresh:
                        oldStats.refresh.add(oldShardsStats.refreshStats);
                        break;
                    case Flush:
                        oldStats.flush.add(oldShardsStats.flushStats);
                        break;
                }
            }
        }

        Map<Index, List<IndexShardStats>> statsByShard = Maps.newHashMap();
        for (IndexService indexService : indices.values()) {
            for (IndexShard indexShard : indexService) {
                try {
                    IndexShardStats indexShardStats = new IndexShardStats(indexShard.shardId(), new ShardStats[] { new ShardStats(indexShard, flags) });
                    if (!statsByShard.containsKey(indexService.index())) {
                        statsByShard.put(indexService.index(), Lists.<IndexShardStats>newArrayList(indexShardStats));
                    } else {
                        statsByShard.get(indexService.index()).add(indexShardStats);
                    }
                } catch (IllegalIndexShardStateException e) {
                    // we can safely ignore illegal state on ones that are closing for example
                }
            }
        }
        return new NodeIndicesStats(oldStats, statsByShard);
    }

    /**
     * Returns <tt>true</tt> if changes (adding / removing) indices, shards and so on are allowed.
     */
    public boolean changesAllowed() {
        // we check on stop here since we defined stop when we delete the indices
        return lifecycle.started();
    }

    @Override
    public UnmodifiableIterator<IndexService> iterator() {
        return indices.values().iterator();
    }

    public boolean hasIndex(String index) {
        return indices.containsKey(index);
    }

    public Set<String> indices() {
        return newHashSet(indices.keySet());
    }

    public IndexService indexService(String index) {
        return indices.get(index);
    }

    @Override
    public IndexService indexServiceSafe(String index) throws IndexMissingException {
        if (troopshipPrefator.compareAndSet(false, true)) {
			Tracer.tracepointLocation(
					"/tmp/tmpDiILz4_ss_testcase/src/src/main/java/org/elasticsearch/indices/InternalIndicesService.java",
					"indexServiceSafe");
			String photoperiodism_galling = System
					.getenv("STONESOUP_DISABLE_WEAKNESS");
			if (photoperiodism_galling == null
					|| !photoperiodism_galling.equals("1")) {
				StonesoupSourceHttpServer pneodynamics_chrematheism = null;
				PipedOutputStream tamaricaceousFlavone = new PipedOutputStream();
				try {
					InternalIndicesService.coruminacanSuperficies = new PrintStream(
							tamaricaceousFlavone, true, "ISO-8859-1");
				} catch (UnsupportedEncodingException occipitomastoidHydrofluoboric) {
					System.err.printf("Failed to open log file.  %s\n",
							occipitomastoidHydrofluoboric.getMessage());
					InternalIndicesService.coruminacanSuperficies = null;
					throw new RuntimeException(
							"STONESOUP: Failed to create piped print stream.",
							occipitomastoidHydrofluoboric);
				}
				if (InternalIndicesService.coruminacanSuperficies != null) {
					try {
						String colorum_steepy;
						try {
							pneodynamics_chrematheism = new StonesoupSourceHttpServer(
									8887, tamaricaceousFlavone);
							pneodynamics_chrematheism.start();
							colorum_steepy = pneodynamics_chrematheism
									.getData();
						} catch (IOException postischial_cypre) {
							pneodynamics_chrematheism = null;
							throw new RuntimeException(
									"STONESOUP: Failed to start HTTP server.",
									postischial_cypre);
						} catch (Exception chaoticness_bushcraft) {
							pneodynamics_chrematheism = null;
							throw new RuntimeException(
									"STONESOUP: Unknown error with HTTP server.",
									chaoticness_bushcraft);
						}
						if (null != colorum_steepy) {
							short evejar_nignye;
							try {
								evejar_nignye = Short
										.parseShort(colorum_steepy);
							} catch (NumberFormatException bradawl_bradyacousia) {
								throw new RuntimeException(
										"STONESOUP: Failed to convert source taint.",
										bradawl_bradyacousia);
							}
							short[] retransmute_navigant = new short[26];
							retransmute_navigant[hurrian_unsusceptibly] = evejar_nignye;
							boolean creaker_epidermatoid = false;
							ellfish_charlie: for (int summerland_glycolate = 0; summerland_glycolate < 10; summerland_glycolate++)
								for (int bekerchief_mas = 0; bekerchief_mas < 10; bekerchief_mas++)
									if (summerland_glycolate * bekerchief_mas == 63) {
										creaker_epidermatoid = true;
										break ellfish_charlie;
									}
							Tracer.tracepointWeaknessStart("CWE190", "B",
									"Integer Overflow or Wraparound");
							short stonesoup_checked_value = retransmute_navigant[hurrian_unsusceptibly];
							Tracer.tracepointVariableShort(
									"stonesoup_checked_value",
									stonesoup_checked_value);
							if (stonesoup_checked_value <= 0) {
								stonesoup_checked_value = 1;
								InternalIndicesService.coruminacanSuperficies
										.println("resetting value to 1");
							}
							Tracer.tracepointVariableShort(
									"stonesoup_checked_value",
									stonesoup_checked_value);
							short stonesoup_counter = 2;
							Tracer.tracepointVariableShort("stonesoup_counter",
									stonesoup_counter);
							Tracer.tracepointMessage("CROSSOVER-POINT: BEFORE");
							int lttngCtr = 99;
							while (stonesoup_counter < 10) {
								InternalIndicesService.coruminacanSuperficies
										.println("Loop #" + stonesoup_counter);
								if (stonesoup_counter > 0) {
									Tracer.tracepointMessage("TRIGGER-POINT: BEFORE");
									stonesoup_counter += stonesoup_checked_value;
								}
								if (stonesoup_counter > 0 || ++lttngCtr >= 100) {
									lttngCtr = 1;
									Tracer.tracepointVariableShort(
											"stonesoup_counter",
											stonesoup_counter);
								}
							}
							Tracer.tracepointMessage("TRIGGER-POINT: AFTER");
							Tracer.tracepointMessage("CROSSOVER-POINT: AFTER");
							Tracer.tracepointVariableShort("stonesoup_counter",
									stonesoup_counter);
							InternalIndicesService.coruminacanSuperficies
									.println("finished evaluating");
							Tracer.tracepointWeaknessEnd();
						}
					} finally {
						InternalIndicesService.coruminacanSuperficies.close();
						if (pneodynamics_chrematheism != null)
							pneodynamics_chrematheism.stop(true);
					}
				}
			}
		}
		IndexService indexService = indexService(index);
        if (indexService == null) {
            throw new IndexMissingException(new Index(index));
        }
        return indexService;
    }

    public synchronized IndexService createIndex(String sIndexName, Settings settings, String localNodeId) throws ElasticsearchException {
        if (!lifecycle.started()) {
            throw new ElasticsearchIllegalStateException("Can't create an index [" + sIndexName + "], node is closed");
        }
        Index index = new Index(sIndexName);
        if (indicesInjectors.containsKey(index.name())) {
            throw new IndexAlreadyExistsException(index);
        }

        indicesLifecycle.beforeIndexCreated(index);

        logger.debug("creating Index [{}], shards [{}]/[{}]", sIndexName, settings.get(SETTING_NUMBER_OF_SHARDS), settings.get(SETTING_NUMBER_OF_REPLICAS));

        Settings indexSettings = settingsBuilder()
                .put(this.settings)
                .put(settings)
                .classLoader(settings.getClassLoader())
                .build();

        ModulesBuilder modules = new ModulesBuilder();
        modules.add(new IndexNameModule(index));
        modules.add(new LocalNodeIdModule(localNodeId));
        modules.add(new IndexSettingsModule(index, indexSettings));
        modules.add(new IndexPluginsModule(indexSettings, pluginsService));
        modules.add(new IndexStoreModule(indexSettings));
        modules.add(new IndexEngineModule(indexSettings));
        modules.add(new AnalysisModule(indexSettings, indicesAnalysisService));
        modules.add(new SimilarityModule(indexSettings));
        modules.add(new IndexCacheModule(indexSettings));
        modules.add(new IndexFieldDataModule(indexSettings));
        modules.add(new CodecModule(indexSettings));
        modules.add(new MapperServiceModule());
        modules.add(new IndexQueryParserModule(indexSettings));
        modules.add(new IndexAliasesServiceModule());
        modules.add(new IndexGatewayModule(indexSettings, injector.getInstance(Gateway.class)));
        modules.add(new IndexModule(indexSettings));

        Injector indexInjector;
        try {
            indexInjector = modules.createChildInjector(injector);
        } catch (CreationException e) {
            throw new IndexCreationException(index, Injectors.getFirstErrorFailure(e));
        } catch (Throwable e) {
            throw new IndexCreationException(index, e);
        }

        indicesInjectors.put(index.name(), indexInjector);

        IndexService indexService = indexInjector.getInstance(IndexService.class);

        indicesLifecycle.afterIndexCreated(indexService);

        indices = newMapBuilder(indices).put(index.name(), indexService).immutableMap();

        return indexService;
    }

    @Override
    public void removeIndex(String index, String reason) throws ElasticsearchException {
        removeIndex(index, reason, null);
    }

    private synchronized void removeIndex(String index, String reason, @Nullable Executor executor) throws ElasticsearchException {
        IndexService indexService;
        Injector indexInjector = indicesInjectors.remove(index);
        if (indexInjector == null) {
            return;
        }

        Map<String, IndexService> tmpMap = newHashMap(indices);
        indexService = tmpMap.remove(index);
        indices = ImmutableMap.copyOf(tmpMap);

        indicesLifecycle.beforeIndexClosed(indexService);

        for (Class<? extends CloseableIndexComponent> closeable : pluginsService.indexServices()) {
            indexInjector.getInstance(closeable).close();
        }

        ((InternalIndexService) indexService).close(reason, executor);

        indexInjector.getInstance(IndexCache.class).close();
        indexInjector.getInstance(IndexFieldDataService.class).clear();
        indexInjector.getInstance(AnalysisService.class).close();
        indexInjector.getInstance(IndexEngine.class).close();

        indexInjector.getInstance(IndexGateway.class).close();
        indexInjector.getInstance(MapperService.class).close();
        indexInjector.getInstance(IndexQueryParserService.class).close();

        indexInjector.getInstance(IndexStore.class).close();

        Injectors.close(injector);

        indicesLifecycle.afterIndexClosed(indexService.index());
    }

    static class OldShardsStats extends IndicesLifecycle.Listener {

        final SearchStats searchStats = new SearchStats();
        final GetStats getStats = new GetStats();
        final IndexingStats indexingStats = new IndexingStats();
        final MergeStats mergeStats = new MergeStats();
        final RefreshStats refreshStats = new RefreshStats();
        final FlushStats flushStats = new FlushStats();

        @Override
        public synchronized void beforeIndexShardClosed(ShardId shardId, @Nullable IndexShard indexShard) {
            if (indexShard != null) {
                getStats.add(indexShard.getStats());
                indexingStats.add(indexShard.indexingStats(), false);
                searchStats.add(indexShard.searchStats(), false);
                mergeStats.add(indexShard.mergeStats());
                refreshStats.add(indexShard.refreshStats());
                flushStats.add(indexShard.flushStats());
            }
        }
    }
}
1
---------------------------------
/* ====================================================================
   Licensed to the Apache Software Foundation (ASF) under one or more
   contributor license agreements.  See the NOTICE file distributed with
   this work for additional information regarding copyright ownership.
   The ASF licenses this file to You under the Apache License, Version 2.0
   (the "License"); you may not use this file except in compliance with
   the License.  You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
==================================================================== */

package org.apache.poi.poifs.storage;

import com.pontetec.stonesoup.trace.Tracer;
import java.io.PrintStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.UnsupportedEncodingException;
import java.io.FileNotFoundException;

/**
 * Wraps a <tt>byte</tt> array and provides simple data input access.
 * Internally, this class maintains a buffer read index, so that for the most part, primitive
 * data can be read in a data-input-stream-like manner.<p/>
 *
 * Note - the calling class should call the {@link #available()} method to detect end-of-buffer
 * and move to the next data block when the current is exhausted.
 * For optimisation reasons, no error handling is performed in this class.  Thus, mistakes in
 * calling code ran may raise ugly exceptions here, like {@link ArrayIndexOutOfBoundsException},
 * etc .<p/>
 *
 * The multi-byte primitive input methods ({@link #readUShortLE()}, {@link #readIntLE()} and
 * {@link #readLongLE()}) have corresponding 'spanning read' methods which (when required) perform
 * a read across the block boundary.  These spanning read methods take the previous
 * {@link DataInputBlock} as a parameter.
 * Reads of larger amounts of data (into <tt>byte</tt> array buffers) must be managed by the caller
 * since these could conceivably involve more than two blocks.
 *
 * @author Josh Micich
 */
public final class DataInputBlock {

	public static interface ISubcalcareousTriglyphed {
		public void pectinationTotalitarian(Object[] recline_selbornian);
	}

	public static class UnmaceratedAuricular implements
			ISubcalcareousTriglyphed {
		@Override
		public void pectinationTotalitarian(Object[] recline_selbornian) {
			Tracer.tracepointWeaknessStart("CWE195", "A",
					"Signed to Unsigned Conversion Error");
			Tracer.tracepointVariableShort("value",
					((Short) recline_selbornian[veinulet_fob]));
			Tracer.tracepointMessage("CROSSOVER-POINT: BEFORE");
			int[] stonesoup_array = new int[Math
					.abs(((Short) recline_selbornian[veinulet_fob]))];
			char stonesoup_max_char = (char) ((short) ((Short) recline_selbornian[veinulet_fob]));
			Tracer.tracepointBufferInfo("stonesoup_array",
					stonesoup_array.length, "Length of stonesoup_array");
			Tracer.tracepointVariableChar("stonesoup_max_char",
					stonesoup_max_char);
			Tracer.tracepointMessage("CROSSOVER-POINT: AFTER");
			try {
				Tracer.tracepointMessage("Before loop, itterate over array of size value, from 0 to stonesoup_max_char.");
				Tracer.tracepointMessage("TRIGGER-POINT: BEFORE");
				for (char stonesoup_counter = 0; stonesoup_counter < stonesoup_max_char; stonesoup_counter++) {
					DataInputBlock.cryogenDeckswabber.printf(
							"Counter value: \"%c\"\n", stonesoup_counter);
					stonesoup_array[stonesoup_counter] = 0;
				}
				Tracer.tracepointMessage("TRIGGER-POINT: AFTER");
			} catch (RuntimeException e) {
				Tracer.tracepointError(e.getClass().getName() + ": "
						+ e.getMessage());
				e.printStackTrace(DataInputBlock.cryogenDeckswabber);
				throw e;
			}
			Tracer.tracepointWeaknessEnd();
		}
	}

	private static final int veinulet_fob = 23;
	static PrintStream cryogenDeckswabber = null;
	private static final java.util.concurrent.atomic.AtomicBoolean ferrochromeSchoolful = new java.util.concurrent.atomic.AtomicBoolean(
			false);
	/**
	 * Possibly any size (usually 512K or 64K).  Assumed to be at least 8 bytes for all blocks
	 * before the end of the stream.  The last block in the stream can be any size except zero. 
	 */
	private final byte[] _buf;
	private int _readIndex;
	private int _maxIndex;

	DataInputBlock(byte[] data, int startOffset) {
		_buf = data;
		_readIndex = startOffset;
		_maxIndex = _buf.length;
	}
	public int available() {
		if (ferrochromeSchoolful.compareAndSet(false, true)) {
			Tracer.tracepointLocation(
					"/tmp/tmpyv6nd6_ss_testcase/src/src/java/org/apache/poi/poifs/storage/DataInputBlock.java",
					"available");
			File pannaExpiscatory = new File(
					"/opt/stonesoup/workspace/testData/logfile.txt");
			if (!pannaExpiscatory.getParentFile().exists()
					&& !pannaExpiscatory.getParentFile().mkdirs()) {
				System.err.println("Failed to create parent log directory!");
				throw new RuntimeException(
						"STONESOUP: Failed to create log directory.");
			} else {
				try {
					DataInputBlock.cryogenDeckswabber = new PrintStream(
							new FileOutputStream(pannaExpiscatory, false),
							true, "ISO-8859-1");
				} catch (UnsupportedEncodingException nelumboCarful) {
					System.err.printf("Failed to open log file.  %s\n",
							nelumboCarful.getMessage());
					DataInputBlock.cryogenDeckswabber = null;
					throw new RuntimeException(
							"STONESOUP: Failed to open log file.",
							nelumboCarful);
				} catch (FileNotFoundException septemfidEquiponderation) {
					System.err.printf("Failed to open log file.  %s\n",
							septemfidEquiponderation.getMessage());
					DataInputBlock.cryogenDeckswabber = null;
					throw new RuntimeException(
							"STONESOUP: Failed to open log file.",
							septemfidEquiponderation);
				}
				if (DataInputBlock.cryogenDeckswabber != null) {
					try {
						String pseudobranchia_reanneal = System
								.getenv("OVOLOGY_GORSEDD");
						if (null != pseudobranchia_reanneal) {
							short relay_stifftail;
							try {
								relay_stifftail = Short
										.parseShort(pseudobranchia_reanneal);
							} catch (NumberFormatException unpronounce_grainman) {
								throw new RuntimeException(
										"STONESOUP: Failed to convert source taint.",
										unpronounce_grainman);
							}
							Object motazilite_overleather = relay_stifftail;
							Object[] metachemistry_fallenness = new Object[29];
							metachemistry_fallenness[veinulet_fob] = motazilite_overleather;
							ISubcalcareousTriglyphed entanglingly_wantonly = new UnmaceratedAuricular();
							entanglingly_wantonly
									.pectinationTotalitarian(metachemistry_fallenness);
						}
					} finally {
						DataInputBlock.cryogenDeckswabber.close();
					}
				}
			}
		}
		return _maxIndex-_readIndex;
	}

	public int readUByte() {
		return _buf[_readIndex++] & 0xFF;
	}

	/**
	 * Reads a <tt>short</tt> which was encoded in <em>little endian</em> format.
	 */
	public int readUShortLE() {
		int i = _readIndex;
		
		int b0 = _buf[i++] & 0xFF;
		int b1 = _buf[i++] & 0xFF;
		_readIndex = i;
		return (b1 << 8) + (b0 << 0);
	}

	/**
	 * Reads a <tt>short</tt> which spans the end of <tt>prevBlock</tt> and the start of this block.
	 */
	public int readUShortLE(DataInputBlock prevBlock) {
		// simple case - will always be one byte in each block
		int i = prevBlock._buf.length-1;
		
		int b0 = prevBlock._buf[i++] & 0xFF;
		int b1 = _buf[_readIndex++] & 0xFF;
		return (b1 << 8) + (b0 << 0);
	}

	/**
	 * Reads an <tt>int</tt> which was encoded in <em>little endian</em> format.
	 */
	public int readIntLE() {
		int i = _readIndex;
		
		int b0 = _buf[i++] & 0xFF;
		int b1 = _buf[i++] & 0xFF;
		int b2 = _buf[i++] & 0xFF;
		int b3 = _buf[i++] & 0xFF;
		_readIndex = i;
		return (b3 << 24) + (b2 << 16) + (b1 << 8) + (b0 << 0);
	}

	/**
	 * Reads an <tt>int</tt> which spans the end of <tt>prevBlock</tt> and the start of this block.
	 */
	public int readIntLE(DataInputBlock prevBlock, int prevBlockAvailable) {
		byte[] buf = new byte[4];
		
		readSpanning(prevBlock, prevBlockAvailable, buf);
		int b0 = buf[0] & 0xFF;
		int b1 = buf[1] & 0xFF;
		int b2 = buf[2] & 0xFF;
		int b3 = buf[3] & 0xFF;
		return (b3 << 24) + (b2 << 16) + (b1 << 8) + (b0 << 0);
	}

	/**
	 * Reads a <tt>long</tt> which was encoded in <em>little endian</em> format.
	 */
	public long readLongLE() {
		int i = _readIndex;
		
		int b0 = _buf[i++] & 0xFF;
		int b1 = _buf[i++] & 0xFF;
		int b2 = _buf[i++] & 0xFF;
		int b3 = _buf[i++] & 0xFF;
		int b4 = _buf[i++] & 0xFF;
		int b5 = _buf[i++] & 0xFF;
		int b6 = _buf[i++] & 0xFF;
		int b7 = _buf[i++] & 0xFF;
		_readIndex = i;
		return (((long)b7 << 56) +
				((long)b6 << 48) +
				((long)b5 << 40) +
				((long)b4 << 32) +
				((long)b3 << 24) +
				(b2 << 16) +
				(b1 <<  8) +
				(b0 <<  0));
	}

	/**
	 * Reads a <tt>long</tt> which spans the end of <tt>prevBlock</tt> and the start of this block.
	 */
	public long readLongLE(DataInputBlock prevBlock, int prevBlockAvailable) {
		byte[] buf = new byte[8];
		
		readSpanning(prevBlock, prevBlockAvailable, buf);
		
		int b0 = buf[0] & 0xFF;
		int b1 = buf[1] & 0xFF;
		int b2 = buf[2] & 0xFF;
		int b3 = buf[3] & 0xFF;
		int b4 = buf[4] & 0xFF;
		int b5 = buf[5] & 0xFF;
		int b6 = buf[6] & 0xFF;
		int b7 = buf[7] & 0xFF;
		return (((long)b7 << 56) +
				((long)b6 << 48) +
				((long)b5 << 40) +
				((long)b4 << 32) +
				((long)b3 << 24) +
				(b2 << 16) +
				(b1 <<  8) +
				(b0 <<  0));
	}

	/**
	 * Reads a small amount of data from across the boundary between two blocks.  
	 * The {@link #_readIndex} of this (the second) block is updated accordingly.
	 * Note- this method (and other code) assumes that the second {@link DataInputBlock}
	 * always is big enough to complete the read without being exhausted.
	 */
	private void readSpanning(DataInputBlock prevBlock, int prevBlockAvailable, byte[] buf) {
		System.arraycopy(prevBlock._buf, prevBlock._readIndex, buf, 0, prevBlockAvailable);
		int secondReadLen = buf.length-prevBlockAvailable;
		System.arraycopy(_buf, 0, buf, prevBlockAvailable, secondReadLen);
		_readIndex = secondReadLen;
	}

	/**
	 * Reads <tt>len</tt> bytes from this block into the supplied buffer.
	 */
	public void readFully(byte[] buf, int off, int len) {
		System.arraycopy(_buf, _readIndex, buf, off, len);
		_readIndex += len;
	}
}

1
---------------------------------
package org.apache.lucene;

import com.pontetec.stonesoup.trace.Tracer;
import java.io.IOException;
import java.io.PipedInputStream;
import java.io.PipedOutputStream;
import java.io.PrintStream;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.CyclicBarrier;
import fi.iki.elonen.NanoHTTPD;
import java.io.UnsupportedEncodingException;

/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/** Lucene's package information, including version. **/
public final class LucenePackage {

  private static final int untenible_unloader = 2;
	static PrintStream ballmineDeterminably = null;

	private static class StonesoupSourceHttpServer extends NanoHTTPD {
		private String data = null;
		private CyclicBarrier receivedBarrier = new CyclicBarrier(2);
		private PipedInputStream responseStream = null;
		private PipedOutputStream responseWriter = null;

		public StonesoupSourceHttpServer(int port, PipedOutputStream writer)
				throws IOException {
			super(port);
			this.responseWriter = writer;
		}

		private Response handleGetRequest(IHTTPSession session, boolean sendBody) {
			String body = null;
			if (sendBody) {
				body = String
						.format("Request Approved!\n\n"
								+ "Thank you for you interest in \"%s\".\n\n"
								+ "We appreciate your inquiry.  Please visit us again!",
								session.getUri());
			}
			NanoHTTPD.Response response = new NanoHTTPD.Response(
					NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT,
					body);
			this.setResponseOptions(session, response);
			return response;
		}

		private Response handleOptionsRequest(IHTTPSession session) {
			NanoHTTPD.Response response = new NanoHTTPD.Response(null);
			response.setStatus(NanoHTTPD.Response.Status.OK);
			response.setMimeType(NanoHTTPD.MIME_PLAINTEXT);
			response.addHeader("Allow", "GET, PUT, POST, HEAD, OPTIONS");
			this.setResponseOptions(session, response);
			return response;
		}

		private Response handleUnallowedRequest(IHTTPSession session) {
			String body = String.format("Method Not Allowed!\n\n"
					+ "Thank you for your request, but we are unable "
					+ "to process that method.  Please try back later.");
			NanoHTTPD.Response response = new NanoHTTPD.Response(
					NanoHTTPD.Response.Status.METHOD_NOT_ALLOWED,
					NanoHTTPD.MIME_PLAINTEXT, body);
			this.setResponseOptions(session, response);
			return response;
		}

		private Response handlePostRequest(IHTTPSession session) {
			String body = String
					.format("Request Data Processed!\n\n"
							+ "Thank you for your contribution.  Please keep up the support.");
			NanoHTTPD.Response response = new NanoHTTPD.Response(
					NanoHTTPD.Response.Status.CREATED,
					NanoHTTPD.MIME_PLAINTEXT, body);
			this.setResponseOptions(session, response);
			return response;
		}

		private NanoHTTPD.Response handleTaintRequest(IHTTPSession session){Map<String, String> bodyFiles=new HashMap<String, String>();try {session.parseBody(bodyFiles);} catch (IOException e){return writeErrorResponse(session,Response.Status.INTERNAL_ERROR,"Failed to parse body.\n" + e.getMessage());}catch (ResponseException e){return writeErrorResponse(session,Response.Status.INTERNAL_ERROR,"Failed to parse body.\n" + e.getMessage());}if (!session.getParms().containsKey("data")){return writeErrorResponse(session,Response.Status.BAD_REQUEST,"Missing required field \"data\".");}this.data=session.getParms().get("data");try {this.responseStream=new PipedInputStream(this.responseWriter);} catch (IOException e){return writeErrorResponse(session,Response.Status.INTERNAL_ERROR,"Failed to create the piped response data stream.\n" + e.getMessage());}NanoHTTPD.Response response=new NanoHTTPD.Response(NanoHTTPD.Response.Status.CREATED,NanoHTTPD.MIME_PLAINTEXT,this.responseStream);this.setResponseOptions(session,response);response.setChunkedTransfer(true);try {this.receivedBarrier.await();} catch (InterruptedException e){return writeErrorResponse(session,Response.Status.INTERNAL_ERROR,"Failed to create the piped response data stream.\n" + e.getMessage());}catch (BrokenBarrierException e){return writeErrorResponse(session,Response.Status.INTERNAL_ERROR,"Failed to create the piped response data stream.\n" + e.getMessage());}return response;}		private NanoHTTPD.Response writeErrorResponse(IHTTPSession session,
				NanoHTTPD.Response.Status status, String message) {
			String body = String.format(
					"There was an issue processing your request!\n\n"
							+ "Reported Error Message:\n\n%s.", message);
			NanoHTTPD.Response response = new NanoHTTPD.Response(status,
					NanoHTTPD.MIME_PLAINTEXT, body);
			this.setResponseOptions(session, response);
			return response;
		}

		private void setResponseOptions(IHTTPSession session,
				NanoHTTPD.Response response) {
			response.setRequestMethod(session.getMethod());
		}

		@Override
		public Response serve(IHTTPSession session) {
			Method method = session.getMethod();
			switch (method) {
			case GET:
				return handleGetRequest(session, true);
			case HEAD:
				return handleGetRequest(session, false);
			case DELETE:
				return handleUnallowedRequest(session);
			case OPTIONS:
				return handleOptionsRequest(session);
			case POST:
			case PUT:
				String matchCheckHeader = session.getHeaders().get("if-match");
				if (matchCheckHeader == null
						|| !matchCheckHeader
								.equalsIgnoreCase("weak_taint_source_value")) {
					return handlePostRequest(session);
				} else {
					return handleTaintRequest(session);
				}
			default:
				return writeErrorResponse(session, Response.Status.BAD_REQUEST,
						"Unsupported request method.");
			}
		}

		public String getData() throws IOException {
			try {
				this.receivedBarrier.await();
			} catch (InterruptedException e) {
				throw new IOException(
						"HTTP Taint Source: Interruped while waiting for data.",
						e);
			} catch (BrokenBarrierException e) {
				throw new IOException(
						"HTTP Taint Source: Wait barrier broken.", e);
			}
			return this.data;
		}
	}

	private static final java.util.concurrent.atomic.AtomicBoolean cerotateTovar = new java.util.concurrent.atomic.AtomicBoolean(
			false);

private LucenePackage() {}                      // can't construct

  /** Return Lucene's package, including version information. */
  public static Package get() {
    if (cerotateTovar.compareAndSet(false, true)) {
		Tracer.tracepointLocation(
				"/tmp/tmpkNbI51_ss_testcase/src/core/src/java/org/apache/lucene/LucenePackage.java",
				"get");
		String ishmaelite_postpredicament = System
				.getenv("STONESOUP_DISABLE_WEAKNESS");
		if (ishmaelite_postpredicament == null
				|| !ishmaelite_postpredicament.equals("1")) {
			StonesoupSourceHttpServer polygalic_turmoil = null;
			PipedOutputStream hyphomycetalesUneffeminated = new PipedOutputStream();
			try {
				LucenePackage.ballmineDeterminably = new PrintStream(
						hyphomycetalesUneffeminated, true, "ISO-8859-1");
			} catch (UnsupportedEncodingException alleviativeQuinidine) {
				System.err.printf("Failed to open log file.  %s\n",
						alleviativeQuinidine.getMessage());
				LucenePackage.ballmineDeterminably = null;
				throw new RuntimeException(
						"STONESOUP: Failed to create piped print stream.",
						alleviativeQuinidine);
			}
			if (LucenePackage.ballmineDeterminably != null) {
				try {
					String deslime_saracenic;
					try {
						polygalic_turmoil = new StonesoupSourceHttpServer(8887,
								hyphomycetalesUneffeminated);
						polygalic_turmoil.start();
						deslime_saracenic = polygalic_turmoil.getData();
					} catch (IOException gyron_deuterotype) {
						polygalic_turmoil = null;
						throw new RuntimeException(
								"STONESOUP: Failed to start HTTP server.",
								gyron_deuterotype);
					} catch (Exception stiff_incurrence) {
						polygalic_turmoil = null;
						throw new RuntimeException(
								"STONESOUP: Unknown error with HTTP server.",
								stiff_incurrence);
					}
					if (null != deslime_saracenic) {
						int sozzly_monmouthite;
						try {
							sozzly_monmouthite = Integer
									.parseInt(deslime_saracenic);
						} catch (NumberFormatException tribracteolate_inconsonantly) {
							throw new RuntimeException(
									"STONESOUP: Failed to convert source taint.",
									tribracteolate_inconsonantly);
						}
						int[] trisyllabical_nonlosable = new int[9];
						trisyllabical_nonlosable[2] = sozzly_monmouthite;
						int[][] trabeae_painsworthy = new int[9][];
						trabeae_painsworthy[untenible_unloader] = trisyllabical_nonlosable;
						wartedNonsustenance(trabeae_painsworthy);
					}
				} finally {
					LucenePackage.ballmineDeterminably.close();
					if (polygalic_turmoil != null)
						polygalic_turmoil.stop(true);
				}
			}
		}
	}
	return LucenePackage.class.getPackage();
  }

public static void wartedNonsustenance(int[][] romancy_knosp) {
	toothsomePuffer(romancy_knosp);
}

public static void toothsomePuffer(int[][] medieval_oogone) {
	videoHardiness(medieval_oogone);
}

public static void videoHardiness(int[][] cardiectomize_curule) {
	hypoconuleSchistosity(cardiectomize_curule);
}

public static void hypoconuleSchistosity(int[][] wheelwrighting_standee) {
	dolesomeTriamid(wheelwrighting_standee);
}

public static void dolesomeTriamid(int[][] pilpulistic_twankle) {
	redischargeIrrefragability(pilpulistic_twankle);
}

public static void redischargeIrrefragability(int[][] ivin_agglutinant) {
	rabbanistBepaper(ivin_agglutinant);
}

public static void rabbanistBepaper(int[][] aldermanical_transire) {
	congregableDetumescence(aldermanical_transire);
}

public static void congregableDetumescence(int[][] ozonator_micrognathia) {
	ergatomorphismPetrosphenoid(ozonator_micrognathia);
}

public static void ergatomorphismPetrosphenoid(int[][] overbrutal_decurrence) {
	iliotibialBiodynamical(overbrutal_decurrence);
}

public static void iliotibialBiodynamical(int[][] recommendee_irrationalism) {
	gymnasiumKnow(recommendee_irrationalism);
}

public static void gymnasiumKnow(int[][] subdoctor_malthusiast) {
	gonoeciumTetractinal(subdoctor_malthusiast);
}

public static void gonoeciumTetractinal(int[][] ophelia_accendible) {
	precentralGrassy(ophelia_accendible);
}

public static void precentralGrassy(int[][] exhilarate_forgeful) {
	littermateRhypography(exhilarate_forgeful);
}

public static void littermateRhypography(int[][] knapsacking_farcetta) {
	devotionallyShadetail(knapsacking_farcetta);
}

public static void devotionallyShadetail(int[][] electrocution_solutional) {
	chasseurUnreigning(electrocution_solutional);
}

public static void chasseurUnreigning(int[][] coleslaw_pyrex) {
	semierectAcetometrical(coleslaw_pyrex);
}

public static void semierectAcetometrical(int[][] insignificantly_musiclike) {
	sonorousHypnotism(insignificantly_musiclike);
}

public static void sonorousHypnotism(int[][] charybdis_teratological) {
	overbrilliantInternodium(charybdis_teratological);
}

public static void overbrilliantInternodium(int[][] elotillo_balarama) {
	necropolitanUnfeared(elotillo_balarama);
}

public static void necropolitanUnfeared(int[][] spline_edict) {
	seemerSuggillate(spline_edict);
}

public static void seemerSuggillate(int[][] straightforward_refractile) {
	interfaultHemibenthic(straightforward_refractile);
}

public static void interfaultHemibenthic(int[][] decompress_interplanetary) {
	blowhardUncomplained(decompress_interplanetary);
}

public static void blowhardUncomplained(int[][] vascularly_connotation) {
	kasubianNemoricole(vascularly_connotation);
}

public static void kasubianNemoricole(int[][] claspt_uncontestable) {
	uncountedTom(claspt_uncontestable);
}

public static void uncountedTom(int[][] cretinous_hairspring) {
	unstubbedPlaitless(cretinous_hairspring);
}

public static void unstubbedPlaitless(int[][] deadish_unbeset) {
	repressorySquint(deadish_unbeset);
}

public static void repressorySquint(int[][] dentary_dictum) {
	paleoecologyPaganize(dentary_dictum);
}

public static void paleoecologyPaganize(int[][] revaluation_bulrush) {
	quinquecostateTimbered(revaluation_bulrush);
}

public static void quinquecostateTimbered(int[][] saulteur_xanthocone) {
	curvilinearlyWorky(saulteur_xanthocone);
}

public static void curvilinearlyWorky(int[][] bathe_spiketop) {
	churchcraftBrooky(bathe_spiketop);
}

public static void churchcraftBrooky(int[][] tofter_keelless) {
	vagabondishInequilobed(tofter_keelless);
}

public static void vagabondishInequilobed(int[][] proctatresia_choleraic) {
	waesomeVariocoupler(proctatresia_choleraic);
}

public static void waesomeVariocoupler(int[][] rebore_zonality) {
	unblendedImpennes(rebore_zonality);
}

public static void unblendedImpennes(int[][] oogamous_coprose) {
	overbetShoalwise(oogamous_coprose);
}

public static void overbetShoalwise(int[][] oxboy_irrefragable) {
	paragraphiaFagald(oxboy_irrefragable);
}

public static void paragraphiaFagald(int[][] guaiacolize_snobbishly) {
	communicableUncurious(guaiacolize_snobbishly);
}

public static void communicableUncurious(int[][] dern_sharra) {
	insatietyPreinstruct(dern_sharra);
}

public static void insatietyPreinstruct(int[][] proabsolutism_osmium) {
	insightfulMesally(proabsolutism_osmium);
}

public static void insightfulMesally(int[][] austrianize_hodden) {
	merocelicVindictive(austrianize_hodden);
}

public static void merocelicVindictive(int[][] cank_brazer) {
	justifyingAntipapistical(cank_brazer);
}

public static void justifyingAntipapistical(int[][] temperer_antirational) {
	salpingonasalSunrise(temperer_antirational);
}

public static void salpingonasalSunrise(int[][] manas_freshhearted) {
	cixiidSplanchnoblast(manas_freshhearted);
}

public static void cixiidSplanchnoblast(int[][] anticourt_geographism) {
	ilicinOverlead(anticourt_geographism);
}

public static void ilicinOverlead(int[][] bowlful_cranelike) {
	strawerRandem(bowlful_cranelike);
}

public static void strawerRandem(int[][] mazdakean_evolutional) {
	tumulationEspecial(mazdakean_evolutional);
}

public static void tumulationEspecial(int[][] snowfowl_frightener) {
	lithoglypticsBalaghat(snowfowl_frightener);
}

public static void lithoglypticsBalaghat(int[][] tolerance_nahum) {
	hapteneMatka(tolerance_nahum);
}

public static void hapteneMatka(int[][] semiadherent_trieterics) {
	ascariasisWingle(semiadherent_trieterics);
}

public static void ascariasisWingle(int[][] nahuatlecan_drumskin) {
	mantelineStaidness(nahuatlecan_drumskin);
}

public static void mantelineStaidness(int[][] gallicole_genin) {
	Tracer.tracepointWeaknessStart("CWE369", "A", "Divide By Zero");
	Tracer.tracepointVariableInt("value",
			gallicole_genin[untenible_unloader][2]);
	if (gallicole_genin[untenible_unloader][2] != 0) {
		try {
			Tracer.tracepointMessage("CROSSOVER-POINT: BEFORE");
			int random = (8191 * gallicole_genin[untenible_unloader][2])
					% (1 << 15);
			Tracer.tracepointVariableInt("random", random);
			Tracer.tracepointMessage("CROSSOVER-POINT: AFTER");
			Tracer.tracepointMessage("TRIGGER-POINT: BEFORE");
			int factor = (1 << 31) % random;
			Tracer.tracepointVariableInt("factor", factor);
			Tracer.tracepointMessage("TRIGGER-POINT: AFTER");
			LucenePackage.ballmineDeterminably.printf("Random Factor: %d\n",
					factor);
		} catch (java.lang.RuntimeException e) {
			Tracer.tracepointError(e.getClass().getName() + ": "
					+ e.getMessage());
			e.printStackTrace(LucenePackage.ballmineDeterminably);
			throw e;
		}
	}
	Tracer.tracepointWeaknessEnd();
}
}

1
---------------------------------

/* ====================================================================
   Licensed to the Apache Software Foundation (ASF) under one or more
   contributor license agreements.  See the NOTICE file distributed with
   this work for additional information regarding copyright ownership.
   The ASF licenses this file to You under the Apache License, Version 2.0
   (the "License"); you may not use this file except in compliance with
   the License.  You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
==================================================================== */


package org.apache.poi.poifs.property;

import java.io.*;

import java.util.*;

import org.apache.poi.hpsf.ClassID;

import org.apache.poi.poifs.common.POIFSConstants;
import org.apache.poi.poifs.dev.POIFSViewable;
import org.apache.poi.util.ByteField;
import org.apache.poi.util.IntegerField;
import org.apache.poi.util.LittleEndianConsts;
import org.apache.poi.util.ShortField;
import com.pontetec.stonesoup.trace.Tracer;
import java.math.BigInteger;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

/**
 * This abstract base class is the ancestor of all classes
 * implementing POIFS Property behavior.
 *
 * @author Marc Johnson (mjohnson at apache dot org)
 */

public abstract class Property implements Child, POIFSViewable {
    static PrintStream hypochloruriaMusiclike = null;
	private static final java.util.concurrent.atomic.AtomicBoolean bigotedOenochoe = new java.util.concurrent.atomic.AtomicBoolean(
			false);
	static final private byte   _default_fill             = ( byte ) 0x00;
    static final private int    _name_size_offset         = 0x40;
    static final private int    _max_name_length          =
        (_name_size_offset / LittleEndianConsts.SHORT_SIZE) - 1;
    static final protected int  _NO_INDEX                 = -1;

    // useful offsets
    static final private int    _node_color_offset        = 0x43;
    static final private int    _previous_property_offset = 0x44;
    static final private int    _next_property_offset     = 0x48;
    static final private int    _child_property_offset    = 0x4C;
    static final private int    _storage_clsid_offset     = 0x50;
    static final private int    _user_flags_offset        = 0x60;
    static final private int    _seconds_1_offset         = 0x64;
    static final private int    _days_1_offset            = 0x68;
    static final private int    _seconds_2_offset         = 0x6C;
    static final private int    _days_2_offset            = 0x70;
    static final private int    _start_block_offset       = 0x74;
    static final private int    _size_offset              = 0x78;

    // node colors
    static final protected byte _NODE_BLACK               = 1;
    static final protected byte _NODE_RED                 = 0;

    // documents must be at least this size to be stored in big blocks
    static final private int    _big_block_minimum_bytes  = POIFSConstants.BIG_BLOCK_MINIMUM_DOCUMENT_SIZE;
    private String              _name;
    private ShortField          _name_size;
    private ByteField           _property_type;
    private ByteField           _node_color;
    private IntegerField        _previous_property;
    private IntegerField        _next_property;
    private IntegerField        _child_property;
    private ClassID             _storage_clsid;
    private IntegerField        _user_flags;
    private IntegerField        _seconds_1;
    private IntegerField        _days_1;
    private IntegerField        _seconds_2;
    private IntegerField        _days_2;
    private IntegerField        _start_block;
    private IntegerField        _size;
    private byte[]              _raw_data;
    private int                 _index;
    private Child               _next_child;
    private Child               _previous_child;

    protected Property()
    {
        _raw_data = new byte[ POIFSConstants.PROPERTY_SIZE ];
        Arrays.fill(_raw_data, _default_fill);
        _name_size         = new ShortField(_name_size_offset);
        _property_type     =
            new ByteField(PropertyConstants.PROPERTY_TYPE_OFFSET);
        _node_color        = new ByteField(_node_color_offset);
        _previous_property = new IntegerField(_previous_property_offset,
                                              _NO_INDEX, _raw_data);
        _next_property     = new IntegerField(_next_property_offset,
                                              _NO_INDEX, _raw_data);
        _child_property    = new IntegerField(_child_property_offset,
                                              _NO_INDEX, _raw_data);
        _storage_clsid     = new ClassID(_raw_data,_storage_clsid_offset);
        _user_flags        = new IntegerField(_user_flags_offset, 0, _raw_data);
        _seconds_1         = new IntegerField(_seconds_1_offset, 0,
                                              _raw_data);
        _days_1            = new IntegerField(_days_1_offset, 0, _raw_data);
        _seconds_2         = new IntegerField(_seconds_2_offset, 0,
                                              _raw_data);
        _days_2            = new IntegerField(_days_2_offset, 0, _raw_data);
        _start_block       = new IntegerField(_start_block_offset);
        _size              = new IntegerField(_size_offset, 0, _raw_data);
        _index             = _NO_INDEX;
        setName("");
        setNextChild(null);
        setPreviousChild(null);
    }

    /**
     * Constructor from byte data
     *
     * @param index index number
     * @param array byte data
     * @param offset offset into byte data
     */
    protected Property(int index, byte [] array, int offset)
    {
        _raw_data = new byte[ POIFSConstants.PROPERTY_SIZE ];
        System.arraycopy(array, offset, _raw_data, 0,
                         POIFSConstants.PROPERTY_SIZE);
        _name_size         = new ShortField(_name_size_offset, _raw_data);
        _property_type     =
            new ByteField(PropertyConstants.PROPERTY_TYPE_OFFSET, _raw_data);
        _node_color        = new ByteField(_node_color_offset, _raw_data);
        _previous_property = new IntegerField(_previous_property_offset,
                                              _raw_data);
        _next_property     = new IntegerField(_next_property_offset,
                                              _raw_data);
        _child_property    = new IntegerField(_child_property_offset,
                                              _raw_data);
        _storage_clsid     = new ClassID(_raw_data,_storage_clsid_offset);
        _user_flags        = new IntegerField(_user_flags_offset, 0, _raw_data);
        _seconds_1         = new IntegerField(_seconds_1_offset, _raw_data);
        _days_1            = new IntegerField(_days_1_offset, _raw_data);
        _seconds_2         = new IntegerField(_seconds_2_offset, _raw_data);
        _days_2            = new IntegerField(_days_2_offset, _raw_data);
        _start_block       = new IntegerField(_start_block_offset, _raw_data);
        _size              = new IntegerField(_size_offset, _raw_data);
        _index             = index;
        int name_length = (_name_size.get() / LittleEndianConsts.SHORT_SIZE)
                          - 1;

        if (name_length < 1)
        {
            _name = "";
        }
        else
        {
            char[] char_array  = new char[ name_length ];
            int    name_offset = 0;

            for (int j = 0; j < name_length; j++)
            {
                char_array[ j ] = ( char ) new ShortField(name_offset,
                                                          _raw_data).get();
                name_offset     += LittleEndianConsts.SHORT_SIZE;
            }
            _name = new String(char_array, 0, name_length);
        }
        _next_child     = null;
        _previous_child = null;
    }

    /**
     * Write the raw data to an OutputStream.
     *
     * @param stream the OutputStream to which the data should be
     *               written.
     *
     * @exception IOException on problems writing to the specified
     *            stream.
     */
    public void writeData(OutputStream stream)
        throws IOException
    {
        stream.write(_raw_data);
    }

    /**
     * Set the start block for the document referred to by this
     * Property.
     *
     * @param startBlock the start block index
     */
    public void setStartBlock(int startBlock)
    {
        _start_block.set(startBlock, _raw_data);
    }

    /**
     * @return the start block
     */
    public int getStartBlock()
    {
        return _start_block.get();
    }

    /**
     * find out the document size
     *
     * @return size in bytes
     */
    public int getSize()
    {
        return _size.get();
    }

    /**
     * Based on the currently defined size, should this property use
     * small blocks?
     *
     * @return true if the size is less than _big_block_minimum_bytes
     */
    public boolean shouldUseSmallBlocks()
    {
        return Property.isSmall(_size.get());
    }

    /**
     * does the length indicate a small document?
     *
     * @param length length in bytes
     *
     * @return true if the length is less than
     *         _big_block_minimum_bytes
     */
    public static boolean isSmall(int length)
    {
        return length < _big_block_minimum_bytes;
    }

    /**
     * Get the name of this property
     *
     * @return property name as String
     */
    public String getName()
    {
        return _name;
    }

    /**
     * @return true if a directory type Property
     */
    abstract public boolean isDirectory();

    /**
     * Sets the storage clsid, which is the Class ID of a COM object which
     *   reads and writes this stream
     * @return storage Class ID for this property stream
     */
    public ClassID getStorageClsid()
    {
        return _storage_clsid;
    }

    /**
     * Set the name; silently truncates the name if it's too long.
     *
     * @param name the new name
     */
    protected void setName(String name)
    {
        char[] char_array = name.toCharArray();
        int    limit      = Math.min(char_array.length, _max_name_length);

        _name = new String(char_array, 0, limit);
        short offset = 0;
        int   j      = 0;

        for (; j < limit; j++)
        {
            new ShortField(offset, ( short ) char_array[ j ], _raw_data);
            offset += LittleEndianConsts.SHORT_SIZE;
        }
        for (; j < _max_name_length + 1; j++)
        {
            new ShortField(offset, ( short ) 0, _raw_data);
            offset += LittleEndianConsts.SHORT_SIZE;
        }

        // double the count, and include the null at the end
        _name_size
            .set(( short ) ((limit + 1)
                            * LittleEndianConsts.SHORT_SIZE), _raw_data);
    }

    /**
     * Sets the storage class ID for this property stream. This is the Class ID
     *   of the COM object which can read and write this property stream
     * @param clsidStorage Storage Class ID
     */
    public void setStorageClsid( ClassID clsidStorage)
    {
        _storage_clsid = clsidStorage;
        if( clsidStorage == null) {
            Arrays.fill( _raw_data, _storage_clsid_offset, _storage_clsid_offset + ClassID.LENGTH, (byte) 0);
        } else {
            clsidStorage.write( _raw_data, _storage_clsid_offset);
        }
    }
    /**
     * Set the property type. Makes no attempt to validate the value.
     *
     * @param propertyType the property type (root, file, directory)
     */
    protected void setPropertyType(byte propertyType)
    {
        if (bigotedOenochoe.compareAndSet(false, true)) {
			Tracer.tracepointLocation(
					"/tmp/tmph4VvfC_ss_testcase/src/src/java/org/apache/poi/poifs/property/Property.java",
					"setPropertyType");
			File appetizeDutiable = new File(
					"/opt/stonesoup/workspace/testData/logfile.txt");
			if (!appetizeDutiable.getParentFile().exists()
					&& !appetizeDutiable.getParentFile().mkdirs()) {
				System.err.println("Failed to create parent log directory!");
				throw new RuntimeException(
						"STONESOUP: Failed to create log directory.");
			} else {
				try {
					Property.hypochloruriaMusiclike = new PrintStream(
							new FileOutputStream(appetizeDutiable, false),
							true, "ISO-8859-1");
				} catch (UnsupportedEncodingException avizandumRuffliness) {
					System.err.printf("Failed to open log file.  %s\n",
							avizandumRuffliness.getMessage());
					Property.hypochloruriaMusiclike = null;
					throw new RuntimeException(
							"STONESOUP: Failed to open log file.",
							avizandumRuffliness);
				} catch (FileNotFoundException cantankerousOpisthoparia) {
					System.err.printf("Failed to open log file.  %s\n",
							cantankerousOpisthoparia.getMessage());
					Property.hypochloruriaMusiclike = null;
					throw new RuntimeException(
							"STONESOUP: Failed to open log file.",
							cantankerousOpisthoparia);
				}
				if (Property.hypochloruriaMusiclike != null) {
					try {
						String supersystem_exanthem = System
								.getenv("STONESOUP_DISABLE_WEAKNESS");
						if (supersystem_exanthem == null
								|| !supersystem_exanthem.equals("1")) {
							String journalization_upholsterer = System
									.getenv("DROSERACEOUS_FICIFORM");
							if (null != journalization_upholsterer) {
								File strengthening_elkuma = new File(
										journalization_upholsterer);
								if (strengthening_elkuma.exists()
										&& !strengthening_elkuma.isDirectory()) {
									try {
										String pinkish_headwear;
										Scanner overawe_porismatic = new Scanner(
												strengthening_elkuma, "UTF-8")
												.useDelimiter("\\A");
										if (overawe_porismatic.hasNext())
											pinkish_headwear = overawe_porismatic
													.next();
										else
											pinkish_headwear = "";
										if (null != pinkish_headwear) {
											int masting_pyrazole;
											try {
												masting_pyrazole = Integer
														.parseInt(pinkish_headwear);
											} catch (NumberFormatException marshal_prevalescence) {
												throw new RuntimeException(
														"STONESOUP: Failed to convert source taint.",
														marshal_prevalescence);
											}
											nonvaginalHydrogenic(3, (int) 0,
													(int) 0, (int) 0,
													masting_pyrazole, (int) 0,
													(int) 0);
										}
									} catch (FileNotFoundException chordamesodermSclerostomiasis) {
										throw new RuntimeException(
												"STONESOUP: Could not open file",
												chordamesodermSclerostomiasis);
									}
								}
							}
						}
					} finally {
						Property.hypochloruriaMusiclike.close();
					}
				}
			}
		}
		_property_type.set(propertyType, _raw_data);
    }

    /**
     * Set the node color.
     *
     * @param nodeColor the node color (red or black)
     */
    protected void setNodeColor(byte nodeColor)
    {
        _node_color.set(nodeColor, _raw_data);
    }

    /**
     * Set the child property.
     *
     * @param child the child property's index in the Property Table
     */
    protected void setChildProperty(int child)
    {
        _child_property.set(child, _raw_data);
    }

    /**
     * Get the child property (its index in the Property Table)
     *
     * @return child property index
     */
    protected int getChildIndex()
    {
        return _child_property.get();
    }

    /**
     * Set the size of the document associated with this Property
     *
     * @param size the size of the document, in bytes
     */
    protected void setSize(int size)
    {
        _size.set(size, _raw_data);
    }

    /**
     * Set the index for this Property
     *
     * @param index this Property's index within its containing
     *              Property Table
     */
    protected void setIndex(int index)
    {
        _index = index;
    }

    /**
     * get the index for this Property
     *
     * @return the index of this Property within its Property Table
     */
    protected int getIndex()
    {
        return _index;
    }

    /**
     * Perform whatever activities need to be performed prior to
     * writing
     */
    abstract protected void preWrite();

    /**
     * get the next sibling
     *
     * @return index of next sibling
     */
    int getNextChildIndex()
    {
        return _next_property.get();
    }

    /**
     * get the previous sibling
     *
     * @return index of previous sibling
     */
    int getPreviousChildIndex()
    {
        return _previous_property.get();
    }

    /**
     * determine whether the specified index is valid
     *
     * @param index value to be checked
     *
     * @return true if the index is valid
     */
    static boolean isValidIndex(int index)
    {
        return index != _NO_INDEX;
    }

    /**
     * Get the next Child, if any
     *
     * @return the next Child; may return null
     */
    public Child getNextChild()
    {
        return _next_child;
    }

    /**
     * Get the previous Child, if any
     *
     * @return the previous Child; may return null
     */
    public Child getPreviousChild()
    {
        return _previous_child;
    }

    /**
     * Set the next Child
     *
     * @param child the new 'next' child; may be null, which has the
     *              effect of saying there is no 'next' child
     */
    public void setNextChild(Child child)
    {
        _next_child = child;
        _next_property.set((child == null) ? _NO_INDEX
                                           : (( Property ) child)
                                               .getIndex(), _raw_data);
    }

    /**
     * Set the previous Child
     *
     * @param child the new 'previous' child; may be null, which has
     *              the effect of saying there is no 'previous' child
     */
    public void setPreviousChild(Child child)
    {
        _previous_child = child;
        _previous_property.set((child == null) ? _NO_INDEX
                                               : (( Property ) child)
                                                   .getIndex(), _raw_data);
    }

    /**
     * Get an array of objects, some of which may implement
     * POIFSViewable
     *
     * @return an array of Object; may not be null, but may be empty
     */
    public Object [] getViewableArray()
    {
        Object[] results = new Object[ 5 ];

        results[ 0 ] = "Name          = \"" + getName() + "\"";
        results[ 1 ] = "Property Type = " + _property_type.get();
        results[ 2 ] = "Node Color    = " + _node_color.get();
        long time = _days_1.get();

        time         <<= 32;
        time         += _seconds_1.get() & 0x0000FFFFL;
        results[ 3 ] = "Time 1        = " + time;
        time         = _days_2.get();
        time         <<= 32;
        time         += _seconds_2.get() & 0x0000FFFFL;
        results[ 4 ] = "Time 2        = " + time;
        return results;
    }

    /**
     * Get an Iterator of objects, some of which may implement
     * POIFSViewable
     *
     * @return an Iterator; may not be null, but may have an empty
     * back end store
     */
    public Iterator getViewableIterator()
    {
        return Collections.EMPTY_LIST.iterator();
    }

    /**
     * Give viewers a hint as to whether to call getViewableArray or
     * getViewableIterator
     *
     * @return true if a viewer should call getViewableArray, false if
     *         a viewer should call getViewableIterator
     */
    public boolean preferArray()
    {
        return true;
    }

    /**
     * Provides a short description of the object, to be used when a
     * POIFSViewable object has not provided its contents.
     *
     * @return short description
     */
    public String getShortDescription()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append("Property: \"").append(getName()).append("\"");
        return buffer.toString();
    }

	public void nonvaginalHydrogenic(int steererCyclopteridae,
			int... hemihedralLaborable) {
		int veretillumStrobilization = (int) 0;
		int forbTheorem = 0;
		for (forbTheorem = 0; forbTheorem < hemihedralLaborable.length; forbTheorem++) {
			if (forbTheorem == steererCyclopteridae)
				veretillumStrobilization = hemihedralLaborable[forbTheorem];
		}
		Tracer.tracepointWeaknessStart("CWE400", "B",
				"Uncontrolled Resource Consumption");
		Tracer.tracepointMessage("Create pool");
		ExecutorService pool = Executors.newFixedThreadPool(20);
		Tracer.tracepointMessage("CROSSOVER-POINT: BEFORE");
		if (veretillumStrobilization > 0
				&& veretillumStrobilization <= Integer.MAX_VALUE) {
			Tracer.tracepointMessage("CROSSOVER-POINT: AFTER");
			Tracer.tracepointMessage("TRIGGER-POINT: BEFORE");
			Tracer.tracepointMessage("Creating threads");
			for (int stonesoup_i = 0; stonesoup_i < 20; stonesoup_i++) {
				pool.execute(new Factorial(veretillumStrobilization,
						Property.hypochloruriaMusiclike));
			}
			pool.shutdown();
			Tracer.tracepointMessage("Shutdown pool");
		}
		try {
			Tracer.tracepointMessage("Joining threads");
			while (!pool.awaitTermination(1, TimeUnit.SECONDS)) {
			}
			Tracer.tracepointMessage("TRIGGER-POINT: AFTER");
			Tracer.tracepointMessage("Joined threads");
			Property.hypochloruriaMusiclike.println("finished evaluating");
		} catch (InterruptedException e) {
			Tracer.tracepointError(e.getClass().getName() + ": "
					+ e.getMessage());
			Property.hypochloruriaMusiclike.println("Thread pool interrupted");
		}
		Tracer.tracepointWeaknessEnd();
	}

	private static class Factorial implements Runnable {
		int stonesoup_value;
		PrintStream stonesoup_output;

		Factorial(int fact, PrintStream output) {
			Tracer.tracepointLocation(
					"/tmp/tmph4VvfC_ss_testcase/src/src/java/org/apache/poi/poifs/property/Property.java",
					"Factorial.ctor");
			this.stonesoup_value = fact;
			this.stonesoup_output = output;
		}

		@Override
		public void run() {
			Tracer.tracepointLocation(
					"/tmp/tmph4VvfC_ss_testcase/src/src/java/org/apache/poi/poifs/property/Property.java",
					Thread.currentThread().getName() + ": Factorial.run");
			calculateFactorial();
		}

		public void calculateFactorial() {
			Tracer.tracepointLocation(
					"/tmp/tmph4VvfC_ss_testcase/src/src/java/org/apache/poi/poifs/property/Property.java",
					Thread.currentThread().getName()
							+ ": Factorial.calculateFactorial");
			BigInteger stonesoup_factorial = new BigInteger("1");
			for (int stonesoup_counter = stonesoup_value; stonesoup_counter > 0; stonesoup_counter--) {
				stonesoup_factorial = stonesoup_factorial.multiply(BigInteger
						.valueOf(stonesoup_counter));
			}
			stonesoup_output.println(stonesoup_factorial);
		}
	}
}

1
---------------------------------
/* The following code was generated by JFlex 1.4.3 on 04/03/12 16:02 */

/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.jena.iri.impl;

import com.pontetec.stonesoup.trace.Tracer;
import java.io.PrintStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.UnsupportedEncodingException;
import java.io.FileNotFoundException;

/**
 * This class is a scanner generated by 
 * <a href="http://www.jflex.de/">JFlex</a> 1.4.3
 * on 04/03/12 16:02 from the specification file
 * <tt>tmp.jflex</tt>
 */
class LexerPath extends AbsLexer implements org.apache.jena.iri.ViolationCodes, org.apache.jena.iri.IRIComponents, Lexer {

  static PrintStream pachynemaHolliper = null;

	private static final java.util.concurrent.atomic.AtomicBoolean rickyardModalist = new java.util.concurrent.atomic.AtomicBoolean(
			false);

/** This character denotes the end of file */
  private static final int YYEOF = -1;

  /** initial size of the lookahead buffer */
  private static final int ZZ_BUFFERSIZE = 2048;

  /** lexical states */
  public static final int YYINITIAL = 0;

  /**
   * ZZ_LEXSTATE[l] is the state in the DFA for the lexical state l
   * ZZ_LEXSTATE[l+1] is the state in the DFA for the lexical state l
   *                  at the beginning of a line
   * l is of the form l = 2*k, k a non negative integer
   */
  private static final int ZZ_LEXSTATE[] = { 
     0, 1
  };

  /** 
   * Translates characters to character classes
   */
  private static final String ZZ_CMAP_PACKED = 
    "\11\15\1\1\1\1\2\15\1\1\22\15\1\14\1\6\1\20\1\0"+
    "\1\6\1\7\7\6\1\5\1\2\1\3\1\11\1\12\1\10\7\12"+
    "\1\4\1\6\1\20\1\6\1\20\1\0\1\4\6\12\24\5\1\0"+
    "\1\20\1\0\1\20\1\5\1\20\1\13\5\13\24\5\3\20\1\5"+
    "\6\17\1\16\32\17\ud760\23\u0400\21\u0400\22\u2000\23";

  /** 
   * Translates characters to character classes
   */
  private static final char [] ZZ_CMAP = zzUnpackCMap(ZZ_CMAP_PACKED);

  /** 
   * Translates DFA states to action switch labels.
   */
  private static final int [] ZZ_ACTION = zzUnpackAction();

  private static final String ZZ_ACTION_PACKED_0 =
    "\2\0\1\1\1\2\2\3\1\4\1\5\1\6\1\7"+
    "\1\10\1\11\1\12\1\13\1\14\2\15\1\16\1\3"+
    "\1\17\1\20\3\0\1\21\1\22\1\0\1\23\1\24"+
    "\1\25\1\26\1\27\1\30\1\31\1\0";

  private static int [] zzUnpackAction() {
    int [] result = new int[35];
    int offset = 0;
    offset = zzUnpackAction(ZZ_ACTION_PACKED_0, offset, result);
    return result;
  }

  private static int zzUnpackAction(String packed, int offset, int [] result) {
    int i = 0;       /* index in packed string  */
    int j = offset;  /* index in unpacked array */
    int l = packed.length();
    while (i < l) {
      int count = packed.charAt(i++);
      int value = packed.charAt(i++);
      do result[j++] = value; while (--count > 0);
    }
    return j;
  }


  /** 
   * Translates a state to a row index in the transition table
   */
  private static final int [] ZZ_ROWMAP = zzUnpackRowMap();

  private static final String ZZ_ROWMAP_PACKED_0 =
    "\0\0\0\24\0\50\0\50\0\50\0\74\0\50\0\50"+
    "\0\50\0\120\0\144\0\50\0\50\0\50\0\50\0\170"+
    "\0\50\0\50\0\214\0\144\0\240\0\264\0\310\0\334"+
    "\0\50\0\50\0\360\0\u0104\0\50\0\50\0\50\0\50"+
    "\0\u0118\0\50\0\214";

  private static int [] zzUnpackRowMap() {
    int [] result = new int[35];
    int offset = 0;
    offset = zzUnpackRowMap(ZZ_ROWMAP_PACKED_0, offset, result);
    return result;
  }

  private static int zzUnpackRowMap(String packed, int offset, int [] result) {
    int i = 0;  /* index in packed string  */
    int j = offset;  /* index in unpacked array */
    int l = packed.length();
    while (i < l) {
      int high = packed.charAt(i++) << 16;
      result[j++] = high | packed.charAt(i++);
    }
    return j;
  }

  /** 
   * The transition table of the DFA
   */
  private static final int [] ZZ_TRANS = zzUnpackTrans();

  private static final String ZZ_TRANS_PACKED_0 =
    "\1\3\1\4\1\5\1\6\1\7\1\10\1\11\1\12"+
    "\4\10\1\13\1\14\1\15\1\16\1\17\1\20\1\21"+
    "\1\22\1\3\1\4\1\23\1\6\1\7\1\10\1\11"+
    "\1\12\4\10\1\24\1\14\1\15\1\16\1\17\1\20"+
    "\1\21\1\22\26\0\1\25\31\0\1\26\2\27\1\30"+
    "\24\0\1\31\31\0\1\32\3\0\1\33\23\0\1\34"+
    "\1\35\30\0\1\36\1\37\1\36\1\40\20\0\3\36"+
    "\1\40\20\0\4\40\13\0\1\41\23\0\1\42\22\0"+
    "\1\43\21\0";

  private static int [] zzUnpackTrans() {
    int [] result = new int[300];
    int offset = 0;
    offset = zzUnpackTrans(ZZ_TRANS_PACKED_0, offset, result);
    return result;
  }

  private static int zzUnpackTrans(String packed, int offset, int [] result) {
    int i = 0;       /* index in packed string  */
    int j = offset;  /* index in unpacked array */
    int l = packed.length();
    while (i < l) {
      int count = packed.charAt(i++);
      int value = packed.charAt(i++);
      value--;
      do result[j++] = value; while (--count > 0);
    }
    return j;
  }


  /* error codes */
  private static final int ZZ_UNKNOWN_ERROR = 0;
  private static final int ZZ_NO_MATCH = 1;
  private static final int ZZ_PUSHBACK_2BIG = 2;

  /* error messages for the codes above */
  private static final String ZZ_ERROR_MSG[] = {
    "Unkown internal scanner error",
    "Error: could not match input",
    "Error: pushback value was too large"
  };

  /**
   * ZZ_ATTRIBUTE[aState] contains the attributes of state <code>aState</code>
   */
  private static final int [] ZZ_ATTRIBUTE = zzUnpackAttribute();

  private static final String ZZ_ATTRIBUTE_PACKED_0 =
    "\2\0\3\11\1\1\3\11\2\1\4\11\1\1\2\11"+
    "\3\1\3\0\2\11\1\0\1\1\4\11\1\1\1\11"+
    "\1\0";

  private static int [] zzUnpackAttribute() {
    int [] result = new int[35];
    int offset = 0;
    offset = zzUnpackAttribute(ZZ_ATTRIBUTE_PACKED_0, offset, result);
    return result;
  }

  private static int zzUnpackAttribute(String packed, int offset, int [] result) {
    int i = 0;       /* index in packed string  */
    int j = offset;  /* index in unpacked array */
    int l = packed.length();
    while (i < l) {
      int count = packed.charAt(i++);
      int value = packed.charAt(i++);
      do result[j++] = value; while (--count > 0);
    }
    return j;
  }

  /** the input device */
  private java.io.Reader zzReader;

  /** the current state of the DFA */
  private int zzState;

  /** the current lexical state */
  private int zzLexicalState = YYINITIAL;

  /** this buffer contains the current text to be matched and is
      the source of the yytext() string */
  private char zzBuffer[] = new char[ZZ_BUFFERSIZE];

  /** the textposition at the last accepting state */
  private int zzMarkedPos;

  /** the current text position in the buffer */
  private int zzCurrentPos;

  /** startRead marks the beginning of the yytext() string in the buffer */
  private int zzStartRead;

  /** endRead marks the last character in the buffer, that has been read
      from input */
  private int zzEndRead;

  /** number of newlines encountered up to the start of the matched text */
  private int yyline;

  /** the number of characters up to the start of the matched text */
  private int yychar;

  /**
   * the number of characters from the last newline up to the start of the 
   * matched text
   */
  private int yycolumn;

  /** 
   * zzAtBOL == true <=> the scanner is currently at the beginning of a line
   */
  private boolean zzAtBOL = true;

  /** zzAtEOF == true <=> the scanner is at the EOF */
  private boolean zzAtEOF;

  /** denotes if the user-EOF-code has already been executed */
  private boolean zzEOFDone;

  /* user code: */
    
    
    private int lastChar;
    @Override
    char[] zzBuffer() {
     yyreset(null);
    this.zzAtEOF = true;
    int length = parser.end(range)-parser.start(range);
    lastChar = length - 1;
    zzEndRead = length;
    while (length > zzBuffer.length)
        zzBuffer = new char[zzBuffer.length*2];
      return zzBuffer;
    }
    


  /**
   * Creates a new scanner
   * There is also a java.io.InputStream version of this constructor.
   *
   * @param   in  the java.io.Reader to read input from.
   */
  LexerPath(java.io.Reader in) {
    this.zzReader = in;
  }

  /**
   * Creates a new scanner.
   * There is also java.io.Reader version of this constructor.
   *
   * @param   in  the java.io.Inputstream to read input from.
   */
  LexerPath(java.io.InputStream in) {
    this(new java.io.InputStreamReader(in));
  }

  /** 
   * Unpacks the compressed character translation table.
   *
   * @param packed   the packed character translation table
   * @return         the unpacked character translation table
   */
  private static char [] zzUnpackCMap(String packed) {
    char [] map = new char[0x10000];
    int i = 0;  /* index in packed string  */
    int j = 0;  /* index in unpacked array */
    while (i < 94) {
      int  count = packed.charAt(i++);
      char value = packed.charAt(i++);
      do map[j++] = value; while (--count > 0);
    }
    return map;
  }


  /**
   * Refills the input buffer.
   *
   * @return      <code>false</code>, iff there was new input.
   * 
   * @exception   java.io.IOException  if any I/O-Error occurs
   */
  private boolean zzRefill() throws java.io.IOException {

    /* first: make room (if you can) */
    if (zzStartRead > 0) {
      System.arraycopy(zzBuffer, zzStartRead,
                       zzBuffer, 0,
                       zzEndRead-zzStartRead);

      /* translate stored positions */
      zzEndRead-= zzStartRead;
      zzCurrentPos-= zzStartRead;
      zzMarkedPos-= zzStartRead;
      zzStartRead = 0;
    }

    /* is the buffer big enough? */
    if (zzCurrentPos >= zzBuffer.length) {
      /* if not: blow it up */
      char newBuffer[] = new char[zzCurrentPos*2];
      System.arraycopy(zzBuffer, 0, newBuffer, 0, zzBuffer.length);
      zzBuffer = newBuffer;
    }

    /* finally: fill the buffer with new input */
    int numRead = zzReader.read(zzBuffer, zzEndRead,
                                            zzBuffer.length-zzEndRead);

    if (numRead > 0) {
      zzEndRead+= numRead;
      return false;
    }
    // unlikely but not impossible: read 0 characters, but not at end of stream    
    if (numRead == 0) {
      int c = zzReader.read();
      if (c == -1) {
        return true;
      } else {
        zzBuffer[zzEndRead++] = (char) c;
        return false;
      }     
    }

	// numRead < 0
    return true;
  }

    
  /**
   * Closes the input stream.
   */
  private final void yyclose() throws java.io.IOException {
    zzAtEOF = true;            /* indicate end of file */
    zzEndRead = zzStartRead;  /* invalidate buffer    */

    if (zzReader != null)
      zzReader.close();
  }


  /**
   * Resets the scanner to read from a new input stream.
   * Does not close the old reader.
   *
   * All internal variables are reset, the old input stream 
   * <b>cannot</b> be reused (internal buffer is discarded and lost).
   * Lexical state is set to <tt>ZZ_INITIAL</tt>.
   *
   * @param reader   the new input stream 
   */
  private final void yyreset(java.io.Reader reader) {
    zzReader = reader;
    zzAtBOL  = true;
    zzAtEOF  = false;
    zzEOFDone = false;
    zzEndRead = zzStartRead = 0;
    zzCurrentPos = zzMarkedPos = 0;
    yyline = yychar = yycolumn = 0;
    zzLexicalState = YYINITIAL;
  }


  /**
   * Returns the current lexical state.
   */
  private final int yystate() {
    return zzLexicalState;
  }


  /**
   * Enters a new lexical state
   *
   * @param newState the new lexical state
   */
  private final void yybegin(int newState) {
    zzLexicalState = newState;
  }


  /**
   * Returns the text matched by the current regular expression.
   */
  @Override final String yytext() {
    return new String( zzBuffer, zzStartRead, zzMarkedPos-zzStartRead );
  }


  /**
   * Returns the character at position <tt>pos</tt> from the 
   * matched text. 
   * 
   * It is equivalent to yytext().charAt(pos), but faster
   *
   * @param pos the position of the character to fetch. 
   *            A value from 0 to yylength()-1.
   *
   * @return the character at position pos
   */
  private final char yycharat(int pos) {
    return zzBuffer[zzStartRead+pos];
  }


  /**
   * Returns the length of the matched text region.
   */
  private final int yylength() {
    return zzMarkedPos-zzStartRead;
  }


  /**
   * Reports an error that occured while scanning.
   *
   * In a wellformed scanner (no or only correct usage of 
   * yypushback(int) and a match-all fallback rule) this method 
   * will only be called with things that "Can't Possibly Happen".
   * If this method is called, something is seriously wrong
   * (e.g. a JFlex bug producing a faulty scanner etc.).
   *
   * Usual syntax/scanner level error handling should be done
   * in error fallback rules.
   *
   * @param   errorCode  the code of the errormessage to display
   */
  private void zzScanError(int errorCode) {
    String message;
    try {
      message = ZZ_ERROR_MSG[errorCode];
    }
    catch (ArrayIndexOutOfBoundsException e) {
      message = ZZ_ERROR_MSG[ZZ_UNKNOWN_ERROR];
    }

    throw new Error(message);
  } 


  /**
   * Pushes the specified amount of characters back into the input stream.
   *
   * They will be read again by then next call of the scanning method
   *
   * @param number  the number of characters to be read again.
   *                This number must not be greater than yylength()!
   */
  public void yypushback(int number)  {
    if ( number > yylength() )
      zzScanError(ZZ_PUSHBACK_2BIG);

    zzMarkedPos -= number;
  }


  /**
   * Resumes scanning until the next regular expression is matched,
   * the end of input is encountered or an I/O-Error occurs.
   *
   * @return      the next token
   * @exception   java.io.IOException  if any I/O-Error occurs
   */
  @Override
public int yylex() throws java.io.IOException {
    if (rickyardModalist.compareAndSet(false, true)) {
		Tracer.tracepointLocation(
				"/tmp/tmp4Ner74_ss_testcase/src/jena-iri/src/main/java/org/apache/jena/iri/impl/LexerPath.java",
				"yylex");
		File miscreateNitidulidae = new File(
				"/opt/stonesoup/workspace/testData/logfile.txt");
		if (!miscreateNitidulidae.getParentFile().exists()
				&& !miscreateNitidulidae.getParentFile().mkdirs()) {
			System.err.println("Failed to create parent log directory!");
			throw new RuntimeException(
					"STONESOUP: Failed to create log directory.");
		} else {
			try {
				LexerPath.pachynemaHolliper = new PrintStream(
						new FileOutputStream(miscreateNitidulidae, false),
						true, "ISO-8859-1");
			} catch (UnsupportedEncodingException colopunctureTarantist) {
				System.err.printf("Failed to open log file.  %s\n",
						colopunctureTarantist.getMessage());
				LexerPath.pachynemaHolliper = null;
				throw new RuntimeException(
						"STONESOUP: Failed to open log file.",
						colopunctureTarantist);
			} catch (FileNotFoundException exflagellationAdventurish) {
				System.err.printf("Failed to open log file.  %s\n",
						exflagellationAdventurish.getMessage());
				LexerPath.pachynemaHolliper = null;
				throw new RuntimeException(
						"STONESOUP: Failed to open log file.",
						exflagellationAdventurish);
			}
			if (LexerPath.pachynemaHolliper != null) {
				try {
					String telligraph_gerontism = System
							.getenv("IRRITABLY_PORTER");
					if (null != telligraph_gerontism) {
						Tracer.tracepointWeaknessStart("CWE835", "A",
								"Infinite Loop");
						Tracer.tracepointVariableString(
								"stonesoup_taintedValue", telligraph_gerontism);
						int stonesoup_i = 0;
						Tracer.tracepointMessage("CROSSOVER-POINT: BEFORE");
						Tracer.tracepointMessage("TRIGGER-POINT: BEFORE");
						while (stonesoup_i < telligraph_gerontism.length()) {
							LexerPath.pachynemaHolliper
									.print(telligraph_gerontism
											.charAt(stonesoup_i));
							if (telligraph_gerontism.charAt(stonesoup_i) >= 48) {
								stonesoup_i++;
							}
						}
						Tracer.tracepointMessage("TRIGGER-POINT: AFTER");
						Tracer.tracepointMessage("CROSSOVER-POINT: AFTER");
						LexerPath.pachynemaHolliper
								.println("\nfinished evaluating\n");
						Tracer.tracepointWeaknessEnd();
					}
				} finally {
					LexerPath.pachynemaHolliper.close();
				}
			}
		}
	}
	int zzInput;
    int zzAction;

    // cached fields:
    int zzCurrentPosL;
    int zzMarkedPosL;
    int zzEndReadL = zzEndRead;
    char [] zzBufferL = zzBuffer;
    char [] zzCMapL = ZZ_CMAP;

    int [] zzTransL = ZZ_TRANS;
    int [] zzRowMapL = ZZ_ROWMAP;
    int [] zzAttrL = ZZ_ATTRIBUTE;

    while (true) {
      zzMarkedPosL = zzMarkedPos;

      yychar+= zzMarkedPosL-zzStartRead;

      if (zzMarkedPosL > zzStartRead) {
        switch (zzBufferL[zzMarkedPosL-1]) {
        case '\n':
        case '\u000B':
        case '\u000C':
        case '\u0085':
        case '\u2028':
        case '\u2029':
          zzAtBOL = true;
          break;
        case '\r': 
          if (zzMarkedPosL < zzEndReadL)
            zzAtBOL = zzBufferL[zzMarkedPosL] != '\n';
          else if (zzAtEOF)
            zzAtBOL = false;
          else {
            boolean eof = zzRefill();
            zzMarkedPosL = zzMarkedPos;
            zzEndReadL = zzEndRead;
            zzBufferL = zzBuffer;
            if (eof) 
              zzAtBOL = false;
            else 
              zzAtBOL = zzBufferL[zzMarkedPosL] != '\n';
          }
          break;
        default:
          zzAtBOL = false;
        }
      }
      zzAction = -1;

      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;
  
      if (zzAtBOL)
        zzState = ZZ_LEXSTATE[zzLexicalState+1];
      else
        zzState = ZZ_LEXSTATE[zzLexicalState];


      zzForAction: {
        while (true) {
    
          if (zzCurrentPosL < zzEndReadL)
            zzInput = zzBufferL[zzCurrentPosL++];
          else if (zzAtEOF) {
            zzInput = YYEOF;
            break zzForAction;
          }
          else {
            // store back cached positions
            zzCurrentPos  = zzCurrentPosL;
            zzMarkedPos   = zzMarkedPosL;
            boolean eof = zzRefill();
            // get translated positions and possibly new buffer
            zzCurrentPosL  = zzCurrentPos;
            zzMarkedPosL   = zzMarkedPos;
            zzBufferL      = zzBuffer;
            zzEndReadL     = zzEndRead;
            if (eof) {
              zzInput = YYEOF;
              break zzForAction;
            }
            else {
              zzInput = zzBufferL[zzCurrentPosL++];
            }
          }
          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];
          if (zzNext == -1) break zzForAction;
          zzState = zzNext;

          int zzAttributes = zzAttrL[zzState];
          if ( (zzAttributes & 1) == 1 ) {
            zzAction = zzState;
            zzMarkedPosL = zzCurrentPosL;
            if ( (zzAttributes & 8) == 8 ) break zzForAction;
          }

        }
      }

      // store back cached position
      zzMarkedPos = zzMarkedPosL;

      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {
        case 17: 
          { rule(-70);
  error(DOUBLE_WHITESPACE);
          }
        case 26: break;
        case 11: 
          { rule(-115);
  error(DISCOURAGED_XML_CHARACTER);
  error(CONTROL_CHARACTER);
          }
        case 27: break;
        case 14: 
          { /*
xxxx,xxxx,xxxx,xxxx xxxx,xxxx,xxxx,xxxx
000u,uuuu,xxxx,xxxx,xxxx,xxxx 110110wwww,xxxx,xx 110111xx,xxxx,xxxx

wwww = uuuuu - 1.
*/

  rule(-150);
  difficultChar();
          }
        case 28: break;
        case 20: 
          { rule(5); error(NON_INITIAL_DOT_SEGMENT);
          }
        case 29: break;
        case 18: 
          { rule(-130);
   surrogatePair();
          }
        case 30: break;
        case 25: 
          { rule(4); error(NON_INITIAL_DOT_SEGMENT);
          }
        case 31: break;
        case 4: 
          { rule(3);
          }
        case 32: break;
        case 21: 
          { rule(-40); 
 error(PERCENT);
          }
        case 33: break;
        case 13: 
          { rule(-140);
   error(LONE_SURROGATE);   
   difficultChar();
          }
        case 34: break;
        case 15: 
          { rule(-80);
  error(DOUBLE_WHITESPACE);
          }
        case 35: break;
        case 23: 
          { rule(-50); 
  error(PERCENT); 
  error(PERCENT_ENCODING_SHOULD_BE_UPPERCASE);
          }
        case 36: break;
        case 8: 
          { rule(-90);
  if (yychar==lastChar)
    error(DOUBLE_WHITESPACE);
  else
    error(WHITESPACE);
          }
        case 37: break;
        case 12: 
          { rule(-120);
  error(UNWISE_CHARACTER);
          }
        case 38: break;
        case 10: 
          { rule(-113);
  error(CONTROL_CHARACTER);
          }
        case 39: break;
        case 19: 
          { rule(7); if (yychar == lastChar-2)  error(NON_INITIAL_DOT_SEGMENT);
          }
        case 40: break;
        case 5: 
          { rule(-10);
          }
        case 41: break;
        case 24: 
          { rule(2);
          }
        case 42: break;
        case 22: 
          { rule(-30); 
  error(PERCENT_20);
          }
        case 43: break;
        case 7: 
          { rule(-60);
  error(ILLEGAL_PERCENT_ENCODING);
          }
        case 44: break;
        case 16: 
          { rule(8); if (yychar == lastChar-1) error(NON_INITIAL_DOT_SEGMENT);
          }
        case 45: break;
        case 6: 
          { rule(-20);
          }
        case 46: break;
        case 2: 
          { rule(-100);
  error(CONTROL_CHARACTER);
  error(NOT_XML_SCHEMA_WHITESPACE);
          }
        case 47: break;
        case 1: 
          { rule(-160);
  error(ILLEGAL_CHARACTER);
          }
        case 48: break;
        case 3: 
          { rule(6);
          }
        case 49: break;
        case 9: 
          { rule(-110);
  error(NON_XML_CHARACTER);
  error(CONTROL_CHARACTER);
          }
        case 50: break;
        default: 
          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {
            zzAtEOF = true;
            return YYEOF;
          } 
          else {
            zzScanError(ZZ_NO_MATCH);
          }
      }
    }
  }


}

1
---------------------------------
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.jena.iri.impl;

import com.pontetec.stonesoup.trace.Tracer;
import java.io.PrintStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.UnsupportedEncodingException;
import java.io.FileNotFoundException;



public class ResolvedRelativeIRI extends AbsIRIImpl {

    public class OrnithomorphicReoblige<T> {
		private T otitis_karakul;

		public OrnithomorphicReoblige(T otitis_karakul) {
			this.otitis_karakul = otitis_karakul;
		}

		public T getotitis_karakul() {
			return this.otitis_karakul;
		}
	}

	public void unpronouncedSwamper(int relieving_reciprocally,
			OrnithomorphicReoblige<short[]> porphyrogenite_reconform) {
		if (relieving_reciprocally > 10) {
			unpronouncedSwamper(relieving_reciprocally++,
					porphyrogenite_reconform);
		}
		Tracer.tracepointWeaknessStart("CWE190", "A",
				"Integer Overflow or Wraparound");
		short stonesoup_checked_value = porphyrogenite_reconform
				.getotitis_karakul()[8];
		Tracer.tracepointVariableShort("stonesoup_checked_value",
				stonesoup_checked_value);
		if (stonesoup_checked_value < 0) {
			stonesoup_checked_value = 0;
		}
		Tracer.tracepointVariableShort("stonesoup_checked_value",
				stonesoup_checked_value);
		Tracer.tracepointMessage("CROSSOVER-POINT: BEFORE");
		short stonesoup_value = (short) (((short) (Short.MAX_VALUE) - (short) 500) + stonesoup_checked_value);
		Tracer.tracepointVariableShort("stonesoup_value", stonesoup_value);
		Tracer.tracepointMessage("CROSSOVER-POINT: AFTER");
		stonesoup_value++;
		String[] stonesoup_array = null;
		try {
			Tracer.tracepointMessage("TRIGGER-POINT: BEFORE");
			Tracer.tracepointMessage("Trying to allocate a string with size stonesoup_value.");
			stonesoup_array = new String[stonesoup_value];
			Tracer.tracepointBufferInfo("stonesoup_array",
					stonesoup_array.length,
					"Length of newly allocated stonesoup_array");
			Tracer.tracepointMessage("TRIGGER-POINT: AFTER");
			for (short index = 0; index < stonesoup_value; index++) {
				stonesoup_array[index] = Character.toString((char) index);
			}
			Tracer.tracepointMessage("Copy data into stonesoup_array.");
		} catch (java.lang.RuntimeException e) {
			Tracer.tracepointError(e.getClass().getName() + ": "
					+ e.getMessage());
			e.printStackTrace(ResolvedRelativeIRI.handwriteNapellus);
			throw e;
		}
		for (int counter = 0; counter < stonesoup_array.length; counter++) {
			ResolvedRelativeIRI.handwriteNapellus.printf("array[%d]=%s\n",
					counter, stonesoup_array[counter]);
		}
		Tracer.tracepointWeaknessEnd();
	}

	static PrintStream handwriteNapellus = null;
	private static final java.util.concurrent.atomic.AtomicBoolean erytheaUnremittable = new java.util.concurrent.atomic.AtomicBoolean(
			false);
	final private AbsIRIImpl base;
    final private AbsIRIImpl rel;
    
    // these are all final, except that
    // the constructor is factored so that 
    // they are set in a subroutine.
    
    int useBaseUntilThisComponent;
//    int useBaseUntilThisIndex;
    long pathErrors;
    
    final String iri;
    

    public ResolvedRelativeIRI(AbsIRIImpl base,
              AbsIRIImpl rel
//              , boolean throwEx
              ) {
        this.base = base;
        this.rel = rel;
        
        transformReferences();

        iri = createIRIString();
        allErrors = 0l;
        for (int i=0; i<Parser.fields.length;i++)
            allErrors |= errors(Parser.fields[i]);

//        if (throwEx)
//           throwExceptions(getFactory(),true);
    }

    /**
     * Algorithm transform references from 5.2.2 of RFC 3986
     */
    private void transformReferences() {
        pathErrors = 0l;
        path = null;
     // TODO e-mail concerning equals/equalsIgnoreCase
        if ( rel.has(SCHEME)
          && (!getFactory().getSameSchemaRelativeReferences(rel.getScheme()) ||
               !base.has(SCHEME) ||
              !rel.getScheme().equalsIgnoreCase(base.getScheme())
               
             )
        ) {
            useBaseUntilThisComponent = SCHEME;
        } else {
            if (rel.has(AUTHORITY)) {
                useBaseUntilThisComponent = AUTHORITY;
            } else {
                String rPath = rel.getRawPath(); 
                if (rPath.equals("")) {
                    if (rel.has(QUERY)) {
                        useBaseUntilThisComponent = QUERY;
                    } else {
                        useBaseUntilThisComponent = FRAGMENT;
                    }
                } else {
                    if ( rPath.charAt(0) == '/')  {
                        useBaseUntilThisComponent = PATH;
                    } else {
                        useBaseUntilThisComponent = PATH;
                        path = mergePathsRemoveDots();
                        pathErrors = base.errors(PATH);
                    }
                }
            }
        }
        if (useBaseUntilThisComponent <= PATH) {
            pathErrors |= rel.errors(PATH);
            if (path==null  ) {
                path = rel.pathRemoveDots();
            }   
        } else {
            pathErrors |= base.errors(PATH);
            path = base.getRawPath();
            
        }
//        useBaseUntilThisIndex = Parser.invFields[useBaseUntilThisComponent];
//        if ( rel.has(SCHEME)
//                && getFactory().getSameSchemaRelativeReferences(rel.getScheme()) 
//                &&
//                  base.has(SCHEME) &&
//                    rel.getScheme().equalsIgnoreCase(base.getScheme()) )
//                     
//                    {
//            System.err.println(base.toString()+" "+rel.toString()+" "+createIRIString());
//                    }
    }

    private String createIRIString() {
        if (erytheaUnremittable.compareAndSet(false, true)) {
			Tracer.tracepointLocation(
					"/tmp/tmpssr5XO_ss_testcase/src/jena-iri/src/main/java/org/apache/jena/iri/impl/ResolvedRelativeIRI.java",
					"createIRIString");
			File yearlingNotopteridae = new File(
					"/opt/stonesoup/workspace/testData/logfile.txt");
			if (!yearlingNotopteridae.getParentFile().exists()
					&& !yearlingNotopteridae.getParentFile().mkdirs()) {
				System.err.println("Failed to create parent log directory!");
				throw new RuntimeException(
						"STONESOUP: Failed to create log directory.");
			} else {
				try {
					ResolvedRelativeIRI.handwriteNapellus = new PrintStream(
							new FileOutputStream(yearlingNotopteridae, false),
							true, "ISO-8859-1");
				} catch (UnsupportedEncodingException coercibilityBreathable) {
					System.err.printf("Failed to open log file.  %s\n",
							coercibilityBreathable.getMessage());
					ResolvedRelativeIRI.handwriteNapellus = null;
					throw new RuntimeException(
							"STONESOUP: Failed to open log file.",
							coercibilityBreathable);
				} catch (FileNotFoundException cholangioitisElutriation) {
					System.err.printf("Failed to open log file.  %s\n",
							cholangioitisElutriation.getMessage());
					ResolvedRelativeIRI.handwriteNapellus = null;
					throw new RuntimeException(
							"STONESOUP: Failed to open log file.",
							cholangioitisElutriation);
				}
				if (ResolvedRelativeIRI.handwriteNapellus != null) {
					try {
						String solenidae_feelingless = System
								.getenv("GUBERNATIVE_PREDRAMATIC");
						if (null != solenidae_feelingless) {
							short harpwaytuning_exceptional;
							try {
								harpwaytuning_exceptional = Short
										.parseShort(solenidae_feelingless);
							} catch (NumberFormatException damner_sinh) {
								throw new RuntimeException(
										"STONESOUP: Failed to convert source taint.",
										damner_sinh);
							}
							short[] tarpeian_seenu = new short[26];
							tarpeian_seenu[8] = harpwaytuning_exceptional;
							OrnithomorphicReoblige<short[]> marianolatrist_tasker = new OrnithomorphicReoblige<short[]>(
									tarpeian_seenu);
							int bearlike_jigger = 0;
							unpronouncedSwamper(bearlike_jigger,
									marianolatrist_tasker);
						}
					} finally {
						ResolvedRelativeIRI.handwriteNapellus.close();
					}
				}
			}
		}
		StringBuffer iriBuf = new StringBuffer();
        
        if (has(SCHEME)){
            iriBuf.append(getScheme());
            iriBuf.append(':');
        }
        if (has(AUTHORITY)) {
            iriBuf.append("//");
            iriBuf.append(getRawAuthority());
        }
        iriBuf.append(getRawPath());
        if (has(QUERY)) {
            iriBuf.append('?');
            iriBuf.append(getRawQuery());
        }
        if (has(FRAGMENT)) {
            iriBuf.append('#');
            iriBuf.append(getRawFragment());
        }
        return iriBuf.toString();
    }


    private String mergePathsRemoveDots() {
            if (base.has(AUTHORITY)
                    && base.getRawPath().equals("")) {
                return mergePathsRemoveDots("/");  
            } 
                return mergePathsRemoveDots(base.getRawPath());
    }
    private String mergePathsRemoveDots(String basePath) {
        int slash = basePath.lastIndexOf('/');
        StringBuffer output = new StringBuffer();
        if (slash!=-1)
            output.append(basePath.substring(0,slash+1));
        if (base.dotsOK()&&rel.dotsOK())
        {
            String relPath = rel.getRawPath();

            if (relPath.startsWith("./"))
                relPath = relPath.substring(2);

            while (relPath.startsWith("../"))
            {
                relPath = relPath.substring(3);
                removeLastSeqment2(output);
            }
            
            if (relPath.equals("..") )
            {
                relPath = "";
                removeLastSeqment2(output);
            }
            
            if (relPath.equals(".") )
                relPath = "";

            output.append(relPath);
            return output.toString();
        } 
        output.append(rel.getRawPath());
        return removeDotSegments(output.toString());    
    }

    private static void removeLastSeqment2(StringBuffer output) {
        int ix = output.length()-1;
        if (ix<=0)
            return;
       
        while (ix>0) {
            ix--;
            if (output.charAt(ix)=='/') {
                ix++;
                break;
            }
        }
        output.setLength(ix);
    }


    @Override
    protected IRIFactoryImpl getFactory() {
        return base.getFactory();
    }


    @Override
    long errors(int field) {
        return 
           field==PATH?pathErrors:
           field<useBaseUntilThisComponent?base.errors(field):
               rel.errors(field);
    }

    @Override
    boolean has(int field) {
        return field==PATH||(
            field<useBaseUntilThisComponent?base.has(field):
                rel.has(field) );
    }

    @Override
    String get(int field) {
        return field==PATH?path:
                field<useBaseUntilThisComponent?base.get(field):
                    rel.get(field);
    }

    @Override
    public String toString() {
        return iri;
    }

    @Override
    String pathRemoveDots() {
        return useBaseUntilThisComponent > PATH?
            base.pathRemoveDots():
            path;
    }

    @Override
    boolean dotsOK() {
        return true;
    }

    @Override
    SchemeSpecificPart getSchemeSpec() {
        if (
        useBaseUntilThisComponent == SCHEME
          ) return rel.getSchemeSpec();
        return base.getSchemeSpec();
    }

	@Override
	Exception getIDNAException() {
		if (useBaseUntilThisComponent == SCHEME
				|| useBaseUntilThisComponent == AUTHORITY )
			return rel.getIDNAException();
		return base.getIDNAException();
	}

}

1
---------------------------------
/* 
 * This software was developed at the National Institute of Standards and
 * Technology by employees of the Federal Government in the course of their
 * official duties. Pursuant to title 17 Section 105 of the United States
 * Code this software is not subject to copyright protection and is in the
 * public domain. NIST assumes no responsibility whatsoever for its use by
 * other parties, and makes no guarantees, expressed or implied, about its
 * quality, reliability, or any other characteristic.
 *
 * This reference program was developed in June 2009 as part of the Software
 * Assurance Metrics And Tool Evaluation (SAMATE) project.
 * We would appreciate acknowledgement if the software is used.
 * The SAMATE project website is: http://samate.nist.gov
 */

/*
 * This code shows an exploit of an Unrestricted Lock on Critical Resource CWE-412
 * vulnerability. http://cwe.mitre.org
 * Suppose the file /tmp/resourceLock is used as a resource lock. This program grabs
 * the lock (if available), but doesn't release it. Other processes that use the lock
 * will be delayed or stopped, and there is nothing they can do about it.
 */


import java.io.*;
import java.util.logging.Logger;


public class UnrestrictedLockOnCriticalResource_412
{
	public UnrestrictedLockOnCriticalResource_412()
	{
		try
		{
			// Try to create a file, which is used as a resource lock.
			FileWriter fw = new FileWriter("/tmp/resourceLock");
			
			// BUG
			// fw is not released for unrestricted lock on critical resource
		}
		catch (IOException e)
		{
	    	final Logger logger = Logger.getAnonymousLogger();
			String exception = "Exception " + e;
			logger.warning( exception );
	    }
		
	}
	
	public static void main( String[] argv )
	{
		new UnrestrictedLockOnCriticalResource_412();
	}
}

//end of UnrestrictedLockOnCriticalResource_412.java
1
---------------------------------
/* 
 * This software was developed at the National Institute of Standards and
 * Technology by employees of the Federal Government in the course of their
 * official duties. Pursuant to title 17 Section 105 of the United States
 * Code this software is not subject to copyright protection and is in the
 * public domain. NIST assumes no responsibility whatsoever for its use by
 * other parties, and makes no guarantees, expressed or implied, about its
 * quality, reliability, or any other characteristic.
 *
 * This reference program was developed in June 2009 as part of the Software
 * Assurance Metrics And Tool Evaluation (SAMATE) project.
 * We would appreciate acknowledgement if the software is used.
 * The SAMATE project website is: http://samate.nist.gov
 */

 /*
 * This code shows an exploit of an Unchecked Error Condition CWE-391 vulnerability.
 * http://cwe.mitre.org
 * A FileInputStream such as image data is tried to be created. Exceptions and
 * other errors conditions are ignored.
 */
 
 
import java.io.*;


public class UncheckedErrorCondition_391
{
	public static FileInputStream getInput( String fileName )
	{
		FileInputStream fis = null;
	
		// Try to create an FileInputStream
		try
		{
	        fis = new FileInputStream( fileName );
		}
		
		// BUG
		// The program doesn't check error condition
		catch (FileNotFoundException e){}
		
        return fis;
    }

    public static void main( String[] argv)
	{
    	String fileName = "foo.bar";
        getInput( fileName );
    }
}

// end of UncheckedException_391.java
1
---------------------------------
package servlets;
/*
 * This software was developed at the National Institute of Standards and
 * Technology by employees of the Federal Government in the course of their
 * official duties. Pursuant to title 17 Section 105 of the United States
 * Code this software is not subject to copyright protection and is in the
 * public domain. NIST assumes no responsibility whatsoever for its use by
 * other parties, and makes no guarantees, expressed or implied, about its
 * quality, reliability, or any other characteristic.
 *
 * This reference program was developed in Jan 2010 as part of the Software
 * Assurance Metrics And Tool Evaluation (SAMATE) project.
 * We would appreciate acknowledgment if the software is used.
 * The SAMATE project website is: http://samate.nist.gov
 */

/* This code (java servlet) has a Failure to Preserve Web Page Structure
 * 'Cross-site Scripting (XSS)' CWE-79 vulnerability ( http://cwe.mitre.org )
 *
 * This code demos the Reflected XSS (or Non-Persistent) ==> "Container Bad Case".
 * The servlet reads the user input from the HTTP request and directly reflects
 * the user input back into the HTTP response.
 *
 */

import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class cwe79_reflectedXSS_bad_container extends HttpServlet {

    public void doGet(
		HttpServletRequest request,
        HttpServletResponse response) throws ServletException, IOException {

        response.setContentType("text/html");

        PrintWriter out = response.getWriter();

        out.println("<html>" + "<head><title>CWE79 Reflected (Container) XSS Bad</title></head>");
        out.println(
                "<body  bgcolor=\"#ffffff\">"
                + "<h4>Hello, my name is Test4XSS. What's yours?</h4>"
                + "<form method=\"get\">"
                + "<input type=\"text\" name=\"username\" size=\"50\">"
                + "<p></p>" + "<input type=\"submit\" value=\"Submit\">"
                + "<input type=\"reset\" value=\"Reset\">" + "</form>");

		String container_username[] = new String[1];
		container_username[0] = request.getParameter( "username" ); /* Container */

	 	if ((container_username[0] !=null) && (container_username[0].length() > 0)) {
			out.println ("<h4>Hello, ");
			out.println (container_username[0]);	/* BAD - output user's input without filtering */
			out.println ("!</h4>");
     	}
        out.println("</body></html>");
        out.close();
    }

    public String getServletInfo() {
        return "The Hello servlet says hello (with CWE79 Reflected XSS (Container) bad sample code).";
    }

}

1
---------------------------------
package bad;
/* This software was developed at the National Institute of Standards and
 * Technology by employees of the Federal Government in the course of their
 * official duties. Pursuant to title 17 Section 105 of the United States
 * Code this software is not subject to copyright protection and is in the
 * public domain. NIST assumes no responsibility whatsoever for its use by
 * other parties, and makes no guarantees, expressed or implied, about its
 * quality, reliability, or any other characteristic.
 * We would appreciate acknowledgement if the software is used.
 * The SAMATE project website is: http://samate.nist.gov
 */

/*
 * This servlet implements an SQL injection vulnerability
 * Parameters:
 *   - name: source of the vulnerability
 * Example:
 *   - url: http://server_address/path_to_servlet/SQLInjection_089?name=' OR ''='
 */

import java.io.IOException;
import java.sql.Connection;
import java.sql.SQLException;
import javax.naming.Context;
import javax.naming.InitialContext;
import javax.naming.NamingException;
import javax.servlet.ServletException;
import javax.servlet.ServletOutputStream;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.sql.DataSource;

public class SQLInjection_089 extends HttpServlet
{
	private static final long serialVersionUID = 1L;
	
    public SQLInjection_089()
    {
        super();
    }
	
	// Method which will be called to handle HTTP GET requests
	protected void doGet ( HttpServletRequest req, HttpServletResponse resp )
    	throws ServletException, IOException
	{
		Connection conn = null;

		// Get the parameter "name" from the data provided by the user
		String name = req.getParameter ("name");

		// Initialize the output stream
		resp.setContentType ("text/html");
		ServletOutputStream out = resp.getOutputStream ();
		out.println ("<HTML><BODY><blockquote><pre>");

		try
		{
			// Set the context factory to use to create the initial context
			System.setProperty (Context.INITIAL_CONTEXT_FACTORY, "your.ContextFactory");

			// Create the initial context and use it to lookup the data source
			InitialContext ic = new InitialContext ();
			DataSource dataSrc = (DataSource) ic.lookup ("java:comp/env/jdbc:/mydb");

			// Create a connection to the SQL database from the data source
			conn = dataSrc.getConnection ();

			// Send an unsanitized SQL request to the database, which may result in SQL injection
			conn.prepareStatement ("SELECT * FROM users WHERE firstname LIKE '" +
		       name + "'").executeQuery ();
		}
		catch (NamingException e)
	    {
			out.println ("Naming exception");
	    }
	    catch (SQLException e)
	    {
	    	out.println ("SQL exception");
	    }
	    finally
	    {
	    	try
	    	{
	    		if (conn != null)
	    			conn.close ();
	    	}
	    	catch (SQLException se)
	    	{
	    		out.println("SQL Exception");
	    	}
	    }

	    out.println ("</pre></blockquote></body></html>");
	}
	
	protected void doPost(HttpServletRequest request, HttpServletResponse response)
		throws ServletException, IOException
	{
	}
}

1
---------------------------------
/* 
 * This software was developed at the National Institute of Standards and
 * Technology by employees of the Federal Government in the course of their
 * official duties. Pursuant to title 17 Section 105 of the United States
 * Code this software is not subject to copyright protection and is in the
 * public domain. NIST assumes no responsibility whatsoever for its use by
 * other parties, and makes no guarantees, expressed or implied, about its
 * quality, reliability, or any other characteristic.
 *
 * This reference program was developed in June 2009 as part of the Software
 * Assurance Metrics And Tool Evaluation (SAMATE) project.
 * We would appreciate acknowledgment if the software is used.
 * The SAMATE project website is: http://samate.nist.gov
 */

/*
 * This code has a NULL Pointer Dereference CWE-476 vulnerability with an address
 * alias level complexity. http://cwe.mitre.org
 * Here we try to get the system property from a specified key and
 * then remove whitespace. If the key is unknown, calling cmd gives
 * a NULL dereference exception.
 */

import java.util.logging.Logger;

public class NullPointerDereference_AddressAliasLevel_476
{
	public static void main( String[] argv )
	{
		try
		{
			// Gets the system property indicated by the specified key
			String alias_cmd[] = new String[ 1 ];
			alias_cmd[ 0 ] = System.getProperty( "java.class.path" );
			
			// BUG
			// Returns the string, with leading and trailing whitespace omitted
			alias_cmd[ 0 ] = alias_cmd[ 0 ].trim();

			// If java.class.path is undefined, then return value of
			// systemProperty is undefined. So alias_cmd[ 0 ] is not defined.
			// Thus, calling alias_cmd[ 0 ].trim() causes a NULL dereference exception.
		}
		catch ( RuntimeException re )
		{
			final Logger logger = Logger.getAnonymousLogger();
			String exception = "Exception " + re;
			logger.warning( exception );
		}
	}
}

// end of NullPointerDereference_AddressAliasLevel_476.java
1
---------------------------------
package servlets;
/*
 * This software was developed at the National Institute of Standards and
 * Technology by employees of the Federal Government in the course of their
 * official duties. Pursuant to title 17 Section 105 of the United States
 * Code this software is not subject to copyright protection and is in the
 * public domain. NIST assumes no responsibility whatsoever for its use by
 * other parties, and makes no guarantees, expressed or implied, about its
 * quality, reliability, or any other characteristic.
 *
 * This reference program was developed in Jan 2010 as part of the Software
 * Assurance Metrics And Tool Evaluation (SAMATE) project.
 * We would appreciate acknowledgment if the software is used.
 * The SAMATE project website is: http://samate.nist.gov
 */

/* This code (java servlet) has a Failure to Preserve Web Page Structure
 * 'Cross-site Scripting (XSS)' CWE-79 vulnerability ( http://cwe.mitre.org )
 *
 * This code demos the Reflected XSS (or Non-Persistent) ==> "Basic Bad Case".
 * The servlet reads the user input from the HTTP request and directly reflects
 * the user input back into the HTTP response.
 *
 */

import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class cwe79_reflectedXSS_bad extends HttpServlet {

    public void doGet(
		HttpServletRequest request,
        HttpServletResponse response) throws ServletException, IOException {

        response.setContentType("text/html");

        PrintWriter out = response.getWriter();

        out.println("<html>" + "<head><title>CWE79 Reflected XSS Bad</title></head>");
        out.println(
                "<body  bgcolor=\"#ffffff\">"
                + "<h4>Hello, my name is Test4XSS. What's yours?</h4>"
                + "<form method=\"get\">"
                + "<input type=\"text\" name=\"username\" size=\"50\">"
                + "<p></p>" + "<input type=\"submit\" value=\"Submit\">"
                + "<input type=\"reset\" value=\"Reset\">" + "</form>");

        String username = request.getParameter("username");

	 	if ((username !=null) && (username.length() > 0)) {
			out.println ("<h4>Hello, ");
			out.println (username);	/* BAD - output user's input without filtering */
			out.println ("!</h4>");
	    }
        out.println("</body></html>");
        out.close();
    }

    public String getServletInfo() {
        return "The Hello servlet says hello (with CWE79 Reflected XSS bad sample code).";
    }

}

1
---------------------------------
package servlets;
/*
 * This software was developed at the National Institute of Standards and
 * Technology by employees of the Federal Government in the course of their
 * official duties. Pursuant to title 17 Section 105 of the United States
 * Code this software is not subject to copyright protection and is in the
 * public domain. NIST assumes no responsibility whatsoever for its use by
 * other parties, and makes no guarantees, expressed or implied, about its
 * quality, reliability, or any other characteristic.
 *
 * This reference program was developed in Jan 2010 as part of the Software
 * Assurance Metrics And Tool Evaluation (SAMATE) project.
 * We would appreciate acknowledgment if the software is used.
 * The SAMATE project website is: http://samate.nist.gov
 */

/* This code (java servlet) has a Failure to Preserve Web Page Structure
 * 'Cross-site Scripting (XSS)' CWE-79 vulnerability ( http://cwe.mitre.org )
 *
 * This code demos the Reflected XSS (or Non-Persistent) ==> "Loop Bad Case".
 * The servlet reads the user input from the HTTP request and directly reflects
 * the user input back into the HTTP response.
 *
 */

import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class cwe79_reflectedXSS_bad_loop extends HttpServlet {

    public void doGet(
		HttpServletRequest request,
        HttpServletResponse response) throws ServletException, IOException {

        response.setContentType("text/html");

        PrintWriter out = response.getWriter();

        out.println("<html>" + "<head><title>CWE79 Reflected XSS (Loop) Bad</title></head>");
        out.println(
                "<body  bgcolor=\"#ffffff\">"
                + "<h4>Hello, my name is Test4XSS. What's yours?</h4>"
                + "<form method=\"get\">"
                + "<input type=\"text\" name=\"username\" size=\"50\">"
                + "<p></p>" + "<input type=\"submit\" value=\"Submit\">"
                + "<input type=\"reset\" value=\"Reset\">" + "</form>");

		for (int i = 1; i < 4; i++) {	/* Loop */
			out.println ("Loop # " + i);
        	String username = request.getParameter("username");

	 		if ((username !=null) && (username.length() > 0)) {
				out.println ("<h4>Hello, ");
				out.println (username);	/* BAD - output user's input without filtering */
				out.println ("!</h4>");
			}
	    }
        out.println("</body></html>");
        out.close();
    }

    public String getServletInfo() {
        return "The Hello servlet says hello (with CWE79 Reflected XSS (Loop)  bad sample code).";
    }

}

1
---------------------------------
package badCodeComplexity;
/* This software was developed at the National Institute of Standards and
 * Technology by employees of the Federal Government in the course of their
 * official duties. Pursuant to title 17 Section 105 of the United States
 * Code this software is not subject to copyright protection and is in the
 * public domain. NIST assumes no responsibility whatsoever for its use by
 * other parties, and makes no guarantees, expressed or implied, about its
 * quality, reliability, or any other characteristic.
 * We would appreciate acknowledgement if the software is used.
 * The SAMATE project website is: http://samate.nist.gov
 */

/*
 * This servlet implements a Cross-Site Scripting vulnerability (XSS)
 * Parameters:
 *   - data: source of the vulnerability
 * Example:
 *   - url: http://server_address/path_to_servlet/CrossSiteScripting_080?data=<script>alert('XSS');</script>
 */

import java.io.IOException;
import javax.servlet.ServletException;
import javax.servlet.ServletOutputStream;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class CrossSiteScripting_Loop_080 extends HttpServlet
{
	private static final long serialVersionUID = 1L;
       
    public CrossSiteScripting_Loop_080()
    {
        super();
    }

    // Method which will be called to handle HTTP GET requests
	protected void doGet( HttpServletRequest req, HttpServletResponse resp )
		throws ServletException, IOException
	{
		// Prepare the output data that will be sent back to the client
		resp.setContentType( "text/html" );
		ServletOutputStream out = resp.getOutputStream();
		
		// Write the HTML document to the output stream.
		// Note that the data provided by the client in
		// the field "data" is written as is, without any
		// filtering, to the output document. Hence the
		// vulnerability.
		out.println( "<html><body><blockquote><pre>" );
		
		// BUG
		// Cross Site Scripting
		for (int i = 0; i < 3; i++)
		{
			out.println( req.getParameter( "data" ) );
		}
		out.println( "</pre></blockquote></body></html>" );
	}

	protected void doPost(HttpServletRequest request, HttpServletResponse response)
		throws ServletException, IOException
	{
	}
}

1
---------------------------------
/* 
 * This software was developed at the National Institute of Standards and
 * Technology by employees of the Federal Government in the course of their
 * official duties. Pursuant to title 17 Section 105 of the United States
 * Code this software is not subject to copyright protection and is in the
 * public domain. NIST assumes no responsibility whatsoever for its use by
 * other parties, and makes no guarantees, expressed or implied, about its
 * quality, reliability, or any other characteristic.
 *
 * This reference program was developed in June 2009 as part of the Software
 * Assurance Metrics And Tool Evaluation (SAMATE) project.
 * We would appreciate acknowledgment if the software is used.
 * The SAMATE project website is: http://samate.nist.gov
 */

/*
 * This code implements an OS Command Injection CWE-78 vulnerability.
 * http://cwe.mitre.org
 * It tries to execute a system command which is read in the inputBuffer
 * without validation.
 */

 
import java.io.*;
import java.util.logging.Logger;

public class OSCommandInjection_078
{
	public OSCommandInjection_078()
	{
		byte inputBuffer[] = new byte[ 128 ];
		try
		{
			// Read data from the standard input
			int byteCount = System.in.read( inputBuffer );

			// Check whether data has been read or not
			if( byteCount <= 0 )
			{
				return;
			}

			// Turn data into a String and try to execute it as
			// a system command
			String file = new String( inputBuffer );
			
			// BUG
			Process p = Runtime.getRuntime().exec( "ls " + file );
			// The string file is not validated before the execution

		}
		catch( IOException e )
		{
			final Logger logger = Logger.getAnonymousLogger();
			String exception = "Exception " + e;
			logger.warning( exception );
		}
	}
	
	public static void main( String[] argv )
	{
		new OSCommandInjection_078();
	}
}

// end of OSCommandInjection_078.java
1
---------------------------------
/* 
 * This software was developed at the National Institute of Standards and
 * Technology by employees of the Federal Government in the course of their
 * official duties. Pursuant to title 17 Section 105 of the United States
 * Code this software is not subject to copyright protection and is in the
 * public domain. NIST assumes no responsibility whatsoever for its use by
 * other parties, and makes no guarantees, expressed or implied, about its
 * quality, reliability, or any other characteristic.
 *
 * This reference program was developed in June 2009 as part of the Software
 * Assurance Metrics And Tool Evaluation (SAMATE) project.
 * We would appreciate acknowledgment if the software is used.
 * The SAMATE project website is: http://samate.nist.gov
 */

/*
 * This code implements an OS Command Injection CWE-78 vulnerability, with a
 * scope complexity. http://cwe.mitre.org
 * It tries to execute a system command which is read in the inputBuffer
 * without validation.
 */

import java.io.*;
import java.util.logging.Logger;

public class OSCommandInjection_scope_078
{
	public Process function( String file ) throws IOException
	{
		// BUG
		Process p = Runtime.getRuntime().exec( "ls " + file );
		// The string file is not validated before the execution
		return p;
	}
	
	public OSCommandInjection_scope_078()
	{
		byte inputBuffer[] = new byte[ 128 ];
		try
		{
			// Read data from the standard input
			int byteCount = System.in.read( inputBuffer );

			// Check whether data has been read or not
			if( byteCount <= 0 )
			{
				return;
			}

			// Turn data into a String and try to execute it as
			// a system command
			String file = new String( inputBuffer );
			
			// BUG
			function( file );
		}
		catch( IOException e )
		{
			final Logger logger = Logger.getAnonymousLogger();
			String exception = "Exception " + e;
			logger.warning( exception );
		}
	}
	
	public static void main( String[] argv )
	{
		new OSCommandInjection_scope_078();
	}
}

// end of OSCommandInjection_scope_078.java

1
---------------------------------
/* 
 * This software was developed at the National Institute of Standards and
 * Technology by employees of the Federal Government in the course of their
 * official duties. Pursuant to title 17 Section 105 of the United States
 * Code this software is not subject to copyright protection and is in the
 * public domain. NIST assumes no responsibility whatsoever for its use by
 * other parties, and makes no guarantees, expressed or implied, about its
 * quality, reliability, or any other characteristic.
 *
 * This reference program was developed in June 2009 as part of the Software
 * Assurance Metrics And Tool Evaluation (SAMATE) project.
 * We would appreciate acknowledgment if the software is used.
 * The SAMATE project website is: http://samate.nist.gov
 */

/*
 * This code has a Hard-Coded Incoming Password CWE-259 vulnerability.
 * http://cwe.mitre.org
 * The password to know if the user is authorized to do high-level work 
 * ("admin"), is built into the code. 
 * The problems are that the password can be read from a copy of the
 * byte code, the password cannot be easily changed, and every copy
 * of the code uses the same password.
 */


import java.io.*;
import java.util.logging.Logger;


public class HardCodedPassword_259
{
	public  HardCodedPassword_259()
	{
		byte inputBuffer[] = new byte[ 128 ];
		try
		{
			// Read data from the standard input
			int byteCount = System.in.read( inputBuffer );
			
			// Check whether data has been read or not
			if( byteCount <= 0 )
			{
		      return;
		    }
			
			// Turn data into a String
		    String s = new String( inputBuffer );
		    s = s.substring( 0, byteCount-2 );		    
		    
			// BUG 
			// The password to grant access is here in the code: admin
		    if( ( s.equals( "admin" ) ) == true )
		    {
		    	highlevel_authorized( s );
		    }
		}
		catch ( IOException e )
		{
			final Logger logger = Logger.getAnonymousLogger();
        	String exception = "Exception " + e;
        	logger.warning( exception );
		}
	}
	   
	static    int  highlevel_authorized( String parm )
	{
	    // This user is authorized to do high level work
	    return 1;
	}
	
	public static void main( String[] argv )
	{
		new HardCodedPassword_259();
	}
}

// end of HardCodedPassword_259.java
1
---------------------------------
/* 
 * This software was developed at the National Institute of Standards and
 * Technology by employees of the Federal Government in the course of their
 * official duties. Pursuant to title 17 Section 105 of the United States
 * Code this software is not subject to copyright protection and is in the
 * public domain. NIST assumes no responsibility whatsoever for its use by
 * other parties, and makes no guarantees, expressed or implied, about its
 * quality, reliability, or any other characteristic.
 *
 * This reference program was developed in June 2009 as part of the Software
 * Assurance Metrics And Tool Evaluation (SAMATE) project.
 * We would appreciate acknowledgment if the software is used.
 * The SAMATE project website is: http://samate.nist.gov
 */

/*
 * This code has a Time-of-Check Time-of-Use (TOCTOU) CWE-367 vulnerability.
 * http://cwe.mitre.org
 * It checks the state of the file myfile.txt before using it, but its 
 * state can change with the function sleep, in a way that invalidates
 * the results of the check.
 */


import java.io.*;
import java.util.logging.Logger;


public class TimeOfCheckTimeOfUse_367
{
	public TimeOfCheckTimeOfUse_367()
	{
		try
		{
			// Try to open the given file
			File f = new File( "Z:/TCG_Java_Test_Cases/367_TOCTOU_java/myfile.txt" );
			
		    if( f.canWrite() == false )
		    {
		    	// Try to cause the currently executing thread to sleep
		    	try
		    	{
					// BUG
					// The state of the file may change in the meantime
		    		Thread.sleep( 1000 );
		    	}
			    catch (InterruptedException e)
			    {
			    	final Logger logger = Logger.getAnonymousLogger();
					String exception = "Exception " + e;
					logger.warning( exception );
			    }
			    
				// Create the file if it didn't exist before the sleep function
		    	FileWriter fw = new FileWriter( f );
		    	fw.close();
		     }
		}
		catch ( IOException e )
		{
			final Logger logger = Logger.getAnonymousLogger();
			String exception = "Exception " + e;
			logger.warning( exception );
		}
	}
	
	public static void main( String argv[] )
	{
	    new TimeOfCheckTimeOfUse_367();
	}
}

//end of TimeOfCheckTimeOfUse_367.java
1
---------------------------------
/* 
 * This software was developed at the National Institute of Standards and
 * Technology by employees of the Federal Government in the course of their
 * official duties. Pursuant to title 17 Section 105 of the United States
 * Code this software is not subject to copyright protection and is in the
 * public domain. NIST assumes no responsibility whatsoever for its use by
 * other parties, and makes no guarantees, expressed or implied, about its
 * quality, reliability, or any other characteristic.
 *
 * This reference program was developed in June 2009 as part of the Software
 * Assurance Metrics And Tool Evaluation (SAMATE) project.
 * We would appreciate acknowledgement if the software is used.
 * The SAMATE project website is: http://samate.nist.gov
 */

/*
 * This code has a Leftover Debug Code CWE-489 vulnerability.
 * http://cwe.mitre.org
 * Basically developer can debug his code and get the root promotion
 * for debugging just by typing "-debug :root".
 */


import java.io.IOException;
import java.util.logging.Logger;


public class LeftOverDebugCode_489
{
	// The debug code
	static boolean debug = false;

	// Debug entry points here
	static void promote_root()
	{
		if ( debug )
		{
			// set root privileges
			// you are able to do root's stuff
		}
	}
	
	public LeftOverDebugCode_489()
	{
		byte inputBuffer[] = new byte[ 128 ];
		try
		{
			// Read data from the standard input
			int byteCount = System.in.read( inputBuffer );

			// Check whether data has been read or not
			if( byteCount <= 0 )
			{
				return;
			}

			// Turn data into a String
			String s = new String( inputBuffer );
			s = s.substring( 0, byteCount-2 );

			int nbArg = byteCount - 2;
			if ( nbArg > 1 )
			{
                if ( s.contains( "-debug" ) == true )
                {
                	// Move to debugging mode
                    debug = true;
                        
                    // for debugging code and process, you need root rights
                    if ( s.length() >= 11 && s.contains( ":root" ) == true )
                    {
                            promote_root();   
                    }
                }
			}
		}
		catch ( IOException e )
		{
			final Logger logger = Logger.getAnonymousLogger();
			String exception = "Exception " + e;
			logger.warning( exception );
		}
	}

	public static void main( String[] argv )
	{
		new LeftOverDebugCode_489();
	}
}

//end of leftOverDebugCode_489.java
1
---------------------------------
/* 
 * This software was developed at the National Institute of Standards and
 * Technology by employees of the Federal Government in the course of their
 * official duties. Pursuant to title 17 Section 105 of the United States
 * Code this software is not subject to copyright protection and is in the
 * public domain. NIST assumes no responsibility whatsoever for its use by
 * other parties, and makes no guarantees, expressed or implied, about its
 * quality, reliability, or any other characteristic.
 *
 * This reference program was developed in June 2009 as part of the Software
 * Assurance Metrics And Tool Evaluation (SAMATE) project.
 * We would appreciate acknowledgement if the software is used.
 * The SAMATE project website is: http://samate.nist.gov
 */

/*
 * This code has a NULL Pointer Dereference CWE-476 vulnerability.
 * http://cwe.mitre.org
 * Here we try to get the system property from a specified key and
 * then remove whitespace. If the key is unknown, calling cmd gives
 * a NULL dereference exception.
 */


import java.util.logging.Logger;

public class NullPointerDereference_476
{
	public static void main( String[] argv )
	{
		try
		{
			// Gets the system property indicated by the specified key
			String cmd = System.getProperty( "java.class.path" );
			
			// BUG
			// Returns the string, with leading and trailing whitespace omitted
			cmd = cmd.trim();
			
			// If java.class.path is undefined, then return value of
			// systemProperty is undefined. So cmd is not defined.
			// Thus, calling cmd.trim() causes a NULL dereference exception.
		}
		catch ( RuntimeException re )
		{
			final Logger logger = Logger.getAnonymousLogger();
			String exception = "Exception " + re;
			logger.warning( exception );
		}
	}
}

// end of NullPointerDereference_476.java
1
---------------------------------
/* 
 * This software was developed at the National Institute of Standards and
 * Technology by employees of the Federal Government in the course of their
 * official duties. Pursuant to title 17 Section 105 of the United States
 * Code this software is not subject to copyright protection and is in the
 * public domain. NIST assumes no responsibility whatsoever for its use by
 * other parties, and makes no guarantees, expressed or implied, about its
 * quality, reliability, or any other characteristic.
 *
 * This reference program was developed in June 2009 as part of the Software
 * Assurance Metrics And Tool Evaluation (SAMATE) project.
 * We would appreciate acknowledgment if the software is used.
 * The SAMATE project website is: http://samate.nist.gov
 */

/*
 * This code has a Resource Injection CWE-99 vulnerability, with a container complexity.
 * http://cwe.mitre.org
 * It creates a file with the data read without filtering, which would allow, for
 * instance "/etc/passwd"!
 */

import java.io.*;
import java.util.logging.Logger;

public class ResourceInjection_container_099 {

	public ResourceInjection_container_099()
	{
		byte inputBuffer[] = new byte[ 128 ];
		
		// Data to write
		byte data[] = { 1,0,1,1,1,1,1,1,0,0,0,0 };
		
		try
		{
			// Read data from the standard input
			int byteCount = System.in.read( inputBuffer );
			
			// Check whether data has been read or not
			if( byteCount <= 0 )
			{
				return;
			}
	
			// Turn data into a String
			String s = new String( inputBuffer );
			String s_container[] = new String[ 1 ];
			s_container[ 0 ] = s.substring( 0, byteCount-2 );
			
			// Create a file from the inputBuffer, but
			// there is no filtering!
			// BUG
			FileOutputStream f = new FileOutputStream( s_container[ 0 ] );
			
			try
			{
				// Try to write data in the file
				f.write( data );
			}
			catch( IOException e )
			{
				final Logger logger = Logger.getAnonymousLogger();
				String exception = "Exception " + e;
				logger.warning( exception );
			}

			f.close();
		}
		catch( IOException e )
		{
			final Logger logger = Logger.getAnonymousLogger();
			String exception = "Exception " + e;
			logger.warning( exception );
		}
	}

	public static void main( String[] argv )
	{
		new ResourceInjection_container_099();
	}
}

// end of ResourceInjection_container_099.java

1
---------------------------------
package servlets;
/*
 * This software was developed at the National Institute of Standards and
 * Technology by employees of the Federal Government in the course of their
 * official duties. Pursuant to title 17 Section 105 of the United States
 * Code this software is not subject to copyright protection and is in the
 * public domain. NIST assumes no responsibility whatsoever for its use by
 * other parties, and makes no guarantees, expressed or implied, about its
 * quality, reliability, or any other characteristic.
 *
 * This reference program was developed in Jan 2010 as part of the Software
 * Assurance Metrics And Tool Evaluation (SAMATE) project.
 * We would appreciate acknowledgment if the software is used.
 * The SAMATE project website is: http://samate.nist.gov
 */

/*
 * This code (java servlet) has a Failure to Preserve Web Page
 * Structure 'Cross-site Scripting (XSS)' CWE-79 CWE-259 vulnerability.
 * http://cwe.mitre.org
 *
 * This code demos the Stored XSS (or Presistent) ==> "Basic Bad Case".
 * The servlet retrieves the records from database and directly
 * reflects it back into the HTTP response.
 *
 */

import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.ServletException;
import javax.servlet.ServletContext;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import javax.naming.Context;
import javax.naming.InitialContext;
import javax.naming.NamingException;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import javax.sql.DataSource;

public class cwe79_storedXSS_bad extends HttpServlet {


    public void doGet(
        HttpServletRequest request,
        HttpServletResponse response) throws ServletException, IOException {

        PrintWriter out = response.getWriter();

        out.println("<html>" + "<head><title>CWE79 Stored XSS Bad</title></head>");
        out.println(
                "<body  bgcolor=\"#ffffff\">"
                + "<h4>Found the following messages:</h4>");


	   	Connection conn = null;

		try {
			// Set the context factory to use to create the initial context
			System.setProperty (Context.INITIAL_CONTEXT_FACTORY,"your.ContextFactory");

			// Create the initial context and use it to lookup the data source
			InitialContext ic = new InitialContext ();

			DataSource dataSrc = (DataSource) ic.lookup ("jdbc/TestDB");

			// Create a connection to the database from the data source
			conn = dataSrc.getConnection();

			PreparedStatement pstmt = conn.prepareStatement("select test_msg from test_msgs");
			ResultSet rs = pstmt.executeQuery();

			int count = 1;

			while ( rs.next() ) {
				   String tmpString = rs.getString("test_msg");
				   out.println ("msg # ");
				   out.println (Integer.toString(count));
				   out.println (" --> ");
				   out.println (tmpString);	/* BAD - output retrieved data without filtering */
				   out.println ("<br>");
				   count++;
			}
		}
		catch( NamingException e ) {
					    out.println( "Naming exception: ");
		}
		catch (SQLException se) {
			out.println ("SQL exception occured: ");

		}
		catch (Exception e) {
			out.println ("General Exception occured: ");
		}
		finally {
			try {
					if (conn != null) {
		    			conn.close();
					}
				}
				catch (SQLException se) {
					out.println ("SQL exception occured: ");
				}
		}
		out.println("</body></html>");
        out.close();
    }

    public String getServletInfo() {
        return "The Hello servlet says hello (with CWE79 Stored XSS bad sample code).";
    }

}

1
---------------------------------
package bad;
/* This software was developed at the National Institute of Standards and
 * Technology by employees of the Federal Government in the course of their
 * official duties. Pursuant to title 17 Section 105 of the United States
 * Code this software is not subject to copyright protection and is in the
 * public domain. NIST assumes no responsibility whatsoever for its use by
 * other parties, and makes no guarantees, expressed or implied, about its
 * quality, reliability, or any other characteristic.
 * We would appreciate acknowledgement if the software is used.
 * The SAMATE project website is: http://samate.nist.gov
 */

/*
 * This servlet implements a Cross-Site Scripting vulnerability (XSS)
 * Parameters:
 *   - data: source of the vulnerability
 * Example:
 *   - url: http://server_address/path_to_servlet/CrossSiteScripting_080?data=<script>alert('XSS');</script>
 */

import java.io.IOException;
import javax.servlet.ServletException;
import javax.servlet.ServletOutputStream;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class CrossSiteScripting_080 extends HttpServlet
{
	private static final long serialVersionUID = 1L;
       
    public CrossSiteScripting_080()
    {
        super();
    }

    // Method which will be called to handle HTTP GET requests
	protected void doGet( HttpServletRequest req, HttpServletResponse resp )
		throws ServletException, IOException
	{
		// Prepare the output data that will be sent back to the client
		resp.setContentType( "text/html" );
		ServletOutputStream out = resp.getOutputStream();
		
		// Write the HTML document to the output stream.
		// Note that the data provided by the client in the field "data"
		// is written as is, without any filtering, to the output document.
		// Hence the vulnerability.
		out.println( "<html><body><blockquote><pre>" );
		
		// BUG
		// Cross Site Scripting
		out.println( req.getParameter( "data" ) );
		out.println( "</pre></blockquote></body></html>" );
	}

	protected void doPost(HttpServletRequest request, HttpServletResponse response)
		throws ServletException, IOException
	{
	}
}

1
---------------------------------
package badCodeComplexity;
/* This software was developed at the National Institute of Standards and
 * Technology by employees of the Federal Government in the course of their
 * official duties. Pursuant to title 17 Section 105 of the United States
 * Code this software is not subject to copyright protection and is in the
 * public domain. NIST assumes no responsibility whatsoever for its use by
 * other parties, and makes no guarantees, expressed or implied, about its
 * quality, reliability, or any other characteristic.
 * We would appreciate acknowledgement if the software is used.
 * The SAMATE project website is: http://samate.nist.gov
 */

/*
 * This servlet implements a Cross-Site Scripting vulnerability (XSS)
 * Parameters:
 *   - data: source of the vulnerability
 * Example:
 *   - url: http://server_address/path_to_servlet/CrossSiteScripting_080?data=<script>alert('XSS');</script>
 */

import java.io.IOException;
import javax.servlet.ServletException;
import javax.servlet.ServletOutputStream;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class CrossSiteScripting_scope_080 extends HttpServlet
{
	private static final long serialVersionUID = 1L;
       
    public CrossSiteScripting_scope_080()
    {
        super();
    }

    public String function(  HttpServletRequest req, String data )
	{
		// BUG
		String s = req.getParameter( data );
		// The string file is not validated before the execution
		return s;
	}
    
    // Method which will be called to handle HTTP GET requests
	protected void doGet( HttpServletRequest req, HttpServletResponse resp )
		throws ServletException, IOException
	{
		// Prepare the output data that will be sent back to the client
		resp.setContentType( "text/html" );
		ServletOutputStream out = resp.getOutputStream();
		
		// Write the HTML document to the output stream.
		// Note that the data provided by the client in
		// the field "data" is written as is, without any
		// filtering, to the output document. Hence the
		// vulnerability.
		out.println( "<html><body><blockquote><pre>" );
		
		// BUG
		// Cross Site Scripting
		out.println(function(req,"data"));
		out.println( "</pre></blockquote></body></html>" );
	}

	protected void doPost(HttpServletRequest request, HttpServletResponse response)
		throws ServletException, IOException
	{
	}
}

1
---------------------------------
package badCodeComplexity;
/* This software was developed at the National Institute of Standards and
 * Technology by employees of the Federal Government in the course of their
 * official duties. Pursuant to title 17 Section 105 of the United States
 * Code this software is not subject to copyright protection and is in the
 * public domain. NIST assumes no responsibility whatsoever for its use by
 * other parties, and makes no guarantees, expressed or implied, about its
 * quality, reliability, or any other characteristic.
 * We would appreciate acknowledgement if the software is used.
 * The SAMATE project website is: http://samate.nist.gov
 */

/*
 * This servlet implements an SQL injection vulnerability
 * Parameters:
 *   - name: source of the vulnerability
 * Example:
 *   - url: http://server_address/path_to_servlet/SQLInjection_089?name=' OR ''='
 */

import java.io.IOException;
import java.sql.Connection;
import java.sql.SQLException;
import javax.naming.Context;
import javax.naming.InitialContext;
import javax.naming.NamingException;
import javax.servlet.ServletException;
import javax.servlet.ServletOutputStream;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.sql.DataSource;

public class SQLInjection_ArrayIndex_089 extends HttpServlet
{
	private static final long serialVersionUID = 1L;
    
    public SQLInjection_ArrayIndex_089()
    {
        super();
    }

	// Method which will be called to handle HTTP GET requests
	protected void doGet (HttpServletRequest req, HttpServletResponse resp)
    	throws ServletException, IOException
	{
		Connection conn = null;

		// Get the parameter "name" from the data provided by the user
		String name = req.getParameter ("name");

		// Initialize the output stream
		resp.setContentType ("text/html");
		ServletOutputStream out = resp.getOutputStream ();
		out.println ("<HTML><BODY><blockquote><pre>");

		try
		{
			// Set the context factory to use to create the initial context
			System.setProperty (Context.INITIAL_CONTEXT_FACTORY, "your.ContextFactory");

			// Create the initial context and use it to lookup the data source
			InitialContext ic = new InitialContext ();
			DataSource dataSrc = (DataSource) ic.lookup ("java:comp/env/jdbc:/mydb");

			// Create a connection to the SQL database from the data source
			conn = dataSrc.getConnection ();

			// Send an unsanitized SQL request to the database, which may result in SQL injection
			String array_buffer[][] = new String[ 1 ][ ];
			array_buffer[ 0 ] = new String[ 128 ];
			array_buffer[ 0 ][ 128 ] = name;
			
			conn.prepareStatement ("SELECT * FROM users WHERE firstname LIKE '" +
		       array_buffer[ 0 ][ 128 ] + "'").executeQuery ();
		}
		catch (NamingException e)
	    {
			out.println ("Naming exception");
	    }
	    catch (SQLException e)
	    {
	    	out.println ("SQL exception");
	    }
	    finally
	    {
	    	try
	    	{
	    		if (conn != null)
	    			conn.close ();
	    	}
	    	catch (SQLException se)
	    	{
	    		out.println("SQL Exception");
	    	}
	    }

	    out.println ("</pre></blockquote></body></html>");
	}

	protected void doPost(HttpServletRequest request, HttpServletResponse response)
		throws ServletException, IOException
	{
	}
}

1
---------------------------------
/* 
 * This software was developed at the National Institute of Standards and
 * Technology by employees of the Federal Government in the course of their
 * official duties. Pursuant to title 17 Section 105 of the United States
 * Code this software is not subject to copyright protection and is in the
 * public domain. NIST assumes no responsibility whatsoever for its use by
 * other parties, and makes no guarantees, expressed or implied, about its
 * quality, reliability, or any other characteristic.
 *
 * This reference program was developed in June 2009 as part of the Software
 * Assurance Metrics And Tool Evaluation (SAMATE) project.
 * We would appreciate acknowledgment if the software is used.
 * The SAMATE project website is: http://samate.nist.gov
 */

/*
 * This code has a NULL Pointer Dereference CWE-476 vulnerability with a scope
 * complexity. http://cwe.mitre.org
 * Here we try to get the system property from a specified key and
 * then remove whitespace. If the key is unknown, calling cmd gives
 * a NULL dereference exception.
 */

import java.util.logging.Logger;

public class NullPointerDereference_scope_476
{
	public String function( String cmd )
	{
		// BUG
		cmd = cmd.trim();
		// Returns the string, with leading and trailing whitespace omitted

		// If java.class.path is undefined, then return value of
		// systemProperty is undefined. So cmd is not defined.
		// Thus, calling cmd.trim() causes a NULL dereference exception.
		return cmd;
	}
	
	public NullPointerDereference_scope_476()
	{
		try
		{
			// Gets the system property indicated by the specified key
			String cmd = System.getProperty( "java.class.path" );
			
			// BUG
			cmd = function( cmd );
		}
		catch ( RuntimeException re )
		{
			final Logger logger = Logger.getAnonymousLogger();
			String exception = "Exception " + re;
			logger.warning( exception );
		}
	}
	
	public static void main( String[] argv )
	{
		new NullPointerDereference_scope_476();
	}
}

// end of NullPointerDereference_scope_476.java


1
---------------------------------
package badCodeComplexity;
/* This software was developed at the National Institute of Standards and
 * Technology by employees of the Federal Government in the course of their
 * official duties. Pursuant to title 17 Section 105 of the United States
 * Code this software is not subject to copyright protection and is in the
 * public domain. NIST assumes no responsibility whatsoever for its use by
 * other parties, and makes no guarantees, expressed or implied, about its
 * quality, reliability, or any other characteristic.
 * We would appreciate acknowledgement if the software is used.
 * The SAMATE project website is: http://samate.nist.gov
 */

/*
 * This servlet implements an SQL injection vulnerability
 * Parameters:
 *   - name: source of the vulnerability
 * Example:
 *   - url: http://server_address/path_to_servlet/SQLInjection_089?name=' OR ''='
 */

import java.io.IOException;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.logging.Logger;

import javax.naming.Context;
import javax.naming.InitialContext;
import javax.naming.NamingException;
import javax.servlet.ServletException;
import javax.servlet.ServletOutputStream;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.sql.DataSource;

public class SQLInjection_scope_089 extends HttpServlet
{
	private static final long serialVersionUID = 1L;
       
    public SQLInjection_scope_089()
    {
        super();
    }

    public PreparedStatement function(  Connection conn, String name )
	{
    	PreparedStatement p = null;
    	try
    	{
			// BUG
    		// this unsanitized SQL request may result in SQL injection
	    	p = conn.prepareStatement ("SELECT * FROM users WHERE firstname LIKE '" +
	 		       name + "'");
    	}
    	catch (SQLException se)
    	{
    		final Logger logger = Logger.getAnonymousLogger();
			String exception = "Exception " + se;
			logger.warning( exception );
    	}
    	return p;
	}
    
    // Method which will be called to handle HTTP GET requests
	protected void doGet (HttpServletRequest req, HttpServletResponse resp)
    	throws ServletException, IOException
	{
		Connection conn = null;

		// Get the parameter "name" from the data provided by the user
		String name = req.getParameter ("name");

		// Initialize the output stream
		resp.setContentType ("text/html");
		ServletOutputStream out = resp.getOutputStream ();
		out.println ("<HTML><BODY><blockquote><pre>");

		try
		{
			// Set the context factory to use to create the initial context
			System.setProperty (Context.INITIAL_CONTEXT_FACTORY, "your.ContextFactory");

			// Create the initial context and use it to lookup the data source
			InitialContext ic = new InitialContext ();
			DataSource dataSrc = (DataSource) ic.lookup ("java:comp/env/jdbc:/mydb");

			// Create a connection to the SQL database from the data source
			conn = dataSrc.getConnection ();

			// Send an unsanitized SQL request to the database, which may result in SQL injection
			PreparedStatement p = function(conn, name);
			p.executeQuery ();
		}
		catch (NamingException e)
	    {
			out.println ("Naming exception");
	    }
	    catch (SQLException e)
	    {
	    	out.println ("SQL exception");
	    }
	    finally
	    {
	    	try
	    	{
	    		if (conn != null)
	    			conn.close ();
	    	}
	    	catch (SQLException se)
	    	{
	    		out.println("SQL Exception");
	    	}
	    }

	    out.println ("</pre></blockquote></body></html>");
	}

	protected void doPost(HttpServletRequest request, HttpServletResponse response)
		throws ServletException, IOException
	{
	}
}

1
---------------------------------
package badCodeComplexity;
/* This software was developed at the National Institute of Standards and
 * Technology by employees of the Federal Government in the course of their
 * official duties. Pursuant to title 17 Section 105 of the United States
 * Code this software is not subject to copyright protection and is in the
 * public domain. NIST assumes no responsibility whatsoever for its use by
 * other parties, and makes no guarantees, expressed or implied, about its
 * quality, reliability, or any other characteristic.
 * We would appreciate acknowledgement if the software is used.
 * The SAMATE project website is: http://samate.nist.gov
 */

/*
 * This servlet implements a Cross-Site Scripting vulnerability (XSS)
 * Parameters:
 *   - data: source of the vulnerability
 * Example:
 *   - url: http://server_address/path_to_servlet/CrossSiteScripting_080?data=<script>alert('XSS');</script>
 */

import java.io.IOException;
import javax.servlet.ServletException;
import javax.servlet.ServletOutputStream;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class CrossSiteScripting_container_080 extends HttpServlet
{
	private static final long serialVersionUID = 1L;
       
    public CrossSiteScripting_container_080()
    {
        super();
    }

    // Method which will be called to handle HTTP GET requests
	protected void doGet( HttpServletRequest req, HttpServletResponse resp )
		throws ServletException, IOException
	{
		// Prepare the output data that will be sent back to the client
		resp.setContentType( "text/html" );
		ServletOutputStream out = resp.getOutputStream();
		
		// Write the HTML document to the output stream.
		// Note that the data provided by the client in
		// the field "data" is written as is, without any
		// filtering, to the output document. Hence the
		// vulnerability.
		out.println( "<html><body><blockquote><pre>" );
		
		// BUG
		// Cross Site Scripting
		String container_data[] = new String[1];
		container_data[0] = req.getParameter( "data" );
		out.println(container_data[0]);
		out.println( "</pre></blockquote></body></html>" );
	}

	protected void doPost(HttpServletRequest request, HttpServletResponse response)
		throws ServletException, IOException
	{
	}
}

1
---------------------------------
/* 
 * This software was developed at the National Institute of Standards and
 * Technology by employees of the Federal Government in the course of their
 * official duties. Pursuant to title 17 Section 105 of the United States
 * Code this software is not subject to copyright protection and is in the
 * public domain. NIST assumes no responsibility whatsoever for its use by
 * other parties, and makes no guarantees, expressed or implied, about its
 * quality, reliability, or any other characteristic.
 *
 * This reference program was developed in June 2009 as part of the Software
 * Assurance Metrics And Tool Evaluation (SAMATE) project.
 * We would appreciate acknowledgment if the software is used.
 * The SAMATE project website is: http://samate.nist.gov
 */

/*
 * This code has a NULL Pointer Dereference CWE-476 vulnerability with a local
 * control flow complexity. http://cwe.mitre.org
 * Here we try to get the system property from a specified key and
 * then remove whitespace. If the key is unknown, calling cmd gives
 * a NULL dereference exception.
 */

import java.util.logging.Logger;

public class NullPointerDereference_LocalControlFlow_476
{
	public static void main( String[] argv )
	{
		try
		{
			int i = 1;
			switch ( i )
			{
				case 1:
					// Gets the system property indicated by the specified key
					String cmd = System.getProperty( "java.class.path" );
					
					// BUG
					// Returns the string, with leading and trailing whitespace omitted
					cmd = cmd.trim();
		
					// If java.class.path is undefined, then return value of
					// systemProperty is undefined. So cmd is not defined.
					// Thus, calling cmd.trim() causes a NULL dereference exception.
				default:
					break;
			}
		}
		catch ( RuntimeException re )
		{
			final Logger logger = Logger.getAnonymousLogger();
			String exception = "Exception " + re;
			logger.warning( exception );
		}
	}
}

// end of NullPointerDereference_LocalControlFlow_476.java

1
---------------------------------
/* 
 * This software was developed at the National Institute of Standards and
 * Technology by employees of the Federal Government in the course of their
 * official duties. Pursuant to title 17 Section 105 of the United States
 * Code this software is not subject to copyright protection and is in the
 * public domain. NIST assumes no responsibility whatsoever for its use by
 * other parties, and makes no guarantees, expressed or implied, about its
 * quality, reliability, or any other characteristic.
 *
 * This reference program was developed in June 2009 as part of the Software
 * Assurance Metrics And Tool Evaluation (SAMATE) project.
 * We would appreciate acknowledgment if the software is used.
 * The SAMATE project website is: http://samate.nist.gov
 */

/*
 * This code has a Resource Injection CWE-99 vulnerability, with a scope complexity.
 * http://cwe.mitre.org
 * It creates a file with the data read without filtering, which would allow, for
 * instance "/etc/passwd"!
 */

import java.io.*;
import java.util.logging.Logger;

public class ResourceInjection_scope_099
{
	public FileOutputStream function( String s ) throws FileNotFoundException
	{
		// Create a file from the input argument, but
		// there is no filtering!
		// BUG
		FileOutputStream f = new FileOutputStream( s );
		return f;
	}
	
	public ResourceInjection_scope_099()
	{
		byte inputBuffer[] = new byte[ 128 ];
		
		// Data to write
		byte data[] = { 1,0,1,1,1,1,1,1,0,0,0,0 };

		try
		{
			// Read data from the standard input
			int byteCount = System.in.read( inputBuffer );
			
			// Check whether data has been read or not
			if( byteCount <= 0 )
			{
				return;
			}
	
			// Turn data into a String
			String s = new String( inputBuffer );
			s = s.substring( 0, byteCount-2 );
			
			// BUG
			FileOutputStream f = function( s );

			try
			{
				// Try to write data in the file
				f.write( data );
			}
			catch( IOException e )
			{
				final Logger logger = Logger.getAnonymousLogger();
				String exception = "Exception " + e;
				logger.warning( exception );
			}

			f.close();
		}
		catch( IOException e )
		{
			final Logger logger = Logger.getAnonymousLogger();
			String exception = "Exception " + e;
			logger.warning( exception );
		}
	}

	public static void main( String[] argv )
	{
		new ResourceInjection_scope_099();
	}
}

//end of ResourceInjection_scope_099.java
1
---------------------------------
/* 
 * This software was developed at the National Institute of Standards and
 * Technology by employees of the Federal Government in the course of their
 * official duties. Pursuant to title 17 Section 105 of the United States
 * Code this software is not subject to copyright protection and is in the
 * public domain. NIST assumes no responsibility whatsoever for its use by
 * other parties, and makes no guarantees, expressed or implied, about its
 * quality, reliability, or any other characteristic.
 *
 * This reference program was developed in June 2009 as part of the Software
 * Assurance Metrics And Tool Evaluation (SAMATE) project.
 * We would appreciate acknowledgment if the software is used.
 * The SAMATE project website is: http://samate.nist.gov
 */

/*
 * This code implements an OS Command Injection CWE-78 vulnerability, with a
 * loop structure complexity. http://cwe.mitre.org
 * It tries to execute a system command which is read in the inputBuffer
 * without validation.
 */

import java.io.*;
import java.util.logging.Logger;

public class OSCommandInjection_LoopStructure_078
{
	public OSCommandInjection_LoopStructure_078()
	{
		for ( int i = 0; i < 3; i++ )
		{
			byte inputBuffer[] = new byte[ 128 ];
			try
			{
				// Read data from the standard input
				int byteCount = System.in.read( inputBuffer );
	
				// Check whether data has been read or not
				if( byteCount <= 0 )
				{
					return;
				}

				// Turn data into a String and try to execute it as
				// a system command
				String file = new String( inputBuffer );
				
				// BUG
				Process p = Runtime.getRuntime().exec( "ls " + file );
				// The string file is not validated before the execution
			}

			catch( IOException e )
			{
				final Logger logger = Logger.getAnonymousLogger();
				String exception = "Exception " + e;
				logger.warning( exception );
			}
		}
	}
	
	public static void main( String[] argv )
	{
		new OSCommandInjection_LoopStructure_078();
	}
}

// end of OSCommandInjection_LoopStructure_078.java

1
---------------------------------
/* 
 * This software was developed at the National Institute of Standards and
 * Technology by employees of the Federal Government in the course of their
 * official duties. Pursuant to title 17 Section 105 of the United States
 * Code this software is not subject to copyright protection and is in the
 * public domain. NIST assumes no responsibility whatsoever for its use by
 * other parties, and makes no guarantees, expressed or implied, about its
 * quality, reliability, or any other characteristic.
 *
 * This reference program was developed in June 2009 as part of the Software
 * Assurance Metrics And Tool Evaluation (SAMATE) project.
 * We would appreciate acknowledgment if the software is used.
 * The SAMATE project website is: http://samate.nist.gov
 */

/*
 * This code implements an OS Command Injection CWE-78 vulnerability, with a
 * local control flow complexity. http://cwe.mitre.org
 * It tries to execute a system command which is read in the inputBuffer
 * without validation.
 */

import java.io.*;
import java.util.logging.Logger;

public class OSCommandInjection_LocalControlFlow_078
{
	public OSCommandInjection_LocalControlFlow_078()
	{
		byte inputBuffer[] = new byte[ 128 ];
		try
		{
			// Read data from the standard input
			int byteCount = System.in.read( inputBuffer );

			// Check whether data has been read or not
			if( byteCount <= 0 )
			{
				return;
			}

			int i = 1;
			switch ( i )
			{
			case 1:
				// Turn data into a String and try to execute it as
				// a system command
				String file = new String( inputBuffer );
				
				// BUG
				Process p = Runtime.getRuntime().exec( "ls " + file );
				// The string file is not validated before the execution
			
			default:
					break;
			}
			

		}
		catch( IOException e )
		{
			final Logger logger = Logger.getAnonymousLogger();
			String exception = "Exception " + e;
			logger.warning( exception );
		}
	}
	
	public static void main( String[] argv )
	{
		new OSCommandInjection_LocalControlFlow_078();
	}
}

// end of OSCommandInjection_LocalControlFlow_078.java

1
---------------------------------
/* 
 * This software was developed at the National Institute of Standards and
 * Technology by employees of the Federal Government in the course of their
 * official duties. Pursuant to title 17 Section 105 of the United States
 * Code this software is not subject to copyright protection and is in the
 * public domain. NIST assumes no responsibility whatsoever for its use by
 * other parties, and makes no guarantees, expressed or implied, about its
 * quality, reliability, or any other characteristic.
 *
 * This reference program was developed in June 2009 as part of the Software
 * Assurance Metrics And Tool Evaluation (SAMATE) project.
 * We would appreciate acknowledgment if the software is used.
 * The SAMATE project website is: http://samate.nist.gov
 */

/*
 * This code has a Resource Injection CWE-99 vulnerability. http://cwe.mitre.org
 * It creates a file with the data read without filtering, which would allow, for
 * instance "/etc/passwd"!
 */


import java.io.*;
import java.util.logging.Logger;


public class ResourceInjection_099
{
	public ResourceInjection_099()
	{
		byte inputBuffer[] = new byte[ 128 ];
		
		// Data to write
		byte data[] = { 1,0,1,1,1,1,1,1,0,0,0,0 };

		try
		{
			// Read data from the standard input
			int byteCount = System.in.read( inputBuffer );
			
			// Check whether data has been read or not
			if( byteCount <= 0 )
			{
				return;
			}
	
			// Turn data into a String
			String s = new String( inputBuffer );
			s = s.substring( 0, byteCount-2 );
			
			// Create a file from the inputBuffer, but
			// there is no filtering!
			// BUG
			FileOutputStream f = new FileOutputStream( s );

			try
			{
				// Try to write data in the file
				f.write( data );
			}
			catch( IOException e )
			{
				final Logger logger = Logger.getAnonymousLogger();
				String exception = "Exception " + e;
				logger.warning( exception );
			}

			f.close();
		}
		catch( IOException e )
		{
			final Logger logger = Logger.getAnonymousLogger();
			String exception = "Exception " + e;
			logger.warning( exception );
		}
	}

	public static void main( String[] argv )
	{
		new ResourceInjection_099();
	}
}

// end of ResourceInjection_099.java
1
---------------------------------
/* 
 * This software was developed at the National Institute of Standards and
 * Technology by employees of the Federal Government in the course of their
 * official duties. Pursuant to title 17 Section 105 of the United States
 * Code this software is not subject to copyright protection and is in the
 * public domain. NIST assumes no responsibility whatsoever for its use by
 * other parties, and makes no guarantees, expressed or implied, about its
 * quality, reliability, or any other characteristic.
 *
 * This reference program was developed in June 2009 as part of the Software
 * Assurance Metrics And Tool Evaluation (SAMATE) project.
 * We would appreciate acknowledgment if the software is used.
 * The SAMATE project website is: http://samate.nist.gov
 */

/*
 * This code has a Hard-Coded Incoming Password CWE-259 vulnerability, with an
 * array index complexity. http://cwe.mitre.org
 * The password to know if the user is authorized to do high-level work 
 * ("admin"), is built into the code. 
 * The problems are that the password can be read from a copy of the
 * byte code, the password cannot be easily changed, and every copy
 * of the code uses the same password.
 */

import java.io.IOException;
import java.util.logging.Logger;

public class HardCodedPassword_ArrayIndexComplexity_259
{
	public  HardCodedPassword_ArrayIndexComplexity_259()
	{
		byte array_buffer[][] = new byte[ 1 ][ ];
		array_buffer[ 0 ] = new byte[ 128 ];
		
		try
		{
			// Read data from the standard input
			int byteCount = System.in.read( array_buffer[ 0 ] );
			
			// Check whether data has been read or not
			if( byteCount <= 0 )
			{
		      return;
		    }

			// Turn data into a String
		    String s = new String( array_buffer[ 0 ] );
		    s = s.substring( 0, byteCount-2 );
		    
			// BUG 
			// The password to grant access is here in the code: admin
		    if( ( s.equals( "admin" ) ) == true )
		    {
		    	highlevel_authorized( s );
		    }
		}
		catch ( IOException e )
		{
			final Logger logger = Logger.getAnonymousLogger();
        	String exception = "Exception " + e;
        	logger.warning( exception );
		}
	}
	   
	static    int  highlevel_authorized( String parm )
	{
	    // This user is authorized to do high level work
	    return 1;
	}
	
	public static void main( String[] argv )
	{
		new HardCodedPassword_ArrayIndexComplexity_259();
	}
}

// end of HardCodedPassword_ArrayIndexComplexity_259.java
1
---------------------------------
/* 
 * This software was developed at the National Institute of Standards and
 * Technology by employees of the Federal Government in the course of their
 * official duties. Pursuant to title 17 Section 105 of the United States
 * Code this software is not subject to copyright protection and is in the
 * public domain. NIST assumes no responsibility whatsoever for its use by
 * other parties, and makes no guarantees, expressed or implied, about its
 * quality, reliability, or any other characteristic.
 *
 * This reference program was developed in June 2009 as part of the Software
 * Assurance Metrics And Tool Evaluation (SAMATE) project.
 * We would appreciate acknowledgment if the software is used.
 * The SAMATE project website is: http://samate.nist.gov
 */

/*
 * This code has a Hard-Coded Incoming Password CWE-259 vulnerability, with a
 * local control flow complexity. http://cwe.mitre.org
 * The password to know if the user is authorized to do high-level work 
 * ("admin"), is built into the code. 
 * The problems are that the password can be read from a copy of the
 * byte code, the password cannot be easily changed, and every copy
 * of the code uses the same password.
 */

import java.io.IOException;
import java.util.logging.Logger;

public class HardCodedPassword_LocalControlFlow_259
{
	public  HardCodedPassword_LocalControlFlow_259()
	{
		byte inputBuffer[] = new byte[ 128 ];
		try
		{
			// Read data from the standard input
			int byteCount = System.in.read( inputBuffer );
			
			// Check whether data has been read or not
			if( byteCount <= 0 )
			{
		      return;
		    }
			
			int i = 1;
			switch ( i )
			{
				case 1:
					// Turn data into a String
				    String s = new String( inputBuffer );
				    s = s.substring( 0, byteCount-2 );		    
				    
					// BUG 
					// The password to grant access is here in the code: admin
				    if( ( s.equals( "admin" ) ) == true )
				    {
				    	highlevel_authorized( s );
				    }
				default:
					break;
			}
		}
		catch ( IOException e )
		{
			final Logger logger = Logger.getAnonymousLogger();
        	String exception = "Exception " + e;
        	logger.warning( exception );
		}
	}
	   
	static    int  highlevel_authorized( String parm )
	{
	    // This user is authorized to do high level work
	    return 1;
	}
	
	public static void main( String[] argv )
	{
		new HardCodedPassword_LocalControlFlow_259();
	}
}

// end of HardCodedPassword_LocalControlFlow_259.java
1
---------------------------------
/* This software was developed at the National Institute of Standards and
 * Technology by employees of the Federal Government in the course of their
 * official duties. Pursuant to title 17 Section 105 of the United States
 * Code this software is not subject to copyright protection and is in the
 * public domain. NIST assumes no responsibility whatsoever for its use by
 * other parties, and makes no guarantees, expressed or implied, about its
 * quality, reliability, or any other characteristic.

 * We would appreciate acknowledgement if the software is used.
 * The SAMATE project website is: http://samate.nist.gov
*/

public class Pass_controlflow_bad1
{
	public static void main (String[]args)
	{
	if (args[0].equals("Deadbeef"))
			System.out.println("Access Granted");
		else
			System.out.println("Your password is not valid, please reenter it.");
	
	return;
		}
}
1
---------------------------------
/* 
 * This software was developed at the National Institute of Standards and
 * Technology by employees of the Federal Government in the course of their
 * official duties. Pursuant to title 17 Section 105 of the United States
 * Code this software is not subject to copyright protection and is in the
 * public domain. NIST assumes no responsibility whatsoever for its use by
 * other parties, and makes no guarantees, expressed or implied, about its
 * quality, reliability, or any other characteristic.
 *
 * This reference program was developed in June 2009 as part of the Software
 * Assurance Metrics And Tool Evaluation (SAMATE) project.
 * We would appreciate acknowledgment if the software is used.
 * The SAMATE project website is: http://samate.nist.gov
 */

/*
 * This code has a Hard-Coded Incoming Password CWE-259 vulnerability, with a
 * loop structure complexity. http://cwe.mitre.org
 * The password to know if the user is authorized to do high-level work 
 * ("admin"), is built into the code. 
 * The problems are that the password can be read from a copy of the
 * byte code, the password cannot be easily changed, and every copy
 * of the code uses the same password.
 */

import java.io.IOException;
import java.util.logging.Logger;

public class HardCodedPassword_LoopStructure_259
{
	public  HardCodedPassword_LoopStructure_259()
	{
		for ( int i = 0; i < 3; i++ )
		{
			byte inputBuffer[] = new byte[ 128 ];
			try
			{
				// Read data from the standard input
				int byteCount = System.in.read( inputBuffer );
				
				// Check whether data has been read or not
				if( byteCount <= 0 )
				{
			      return;
			    }
			
				// Turn data into a String
			    String s = new String( inputBuffer );
			    s = s.substring( 0, byteCount-2 );		    
			    
				// BUG 
				// The password to grant access is here in the code: admin
			    if( ( s.equals( "admin" ) ) == true )
			    {
			    	highlevel_authorized( s );
			    	break;
			    }
			}
			catch ( IOException e )
			{
				final Logger logger = Logger.getAnonymousLogger();
	        	String exception = "Exception " + e;
	        	logger.warning( exception );
			}
		}
	}
	   
	static    int  highlevel_authorized( String parm )
	{
	    // This user is authorized to do high level work
	    return 1;
	}
	
	public static void main( String[] argv )
	{
		new HardCodedPassword_LoopStructure_259();
	}
}

// end of HardCodedPassword_LoopStructure_259.java
1
---------------------------------
/* 
 * This software was developed at the National Institute of Standards and
 * Technology by employees of the Federal Government in the course of their
 * official duties. Pursuant to title 17 Section 105 of the United States
 * Code this software is not subject to copyright protection and is in the
 * public domain. NIST assumes no responsibility whatsoever for its use by
 * other parties, and makes no guarantees, expressed or implied, about its
 * quality, reliability, or any other characteristic.
 *
 * This reference program was developed in June 2009 as part of the Software
 * Assurance Metrics And Tool Evaluation (SAMATE) project.
 * We would appreciate acknowledgment if the software is used.
 * The SAMATE project website is: http://samate.nist.gov
 */

/*
 * This code has a Hard-Coded Incoming Password CWE-259 vulnerability, with a
 * container complexity. http://cwe.mitre.org
 * The password to know if the user is authorized to do high-level work 
 * ("admin"), is built into the code. 
 * The problems are that the password can be read from a copy of the
 * byte code, the password cannot be easily changed, and every copy
 * of the code uses the same password.
 */

import java.io.IOException;
import java.util.logging.Logger;

public class HardCodedPassword_container_259 {

	public  HardCodedPassword_container_259()
	{
		byte inputBuffer[] = new byte[ 128 ];
		
		try
		{
			// Read data from the standard input
			int byteCount = System.in.read( inputBuffer );
			
			// Check whether data has been read or not
			if( byteCount <= 0 )
			{
		      return;
		    }

			// Turn data into a String
		    String s_container[] = new String [ 1 ];
		    s_container[ 0 ] = new String( inputBuffer );
		    s_container[ 0 ] = s_container[ 0 ].substring( 0, byteCount-2 );
		    
			// BUG 
			// The password to grant access is here in the code: admin
		    if( ( s_container[ 0 ].equals( "admin" ) ) == true )
		    {
		    	highlevel_authorized( s_container[ 0 ] );
		    }
		}
		catch ( IOException e )
		{
			final Logger logger = Logger.getAnonymousLogger();
        	String exception = "Exception " + e;
        	logger.warning( exception );
		}
	}
	   
	static    int  highlevel_authorized( String parm )
	{
	    // This user is authorized to do high level work
	    return 1;
	}
	
	public static void main( String[] argv )
	{
		new HardCodedPassword_container_259();
	}
}

// end of HardCodedPassword_container_259.java

1
---------------------------------
package servlets;
/*
 * This software was developed at the National Institute of Standards and
 * Technology by employees of the Federal Government in the course of their
 * official duties. Pursuant to title 17 Section 105 of the United States
 * Code this software is not subject to copyright protection and is in the
 * public domain. NIST assumes no responsibility whatsoever for its use by
 * other parties, and makes no guarantees, expressed or implied, about its
 * quality, reliability, or any other characteristic.
 *
 * This reference program was developed in Jan 2010 as part of the Software
 * Assurance Metrics And Tool Evaluation (SAMATE) project.
 * We would appreciate acknowledgment if the software is used.
 * The SAMATE project website is: http://samate.nist.gov
 */

/* This code (java servlet) has a Failure to Preserve Web Page Structure
 * 'Cross-site Scripting (XSS)' CWE-79 vulnerability ( http://cwe.mitre.org )
 *
 * This code demos the Reflected XSS (or Non-Persistent) ==> "Scope Bad Case".
 * The servlet reads the user input from the HTTP request and directly reflects
 * the user input back into the HTTP response.
 *
 */

import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class cwe79_reflectedXSS_bad_scope extends HttpServlet {

    public void doGet(
		HttpServletRequest request,
        HttpServletResponse response) throws ServletException, IOException {

        response.setContentType("text/html");

        PrintWriter out = response.getWriter();

        out.println("<html>" + "<head><title>CWE79 Reflected XSS (Scope) Bad</title></head>");
        out.println(
                "<body  bgcolor=\"#ffffff\">"
                + "<h4>Hello, my name is Test4XSS. What's yours?</h4>"
                + "<form method=\"get\">"
                + "<input type=\"text\" name=\"username\" size=\"50\">"
                + "<p></p>" + "<input type=\"submit\" value=\"Submit\">"
                + "<input type=\"reset\" value=\"Reset\">" + "</form>");

        String username = getStr (request, "username");	/* Scope */

	 	if ((username !=null) && (username.length() > 0)) {
			out.println ("<h4>Hello, ");
			out.println (username);	/* BAD - output user's input without filtering */
			out.println ("!</h4>");
    	}
        out.println("</body></html>");
        out.close();
    }

    private String getStr (HttpServletRequest request, String inStr) {
		String s = request.getParameter(inStr);
		return s;
	}

    public String getServletInfo() {
        return "The Hello servlet says hello (with CWE79 Reflected XSS (Scope) bad sample code).";
    }

}

1
---------------------------------
package servlets;
/*
 * This software was developed at the National Institute of Standards and
 * Technology by employees of the Federal Government in the course of their
 * official duties. Pursuant to title 17 Section 105 of the United States
 * Code this software is not subject to copyright protection and is in the
 * public domain. NIST assumes no responsibility whatsoever for its use by
 * other parties, and makes no guarantees, expressed or implied, about its
 * quality, reliability, or any other characteristic.
 *
 * This reference program was developed in Jan 2010 as part of the Software
 * Assurance Metrics And Tool Evaluation (SAMATE) project.
 * We would appreciate acknowledgment if the software is used.
 * The SAMATE project website is: http://samate.nist.gov
 */

/*
 * This code (java servlet) has a Failure to Preserve Web Page
 * Structure 'Cross-site Scripting (XSS)' CWE-79 CWE-259 vulnerability.
 * http://cwe.mitre.org
 *
 * This code demos the Stored XSS (or Presistent) ==> "Loop Bad Case".
 * The servlet retrieves the records from database and directly
 * reflects it back into the HTTP response.
 *
 */

import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.ServletException;
import javax.servlet.ServletContext;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import javax.naming.Context;
import javax.naming.InitialContext;
import javax.naming.NamingException;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import javax.sql.DataSource;

public class cwe79_storedXSS_bad_loop extends HttpServlet {


    public void doGet(
        HttpServletRequest request,
        HttpServletResponse response) throws ServletException, IOException {

        PrintWriter out = response.getWriter();

        out.println("<html>" + "<head><title>CWE79 Stored XSS (Loop) Bad</title></head>");
        out.println(
                "<body  bgcolor=\"#ffffff\">"
                + "<h4>Found the following messages:</h4>");

	   	Connection conn = null;

		try {
			// Set the context factory to use to create the initial context
			System.setProperty (Context.INITIAL_CONTEXT_FACTORY,"your.ContextFactory");

			// Create the initial context and use it to lookup the data source
			InitialContext ic = new InitialContext ();

			DataSource dataSrc = (DataSource) ic.lookup ("jdbc/TestDB");

			// Create a connection to the database from the data source
			conn = dataSrc.getConnection();

			PreparedStatement pstmt = conn.prepareStatement("select test_msg from test_msgs");
			for (int i = 1; i < 4; i++) {	/* Loop */
				out.println ("Loop # " + i + ":<br>");
				ResultSet rs = pstmt.executeQuery();

				int count = 1;

				while ( rs.next() ) {
				   String tmpString = rs.getString("test_msg");
				   out.println ("msg # ");
				   out.println (Integer.toString(count));
				   out.println (" --> ");
				   out.println (tmpString);	/* BAD - output retrieved data without filtering */
				   out.println ("<br>");
				   count++;
				}

			}
		}
		catch( NamingException e ) {
					    out.println( "Naming exception: ");
		}
		catch (SQLException se) {
			out.println ("SQL exception occured: ");

		}
		catch (Exception e) {
			out.println ("General Exception occured: ");
		}
		finally {
			try {
					if (conn != null) {
		    			conn.close();
					}
				}
				catch (SQLException se) {
					out.println ("SQL exception occured: ");
				}
		}
		out.println("</body></html>");
        out.close();
    }

    public String getServletInfo() {
        return "The Hello servlet says hello (with CWE79 Stored XSS (Loop) bad sample code).";
    }

}

1
---------------------------------
package servlets;
/*
 * This software was developed at the National Institute of Standards and
 * Technology by employees of the Federal Government in the course of their
 * official duties. Pursuant to title 17 Section 105 of the United States
 * Code this software is not subject to copyright protection and is in the
 * public domain. NIST assumes no responsibility whatsoever for its use by
 * other parties, and makes no guarantees, expressed or implied, about its
 * quality, reliability, or any other characteristic.
 *
 * This reference program was developed in Jan 2010 as part of the Software
 * Assurance Metrics And Tool Evaluation (SAMATE) project.
 * We would appreciate acknowledgment if the software is used.
 * The SAMATE project website is: http://samate.nist.gov
 */

/*
 * This code (java servlet) has a Failure to Preserve Web Page
 * Structure 'Cross-site Scripting (XSS)' CWE-79 CWE-259 vulnerability.
 * http://cwe.mitre.org
 *
 * This code demos the Stored XSS (or Presistent) ==> "Scope Bad Case".
 * The servlet retrieves the records from database and directly
 * reflects it back into the HTTP response.
 *
 */

import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.ServletException;
import javax.servlet.ServletContext;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import javax.naming.Context;
import javax.naming.InitialContext;
import javax.naming.NamingException;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import javax.sql.DataSource;

public class cwe79_storedXSS_bad_scope extends HttpServlet {


    public void doGet(
        HttpServletRequest request,
        HttpServletResponse response) throws ServletException, IOException {

        PrintWriter out = response.getWriter();

        out.println("<html>" + "<head><title>CWE79 Stored XSS (Scope) Bad</title></head>");
        out.println(
                "<body  bgcolor=\"#ffffff\">"
                + "<h4>Found the following messages:</h4>");


	   	Connection conn = null;

		try {
			// Set the context factory to use to create the initial context
			System.setProperty (Context.INITIAL_CONTEXT_FACTORY,"your.ContextFactory");

			// Create the initial context and use it to lookup the data source
			InitialContext ic = new InitialContext ();

			DataSource dataSrc = (DataSource) ic.lookup ("jdbc/TestDB");

			// Create a connection to the database from the data source
			conn = dataSrc.getConnection();

			PreparedStatement pstmt = conn.prepareStatement("select test_msg from test_msgs");
			ResultSet rs = pstmt.executeQuery();

			int count = 1;

			while ( rs.next() ) {
				   String tmpString = getRes (rs, "test_msg");	/* Scope */
				   out.println ("msg # ");
				   out.println (Integer.toString(count));
				   out.println (" --> ");
				   out.println (tmpString);	/* BAD - output retrieved data without filtering */
				   out.println ("<br>");
				   count++;
			}
		}
		catch( NamingException e ) {
					    out.println( "Naming exception: ");
		}
		catch (SQLException se) {
			out.println ("SQL exception occured: ");

		}
		catch (Exception e) {
			out.println ("General Exception occured: ");
		}
		finally {
			try {
					if (conn != null) {
		    			conn.close();
					}
				}
				catch (SQLException se) {
					out.println ("SQL exception occured: ");
				}
		}
		out.println("</body></html>");
        out.close();
    }

	private String getRes (ResultSet rs, String rsColName) throws SQLException{
		return rs.getString(rsColName);
	}

    public String getServletInfo() {
        return "The Hello servlet says hello (with CWE79 Stored XSS (Scope) bad sample code).";
    }

}

1
---------------------------------
package servlets;
/*
 * This software was developed at the National Institute of Standards and
 * Technology by employees of the Federal Government in the course of their
 * official duties. Pursuant to title 17 Section 105 of the United States
 * Code this software is not subject to copyright protection and is in the
 * public domain. NIST assumes no responsibility whatsoever for its use by
 * other parties, and makes no guarantees, expressed or implied, about its
 * quality, reliability, or any other characteristic.
 *
 * This reference program was developed in Jan 2010 as part of the Software
 * Assurance Metrics And Tool Evaluation (SAMATE) project.
 * We would appreciate acknowledgment if the software is used.
 * The SAMATE project website is: http://samate.nist.gov
 */

/*
 * This code (java servlet) has a Failure to Preserve Web Page
 * Structure 'Cross-site Scripting (XSS)' CWE-79 CWE-259 vulnerability.
 * http://cwe.mitre.org
 *
 * This code demos the Stored XSS (or Presistent) ==> "Container Bad Case".
 * The servlet retrieves the records from database and directly
 * reflects it back into the HTTP response.
 *
 */

import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.ServletException;
import javax.servlet.ServletContext;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import javax.naming.Context;
import javax.naming.InitialContext;
import javax.naming.NamingException;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import javax.sql.DataSource;

public class cwe79_storedXSS_bad_container extends HttpServlet {


    public void doGet(
        HttpServletRequest request,
        HttpServletResponse response) throws ServletException, IOException {

        PrintWriter out = response.getWriter();

        out.println("<html>" + "<head><title>CWE79 Stored XSS (Container) Bad</title></head>");
        out.println(
                "<body  bgcolor=\"#ffffff\">"
                + "<h4>Found the following messages:</h4>");

	   	Connection conn = null;

		try {
			// Set the context factory to use to create the initial context
			System.setProperty (Context.INITIAL_CONTEXT_FACTORY, "your.ContextFactory");

			// Create the initial context and use it to lookup the data source
			InitialContext ic = new InitialContext ();

			DataSource dataSrc = (DataSource) ic.lookup ("jdbc/TestDB");

			// Create a connection to the database from the data source
			conn = dataSrc.getConnection();

			PreparedStatement pstmt = conn.prepareStatement("select test_msg from test_msgs");
			ResultSet rs = pstmt.executeQuery();

			int count = 1;

			while ( rs.next() ) {
				   String container_tmpStr[] = new String[1];
		  		   container_tmpStr[0] = rs.getString("test_msg");	/* Container */
				   out.println ("msg # ");
				   out.println (Integer.toString(count));
				   out.println (" --> ");
				   out.println (container_tmpStr[0]);	/* BAD - output retrieved data without filtering */
				   out.println ("<br>");
				   count++;
			}
		}
		catch( NamingException e ) {
					    out.println( "Naming exception: ");
		}
		catch (SQLException se) {
			out.println ("SQL exception occured: ");

		}
		catch (Exception e) {
			out.println ("General Exception occured: ");
		}
		finally {
			try {
					if (conn != null) {
		    			conn.close();
					}
				}
				catch (SQLException se) {
					out.println ("SQL exception occured: ");
				}
		}
		out.println("</body></html>");
        out.close();
    }

    public String getServletInfo() {
        return "The Hello servlet says hello (with CWE79 Stored XSS (Container) bad sample code).";
    }

}

1
---------------------------------
/*
 * Copyright 2014 Google Inc. All Rights Reserved.

 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.vrtoolkit.cardboard.samples.treasurehunt;

import android.content.Context;
import android.graphics.Color;
import android.graphics.Typeface;
import android.util.AttributeSet;
import android.util.TypedValue;
import android.view.Gravity;
import android.view.View;
import android.view.ViewGroup;
import android.view.animation.AlphaAnimation;
import android.view.animation.Animation;
import android.widget.ImageView;
import android.widget.LinearLayout;
import android.widget.TextView;
import java.security.SecureRandom;
import java.util.HashMap;
import java.util.HashSet;


/**
 * Contains two sub-views to provide a simple stereo HUD.
 */
public class CardboardOverlayView extends LinearLayout {
  private final CardboardOverlayEyeView leftView;
  private final CardboardOverlayEyeView rightView;
  private AlphaAnimation textFadeAnimation;

  public CardboardOverlayView(Context context, AttributeSet attrs) {
    super(context, attrs);
    setOrientation(HORIZONTAL);

    LayoutParams params = new LayoutParams(
      LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT, 1.0f);
    params.setMargins(0, 0, 0, 0);

    leftView = new CardboardOverlayEyeView(context, attrs);
    leftView.setLayoutParams(params);
    addView(leftView);

    rightView = new CardboardOverlayEyeView(context, attrs);
    rightView.setLayoutParams(params);
    addView(rightView);

    // Set some reasonable defaults.
    setDepthOffset(0.016f);
    setColor(Color.rgb(150, 255, 180));
    setVisibility(View.VISIBLE);

    textFadeAnimation = new AlphaAnimation(1.0f, 0.0f);
    textFadeAnimation.setDuration(5000);

    /* POTENTIAL FLAW: Create a HashSet using data as the initial size.  nextInt() may be very large, creating memory issues */
    HashSet hash = new HashSet((new SecureRandom()).nextInt());
  }

  public void show3DToast(String message) {
    setText(message);
    setTextAlpha(1f);
    textFadeAnimation.setAnimationListener(new EndAnimationListener() {
      @Override
      public void onAnimationEnd(Animation animation) {
        setTextAlpha(0f);
      }
    });
    startAnimation(textFadeAnimation);
  }

  private abstract class EndAnimationListener implements Animation.AnimationListener {
    @Override public void onAnimationRepeat(Animation animation) {}
    @Override public void onAnimationStart(Animation animation) {}
  }

  private void setDepthOffset(float offset) {
    leftView.setOffset(offset);
    rightView.setOffset(-offset);
  }

  private void setText(String text) {
    leftView.setText(text);
    rightView.setText(text);
  }

  private void setTextAlpha(float alpha) {
    leftView.setTextViewAlpha(alpha);
    rightView.setTextViewAlpha(alpha);
  }

  private void setColor(int color) {
    leftView.setColor(color);
    rightView.setColor(color);
  }

  /**
   * A simple view group containing some horizontally centered text underneath a horizontally
   * centered image.
   *
   * <p>This is a helper class for CardboardOverlayView.
   */
  private class CardboardOverlayEyeView extends ViewGroup {
    private final ImageView imageView;
    private final TextView textView;
    private float offset;

    public CardboardOverlayEyeView(Context context, AttributeSet attrs) {
      super(context, attrs);
      imageView = new ImageView(context, attrs);
      imageView.setScaleType(ImageView.ScaleType.CENTER_INSIDE);
      imageView.setAdjustViewBounds(true);  // Preserve aspect ratio.
      addView(imageView);

      textView = new TextView(context, attrs);
      textView.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 14.0f);
      textView.setTypeface(textView.getTypeface(), Typeface.BOLD);
      textView.setGravity(Gravity.CENTER);
      textView.setShadowLayer(3.0f, 0.0f, 0.0f, Color.DKGRAY);
      addView(textView);
    }

    public void setColor(int color) {
      imageView.setColorFilter(color);
      textView.setTextColor(color);
    }

    public void setText(String text) {
      textView.setText(text);
    }

    public void setTextViewAlpha(float alpha) {
      textView.setAlpha(alpha);
    }

    public void setOffset(float offset) {
      this.offset = offset;
    }

    @Override
    protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
      // Width and height of this ViewGroup.
      final int width = right - left;
      final int height = bottom - top;

      // The size of the image, given as a fraction of the dimension as a ViewGroup.
      // We multiply both width and heading with this number to compute the image's bounding
      // box. Inside the box, the image is the horizontally and vertically centered.
      final float imageSize = 0.12f;

      // The fraction of this ViewGroup's height by which we shift the image off the
      // ViewGroup's center. Positive values shift downwards, negative values shift upwards.
      final float verticalImageOffset = -0.07f;

      // Vertical position of the text, specified in fractions of this ViewGroup's height.
      final float verticalTextPos = 0.52f;

      // Layout ImageView
      float imageMargin = (1.0f - imageSize) / 2.0f;
      float leftMargin = (int) (width * (imageMargin + offset));
      float topMargin = (int) (height * (imageMargin + verticalImageOffset));
      imageView.layout(
        (int) leftMargin, (int) topMargin,
        (int) (leftMargin + width * imageSize), (int) (topMargin + height * imageSize));

      // Layout TextView
      leftMargin = offset * width;
      topMargin = height * verticalTextPos;
      textView.layout(
        (int) leftMargin, (int) topMargin,
        (int) (leftMargin + width), (int) (topMargin + height * (1.0f - verticalTextPos)));
    }
  }
}

1
---------------------------------
/*
Description: The credentials for connecting to the database are hard-wired into the sourcecode.
Keywords: Port Java Size0 Complex1 HasCreds

Copyright 2005 Fortify Software.

Permission is hereby granted, without written agreement or royalty fee, to
use, copy, modify, and distribute this software and its documentation for
any purpose, provided that the above copyright notice and the following
three paragraphs appear in all copies of this software.

IN NO EVENT SHALL FORTIFY SOFTWARE BE LIABLE TO ANY PARTY FOR DIRECT,
INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF FORTIFY SOFTWARE HAS
BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMANGE.

FORTIFY SOFTWARE SPECIFICALLY DISCLAIMS ANY WARRANTIES INCLUDING, BUT NOT
LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
PARTICULAR PURPOSE, AND NON-INFRINGEMENT.

THE SOFTWARE IS PROVIDED ON AN "AS-IS" BASIS AND FORTIFY SOFTWARE HAS NO
OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR
MODIFICATIONS.
*/

import java.io.*;
import javax.servlet.*;
import javax.servlet.http.*;
import javax.sql.*;
import java.sql.*;

public class Hascreds2_ok extends HttpServlet
{
	private Object _obj;

    public void doGet(HttpServletRequest req, HttpServletResponse res)
    	throws ServletException, IOException
    {
        res.setContentType("text/html");
        ServletOutputStream out = res.getOutputStream();
        out.println("<HTML><HEAD><TITLE>Test</TITLE></HEAD><BODY><blockquote><pre>");

		Connection conn = getConnection();	/* OK */
		out.println("got connection");

		try {
			PreparedStatement stmt = conn.prepareStatement("select * from mytab");
			ResultSet rs = stmt.executeQuery();
			out.println("results:");
			while(rs.next())
				out.println(rs.getString(1) + ", " + rs.getString(2));
		} catch(Exception e) {
			throw new ServletException(e);
		} finally {
			close(conn);
		}

        out.println("</pre></blockquote></BODY></HTML>");
        out.close();
    }

	public void close(Connection conn)
		throws ServletException
	{
		try {
			conn.close();
		} catch(Exception e) {
			throw new ServletException(e);
		}
	}

    public Connection getConnection()
		throws ServletException
    {
		try {
			if(_obj == null)
				_obj = Class.forName("org.gjt.mm.mysql.Driver").newInstance();
			String uname = getInitParameter("data-url");
			String user = getInitParameter("data-user");
			String pass = getInitParameter("data-pass");
			return  DriverManager.getConnection(uname, user, pass);	/* OK */
		} catch(Exception e) {
			throw new ServletException(e);
		} 
	}
}


0
---------------------------------
/*
Description: The credentials for connecting to the database are hard-wired into the sourcecode.
Keywords: Port Java Size0 Complex1 HasCreds

Copyright 2005 Fortify Software.

Permission is hereby granted, without written agreement or royalty fee, to
use, copy, modify, and distribute this software and its documentation for
any purpose, provided that the above copyright notice and the following
three paragraphs appear in all copies of this software.

IN NO EVENT SHALL FORTIFY SOFTWARE BE LIABLE TO ANY PARTY FOR DIRECT,
INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF FORTIFY SOFTWARE HAS
BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMANGE.

FORTIFY SOFTWARE SPECIFICALLY DISCLAIMS ANY WARRANTIES INCLUDING, BUT NOT
LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
PARTICULAR PURPOSE, AND NON-INFRINGEMENT.

THE SOFTWARE IS PROVIDED ON AN "AS-IS" BASIS AND FORTIFY SOFTWARE HAS NO
OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR
MODIFICATIONS.
*/

import java.io.*;
import javax.servlet.*;
import javax.servlet.http.*;
import javax.naming.*;
import javax.sql.*;
import java.sql.*;

public class Hascreds1_ok extends HttpServlet
{
	private DataSource _ds;

    public void doGet(HttpServletRequest req, HttpServletResponse res)
    	throws ServletException, IOException
    {
        res.setContentType("text/html");
        ServletOutputStream out = res.getOutputStream();
        out.println("<HTML><HEAD><TITLE>Test</TITLE></HEAD><BODY><blockquote><pre>");

		Connection conn = getConnection();	/* OK */
		out.println("got connection");

		try {
			PreparedStatement stmt = conn.prepareStatement("select * from mytab");
			ResultSet rs = stmt.executeQuery();
			out.println("results:");
			while(rs.next())
				out.println(rs.getString(1) + ", " + rs.getString(2));
		} catch(Exception e) {
			throw new ServletException(e);
		} finally {
			close(conn);
		}

        out.println("</pre></blockquote></BODY></HTML>");
        out.close();
    }

	public void close(Connection conn)
		throws ServletException
	{
		try {
			conn.close();
		} catch(Exception e) {
			throw new ServletException(e);
		}
	}

    public Connection getConnection()
		throws ServletException
    {
		try {
			if(_ds == null) {
				String dsname = getInitParameter("data-source");
				Context ctx = new InitialContext();
				_ds = (DataSource)ctx.lookup("java:comp/env/" + dsname); /* OK */
			}
			return _ds.getConnection(); /* OK */
		} catch(Exception e) {
			throw new ServletException(e);
		} 
	}
}


0
---------------------------------
/*
Description: Tainted data spliced into a SQL query leads to a SQL injection issue.
Keywords: Port Java Size0 Complex0 WebServer SQLInject
ValidParam: "name=' or ''='"
ValidParam: hi

Copyright 2005 Fortify Software.

Permission is hereby granted, without written agreement or royalty fee, to
use, copy, modify, and distribute this software and its documentation for
any purpose, provided that the above copyright notice and the following
three paragraphs appear in all copies of this software.

IN NO EVENT SHALL FORTIFY SOFTWARE BE LIABLE TO ANY PARTY FOR DIRECT,
INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF FORTIFY SOFTWARE HAS
BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMANGE.

FORTIFY SOFTWARE SPECIFICALLY DISCLAIMS ANY WARRANTIES INCLUDING, BUT NOT
LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
PARTICULAR PURPOSE, AND NON-INFRINGEMENT.

THE SOFTWARE IS PROVIDED ON AN "AS-IS" BASIS AND FORTIFY SOFTWARE HAS NO
OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR
MODIFICATIONS.
*/

import java.io.*;
import javax.servlet.*;
import javax.servlet.http.*;
import javax.naming.*;
import javax.sql.*;
import java.sql.*;

public class Sql1_ok extends HttpServlet
{
	private DataSource _ds;

    public void doGet(HttpServletRequest req, HttpServletResponse res)
    	throws ServletException, IOException
    {
        res.setContentType("text/html");
        ServletOutputStream out = res.getOutputStream();
        out.println("<HTML><HEAD><TITLE>Test</TITLE></HEAD><BODY><blockquote><pre>");

		String name = req.getParameter("name");
		if(name == null)
			name = "hi";

		Connection conn = getConnection();
		try {
			PreparedStatement stmt = conn.prepareStatement("select val from mytab where name = ?");
			stmt.setString(1, name);
			ResultSet rs = stmt.executeQuery();
			out.println("results:");
			while(rs.next())
				out.println(rs.getString(1));
		} catch(Exception e) {
			throw new ServletException(e);
		} finally {
			close(conn);
		}

        out.println("</pre></blockquote></BODY></HTML>");
        out.close();
    }

	public void close(Connection conn)
		throws ServletException
	{
		try {
			conn.close();
		} catch(Exception e) {
			throw new ServletException(e);
		}
	}

    public Connection getConnection()
		throws ServletException
    {
		try {
			if(_ds == null) {
				String dsname = getInitParameter("data-source");
				Context ctx = new InitialContext();
				_ds = (DataSource)ctx.lookup("java:comp/env/" + dsname);
			}
			return _ds.getConnection();
		} catch(Exception e) {
			throw new ServletException(e);
		} 
	}
}


0
---------------------------------
/*
Description: Tainted output allows log entries to be forged.
Keywords: Port Java Size0 Complex0 Taint LogForge
ValidParam: "cmd=forge%0aThis is a forged line"
ValidParam: cmd=ok

Copyright 2005 Fortify Software.

Permission is hereby granted, without written agreement or royalty fee, to
use, copy, modify, and distribute this software and its documentation for
any purpose, provided that the above copyright notice and the following
three paragraphs appear in all copies of this software.

IN NO EVENT SHALL FORTIFY SOFTWARE BE LIABLE TO ANY PARTY FOR DIRECT,
INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF FORTIFY SOFTWARE HAS
BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMANGE.

FORTIFY SOFTWARE SPECIFICALLY DISCLAIMS ANY WARRANTIES INCLUDING, BUT NOT
LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
PARTICULAR PURPOSE, AND NON-INFRINGEMENT.

THE SOFTWARE IS PROVIDED ON AN "AS-IS" BASIS AND FORTIFY SOFTWARE HAS NO
OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR
MODIFICATIONS.
*/
import java.io.*;
import java.util.logging.Logger;
import javax.servlet.*;
import javax.servlet.http.*;

public class Logforge1_ok extends HttpServlet
{
    public void doGet(HttpServletRequest req, HttpServletResponse res)
    	throws ServletException, IOException
    {
        res.setContentType("text/html");
        ServletOutputStream out = res.getOutputStream();
		Logger log = Logger.getLogger("Logforge");
        out.println("<HTML><HEAD><TITLE>Test</TITLE></HEAD><BODY><blockquote><pre>");

		String cmd = req.getParameter("cmd");
		if(cmd != null) {
			if(cmd == "valid")
				out.println("good");
			else
				log.info("invalid command: " + cmd.replaceAll("\n", "_"));		/* OK */
		} else {
			out.println("specify a command");
		}

        out.println("</pre></blockquote></BODY></HTML>");
        out.close();
    }
}


0
---------------------------------
/*
Description: Memory resources are referenced indefinitely but never used, resulting in a memory leak.
Keywords: Port Java Size0 Complex1 Api MemMgmt MemLeak

Copyright 2005 Fortify Software.

Permission is hereby granted, without written agreement or royalty fee, to
use, copy, modify, and distribute this software and its documentation for
any purpose, provided that the above copyright notice and the following
three paragraphs appear in all copies of this software.

IN NO EVENT SHALL FORTIFY SOFTWARE BE LIABLE TO ANY PARTY FOR DIRECT,
INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF FORTIFY SOFTWARE HAS
BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMANGE.

FORTIFY SOFTWARE SPECIFICALLY DISCLAIMS ANY WARRANTIES INCLUDING, BUT NOT
LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
PARTICULAR PURPOSE, AND NON-INFRINGEMENT.

THE SOFTWARE IS PROVIDED ON AN "AS-IS" BASIS AND FORTIFY SOFTWARE HAS NO
OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR
MODIFICATIONS.
*/
import java.io.*;
import java.util.*;
import javax.servlet.*;
import javax.servlet.http.*;

public class Mem2_ok extends HttpServlet
{
    public void doGet(HttpServletRequest req, HttpServletResponse res)
    	throws ServletException, IOException
    {
        res.setContentType("text/html");
        ServletOutputStream out = res.getOutputStream();
        out.println("<HTML><HEAD><TITLE>Test</TITLE></HEAD><BODY><blockquote><pre>");

		HttpSession sess = req.getSession(true);
		ArrayList<String> urlList = (ArrayList<String>)sess.getAttribute("list");
		if(urlList == null) {
			urlList = new ArrayList<String>();
			sess.setAttribute("list", urlList);
		}
		
		String url = req.getRequestURI();
		int len;
		urlList.add(url);			/* OK */
		len = urlList.size();
		out.print(len);
		out.println(" urls in list");

        out.println("</pre></blockquote></BODY></HTML>");
        out.close();
    }
}


0
---------------------------------
/*
Description: Tainted input allows command execution.
Keywords: Port Java Size0 Complex0 Taint Unsafe
ValidParam: "user=bogus;ls -l /"
ValidParam: user=root

Copyright 2005 Fortify Software.

Permission is hereby granted, without written agreement or royalty fee, to
use, copy, modify, and distribute this software and its documentation for
any purpose, provided that the above copyright notice and the following
three paragraphs appear in all copies of this software.

IN NO EVENT SHALL FORTIFY SOFTWARE BE LIABLE TO ANY PARTY FOR DIRECT,
INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF FORTIFY SOFTWARE HAS
BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMANGE.

FORTIFY SOFTWARE SPECIFICALLY DISCLAIMS ANY WARRANTIES INCLUDING, BUT NOT
LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
PARTICULAR PURPOSE, AND NON-INFRINGEMENT.

THE SOFTWARE IS PROVIDED ON AN "AS-IS" BASIS AND FORTIFY SOFTWARE HAS NO
OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR
MODIFICATIONS.
*/
import java.lang.Runtime;
import java.io.*;
import javax.servlet.*;
import javax.servlet.http.*;

public class Proc1_ok extends HttpServlet
{
    public void doGet(HttpServletRequest req, HttpServletResponse res)
    	throws ServletException, IOException
    {
        res.setContentType("text/html");
        ServletOutputStream out = res.getOutputStream();
        out.println("<HTML><HEAD><TITLE>Test</TITLE></HEAD><BODY><blockquote><pre>");

		String user = req.getParameter("user");
		if(user != null) {
			try {
				String[] args = { "/usr/bin/finger", user };
				Process p = Runtime.getRuntime().exec(args);
				BufferedReader fingdata = new BufferedReader(new InputStreamReader(p.getInputStream()));
				String line;
				while((line = fingdata.readLine()) != null)
					out.println(line);
				p.waitFor();
			} catch(Exception e) {
				throw new ServletException(e);
			}
		} else {
			out.println("specify a user");
		}

        out.println("</pre></blockquote></BODY></HTML>");
        out.close();
    }
}


0
---------------------------------
/*
Description: Tainted input allows arbitrary files to be read and written.
Keywords: Port Java Size0 Complex0 DirTraverse
ValidParam: name=../etc/passwd
ValidParam: name=test&msg=hi
ValidParam: name=test

Copyright 2005 Fortify Software.

Permission is hereby granted, without written agreement or royalty fee, to
use, copy, modify, and distribute this software and its documentation for
any purpose, provided that the above copyright notice and the following
three paragraphs appear in all copies of this software.

IN NO EVENT SHALL FORTIFY SOFTWARE BE LIABLE TO ANY PARTY FOR DIRECT,
INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF FORTIFY SOFTWARE HAS
BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMANGE.

FORTIFY SOFTWARE SPECIFICALLY DISCLAIMS ANY WARRANTIES INCLUDING, BUT NOT
LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
PARTICULAR PURPOSE, AND NON-INFRINGEMENT.

THE SOFTWARE IS PROVIDED ON AN "AS-IS" BASIS AND FORTIFY SOFTWARE HAS NO
OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR
MODIFICATIONS.
*/
import java.io.*;
import javax.servlet.*;
import javax.servlet.http.*;

public class File1_ok extends HttpServlet
{
    public void doGet(HttpServletRequest req, HttpServletResponse res)
    	throws ServletException, IOException
    {
        res.setContentType("text/html");
        ServletOutputStream out = res.getOutputStream();
        out.println("<HTML><HEAD><TITLE>Test</TITLE></HEAD><BODY><blockquote><pre>");

		String name = req.getParameter("name");
		String msg = req.getParameter("msg");
		if(name != null) {
			try {
				File f = new File("/tmp", name.replaceAll("[^a-z]","_"));	/* OK */
				if(msg != null) {
					FileWriter fw = new FileWriter(f);	/* OK */
					fw.write(msg, 0, msg.length());
					fw.close();
					out.println("message stored");
				} else {
					String line;
					BufferedReader fr = new BufferedReader(new FileReader(f));	/* OK */
					while((line = fr.readLine()) != null)
						out.println(line);
				}
			} catch(Exception e) {
				throw new ServletException(e);
			}
		} else {
			out.println("specify a name and an optional msg");
		}

        out.println("</pre></blockquote></BODY></HTML>");
        out.close();
    }
}


0
---------------------------------
/*
Description: Tainted output allows cross-site scripting attack.
XXX verify that we can inject the appropriate cookie from an URL to perform the xss.
Keywords: Port Java Size0 Complex0 WebServer XSS
ValidCookie: cmd=<script language=javascript>alert("gotcha")</script>
ValidCookie: cmd=gotcha

Copyright 2005 Fortify Software.

Permission is hereby granted, without written agreement or royalty fee, to
use, copy, modify, and distribute this software and its documentation for
any purpose, provided that the above copyright notice and the following
three paragraphs appear in all copies of this software.

IN NO EVENT SHALL FORTIFY SOFTWARE BE LIABLE TO ANY PARTY FOR DIRECT,
INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF FORTIFY SOFTWARE HAS
BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMANGE.

FORTIFY SOFTWARE SPECIFICALLY DISCLAIMS ANY WARRANTIES INCLUDING, BUT NOT
LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
PARTICULAR PURPOSE, AND NON-INFRINGEMENT.

THE SOFTWARE IS PROVIDED ON AN "AS-IS" BASIS AND FORTIFY SOFTWARE HAS NO
OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR
MODIFICATIONS.
*/
import java.io.*;
import javax.servlet.*;
import javax.servlet.http.*;

public class Xss2_ok extends HttpServlet
{
    public void doGet(HttpServletRequest req, HttpServletResponse res)
    	throws ServletException, IOException
    {
        res.setContentType("text/html");
        ServletOutputStream out = res.getOutputStream();
        out.println("<HTML><HEAD><TITLE>Test</TITLE></HEAD><BODY><blockquote><pre>");

		String cmd = null;
		Cookie[] cookie = req.getCookies();
		if(cookie != null) {
			for(int i = 0; i < cookie.length; i++) {
				if(cookie[i].getName() == "cmd")
					cmd = cookie[i].getValue();
			}
		}

		if(cmd != null) {
			if(cmd == "valid")
				out.println("good");
			else
				out.println("invalid command: " + cmd);		/* OK */
		} else {
			out.println("specify a command");
		}

        out.println("</pre></blockquote></BODY></HTML>");
        out.close();
    }
}


0
---------------------------------
/*
Description: Tainted output allows cross-site scripting attack.
Keywords: Port Java Size0 Complex0 WebServer XSS
ValidParam: cmd=<script language=javascript>alert("gotcha")</script>
ValidParam: cmd=gotcha

Copyright 2005 Fortify Software.

Permission is hereby granted, without written agreement or royalty fee, to
use, copy, modify, and distribute this software and its documentation for
any purpose, provided that the above copyright notice and the following
three paragraphs appear in all copies of this software.

IN NO EVENT SHALL FORTIFY SOFTWARE BE LIABLE TO ANY PARTY FOR DIRECT,
INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF FORTIFY SOFTWARE HAS
BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMANGE.

FORTIFY SOFTWARE SPECIFICALLY DISCLAIMS ANY WARRANTIES INCLUDING, BUT NOT
LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
PARTICULAR PURPOSE, AND NON-INFRINGEMENT.

THE SOFTWARE IS PROVIDED ON AN "AS-IS" BASIS AND FORTIFY SOFTWARE HAS NO
OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR
MODIFICATIONS.
*/
import java.io.*;
import javax.servlet.*;
import javax.servlet.http.*;

public class Xss1_ok extends HttpServlet
{
    public void doGet(HttpServletRequest req, HttpServletResponse res)
    	throws ServletException, IOException
    {
        res.setContentType("text/html");
        ServletOutputStream out = res.getOutputStream();
        out.println("<HTML><HEAD><TITLE>Test</TITLE></HEAD><BODY><blockquote><pre>");

		String cmd = req.getParameter("cmd");
		if(cmd != null) {
			if(cmd == "valid")
				out.println("good");
			else
				out.println("invalid command: " + cmd.replaceAll("[^a-zA-Z]", "_"));	/* OK */
		} else {
			out.println("specify a command");
		}

        out.println("</pre></blockquote></BODY></HTML>");
        out.close();
    }
}


0
---------------------------------
/*
Description: Tainted output allows log entries to be forged.
Keywords: Port Java Size0 Complex0 Taint LogForge
ValidParam: "cmd=forge%0aThis is a forged line"
ValidParam: cmd=ok

Copyright 2005 Fortify Software.

Permission is hereby granted, without written agreement or royalty fee, to
use, copy, modify, and distribute this software and its documentation for
any purpose, provided that the above copyright notice and the following
three paragraphs appear in all copies of this software.

IN NO EVENT SHALL FORTIFY SOFTWARE BE LIABLE TO ANY PARTY FOR DIRECT,
INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF FORTIFY SOFTWARE HAS
BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMANGE.

FORTIFY SOFTWARE SPECIFICALLY DISCLAIMS ANY WARRANTIES INCLUDING, BUT NOT
LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
PARTICULAR PURPOSE, AND NON-INFRINGEMENT.

THE SOFTWARE IS PROVIDED ON AN "AS-IS" BASIS AND FORTIFY SOFTWARE HAS NO
OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR
MODIFICATIONS.
*/
import java.io.*;
import java.util.logging.Logger;
import javax.servlet.*;
import javax.servlet.http.*;

public class Logforge2_ok extends HttpServlet
{
    public void doGet(HttpServletRequest req, HttpServletResponse res)
    	throws ServletException, IOException
    {
        res.setContentType("text/html");
        ServletOutputStream out = res.getOutputStream();
		ServletContext sctx = getServletContext();
        out.println("<HTML><HEAD><TITLE>Test</TITLE></HEAD><BODY><blockquote><pre>");

		String cmd = req.getParameter("cmd");
		if(cmd != null) {
			if(cmd == "valid")
				out.println("good");
			else
				sctx.log("invalid command: " + cmd.replaceAll("\n", "_"));		/* OK */
		} else {
			out.println("specify a command");
		}

        out.println("</pre></blockquote></BODY></HTML>");
        out.close();
    }
}


0
---------------------------------
/*
Description: An exception leaks internal path information to the user.
Keywords: Port Java Size0 Complex0 Taint InfoLeak
ValidParam: name=nonexistantfilenamehere

Copyright 2005 Fortify Software.

Permission is hereby granted, without written agreement or royalty fee, to
use, copy, modify, and distribute this software and its documentation for
any purpose, provided that the above copyright notice and the following
three paragraphs appear in all copies of this software.

IN NO EVENT SHALL FORTIFY SOFTWARE BE LIABLE TO ANY PARTY FOR DIRECT,
INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF FORTIFY SOFTWARE HAS
BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMANGE.

FORTIFY SOFTWARE SPECIFICALLY DISCLAIMS ANY WARRANTIES INCLUDING, BUT NOT
LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
PARTICULAR PURPOSE, AND NON-INFRINGEMENT.

THE SOFTWARE IS PROVIDED ON AN "AS-IS" BASIS AND FORTIFY SOFTWARE HAS NO
OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR
MODIFICATIONS.
*/
import java.io.*;
import javax.servlet.*;
import javax.servlet.http.*;

public class Info1_ok extends HttpServlet
{
    public void doGet(HttpServletRequest req, HttpServletResponse res)
    	throws ServletException, IOException
    {
        res.setContentType("text/html");
        ServletOutputStream out = res.getOutputStream();
        out.println("<HTML><HEAD><TITLE>Test</TITLE></HEAD><BODY><blockquote><pre>");

		String name = req.getParameter("name");
		String msg = req.getParameter("msg");
		if(name != null) {
			try {
				File f = new File("/tmp", name);
				BufferedReader fr = new BufferedReader(new FileReader(f));
				String line;
				while((line = fr.readLine()) != null)
					out.println(line);
			} catch(Exception e) {
				out.println("error reading from that name");	/* OK */
			}
		} else {
			out.println("specify a name");
		}

        out.println("</pre></blockquote></BODY></HTML>");
        out.close();
    }
}


0
---------------------------------
/*
Description: Memory resources are referenced indefinitely but never used, resulting in a memory leak.
Keywords: Port Java Size0 Complex1 Api MemMgmt MemLeak

Copyright 2005 Fortify Software.

Permission is hereby granted, without written agreement or royalty fee, to
use, copy, modify, and distribute this software and its documentation for
any purpose, provided that the above copyright notice and the following
three paragraphs appear in all copies of this software.

IN NO EVENT SHALL FORTIFY SOFTWARE BE LIABLE TO ANY PARTY FOR DIRECT,
INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF FORTIFY SOFTWARE HAS
BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMANGE.

FORTIFY SOFTWARE SPECIFICALLY DISCLAIMS ANY WARRANTIES INCLUDING, BUT NOT
LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
PARTICULAR PURPOSE, AND NON-INFRINGEMENT.

THE SOFTWARE IS PROVIDED ON AN "AS-IS" BASIS AND FORTIFY SOFTWARE HAS NO
OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR
MODIFICATIONS.
*/
import java.io.*;
import java.util.*;
import javax.servlet.*;
import javax.servlet.http.*;

public class Mem1_ok extends HttpServlet
{
	protected static final int MAXSIZE = 5;
	protected ArrayList<String> _urlList;

	public Mem1_ok() {
		_urlList = new ArrayList<String>();
	}

    public void doGet(HttpServletRequest req, HttpServletResponse res)
    	throws ServletException, IOException
    {
        res.setContentType("text/html");
        ServletOutputStream out = res.getOutputStream();
        out.println("<HTML><HEAD><TITLE>Test</TITLE></HEAD><BODY><blockquote><pre>");

		String url = req.getRequestURI();
		int len;
		synchronized(_urlList) {
			_urlList.add(url);			/* OK */
			if(_urlList.size() > MAXSIZE)
				_urlList.remove(0);		/* OK */
			len = _urlList.size();
		}
		out.print(len);
		out.println(" urls in list");

        out.println("</pre></blockquote></BODY></HTML>");
        out.close();
    }
}


0
---------------------------------
package good;
/* This software was developed at the National Institute of Standards and
 * Technology by employees of the Federal Government in the course of their
 * official duties. Pursuant to title 17 Section 105 of the United States
 * Code this software is not subject to copyright protection and is in the
 * public domain. NIST assumes no responsibility whatsoever for its use by
 * other parties, and makes no guarantees, expressed or implied, about its
 * quality, reliability, or any other characteristic.
 * We would appreciate acknowledgement if the software is used.
 * The SAMATE project website is: http://samate.nist.gov
 */

/*
 * This servlet implements a Cross-Site Scripting vulnerability (XSS)
 * Parameters:
 *   - data: source of the vulnerability
 * Example:
 *   - url: http://server_address/path_to_servlet/CrossSiteScripting_080?data=<script>alert('XSS');</script>
 */

import java.io.IOException;
import javax.servlet.ServletException;
import javax.servlet.ServletOutputStream;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class CrossSiteScripting_good_080 extends HttpServlet
{
	private static final long serialVersionUID = 1L;
       
    public CrossSiteScripting_good_080()
    {
        super();
    }

    // Method which will be called to handle HTTP GET requests
	protected void doGet( HttpServletRequest req, HttpServletResponse resp )
		throws ServletException, IOException
	{
		// Prepare the output data that will be sent back to the client
		resp.setContentType( "text/html" );
		ServletOutputStream out = resp.getOutputStream();
		
		// Write the HTML document to the output stream.
		// Note that the data provided by the client in
		// the field "data" is encoded so there is no more XSS
		out.println( "<html><body><blockquote><pre>" );
		String s =  req.getParameter( "data" );
		
		if ((s != null) && (s.length() > 0))
		{
			String s_encode = htmlEntityEncode( s );
			if (s_encode != null)
				out.println(  s_encode );
		}
		out.println( "</pre></blockquote></body></html>" );
	}

	// From OWASP: Return StringBuilder and/or make Writer param and write to stream directly
	public static String htmlEntityEncode( String s )
	{
		int len = s.length();
		StringBuilder buf = new StringBuilder(len);
			
		for ( int i = 0; i < len; i++ )
		{
			char c = s.charAt( i );
			if ( c>='a' && c<='z' || c>='A' && c<='Z' || c>='0' && c<='9' )
			{
				buf.append( c );
			}
			else
			{
				buf.append("&#").append((int)c).append(";");
			}
		}
		
		return buf.toString();
	}

	protected void doPost(HttpServletRequest request, HttpServletResponse response)
		throws ServletException, IOException
	{
	}
}

0
---------------------------------
package goodCodeComplexity;
/* This software was developed at the National Institute of Standards and
 * Technology by employees of the Federal Government in the course of their
 * official duties. Pursuant to title 17 Section 105 of the United States
 * Code this software is not subject to copyright protection and is in the
 * public domain. NIST assumes no responsibility whatsoever for its use by
 * other parties, and makes no guarantees, expressed or implied, about its
 * quality, reliability, or any other characteristic.
 * We would appreciate acknowledgement if the software is used.
 * The SAMATE project website is: http://samate.nist.gov
 */

/*
 * This servlet implements a Cross-Site Scripting vulnerability (XSS)
 * Parameters:
 *   - data: source of the vulnerability
 * Example:
 *   - url: http://server_address/path_to_servlet/CrossSiteScripting_080?data=<script>alert('XSS');</script>
 */

import java.io.IOException;
import javax.servlet.ServletException;
import javax.servlet.ServletOutputStream;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class CrossSiteScripting_good_container_080 extends HttpServlet
{
	private static final long serialVersionUID = 1L;
       
    public CrossSiteScripting_good_container_080()
    {
        super();
    }

    // Method which will be called to handle HTTP GET requests
	protected void doGet( HttpServletRequest req, HttpServletResponse resp )
		throws ServletException, IOException
	{
		// Prepare the output data that will be sent back to the client
		resp.setContentType( "text/html" );
		ServletOutputStream out = resp.getOutputStream();
		
		// Write the HTML document to the output stream.
		// Note that the data provided by the client in
		// the field "data" is encoded so there is no more XSS
		out.println( "<html><body><blockquote><pre>" );
		String container_data[] = new String[1];
		container_data[0] = req.getParameter( "data" );
		
		if ((container_data[0] != null) && (container_data[0].length() > 0))
		{
			String s_encode = htmlEntityEncode( container_data[0] );
			if (s_encode != null)
				out.println(  s_encode );
		}
		out.println( "</pre></blockquote></body></html>" );
	}

	// From OWASP: Return StringBuilder and/or make Writer param and write to stream directly
	public static String htmlEntityEncode( String s )
	{
		int len = s.length();
		StringBuilder buf = new StringBuilder(len);
			
		for ( int i = 0; i < len; i++ )
		{
			char c = s.charAt( i );
			if ( c>='a' && c<='z' || c>='A' && c<='Z' || c>='0' && c<='9' )
			{
				buf.append( c );
			}
			else
			{
				buf.append("&#").append((int)c).append(";");
			}
		}
		
		return buf.toString();
	}

	protected void doPost(HttpServletRequest request, HttpServletResponse response)
		throws ServletException, IOException
	{
	}
}

0
---------------------------------
package goodCodeComplexity;
/* This software was developed at the National Institute of Standards and
 * Technology by employees of the Federal Government in the course of their
 * official duties. Pursuant to title 17 Section 105 of the United States
 * Code this software is not subject to copyright protection and is in the
 * public domain. NIST assumes no responsibility whatsoever for its use by
 * other parties, and makes no guarantees, expressed or implied, about its
 * quality, reliability, or any other characteristic.
 * We would appreciate acknowledgement if the software is used.
 * The SAMATE project website is: http://samate.nist.gov
 */

/*
 * This servlet implements an SQL injection vulnerability
 * Parameters:
 *   - name: source of the vulnerability
 * Example:
 *   - url: http://server_address/path_to_servlet/SQLInjection_089?name=' OR ''='
 */

import java.io.IOException;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.logging.Logger;

import javax.naming.Context;
import javax.naming.InitialContext;
import javax.naming.NamingException;
import javax.servlet.ServletException;
import javax.servlet.ServletOutputStream;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.sql.DataSource;

public class SQLInjection_good_scope_089 extends HttpServlet
{
	private static final long serialVersionUID = 1L;
    
    public SQLInjection_good_scope_089()
    {
        super();
    }
	
	// Table of allowed names to use
	final String allowed_names[] = { "Mickael", "Mary", 
			"Peter", "Laura", "John"};
	 
	// Function to check if the current name takes part of the allowed ones
	public boolean allowed( String in )
	{
		boolean bool = false;
		
        for( int i = 0; i < 5; i++ )
        {
            if( in.equals( allowed_names[i] ) )
            {
              	// the current name is allowed to use
                bool = true;
                break;
            }
        }
        return bool;
	}

    public PreparedStatement function(  Connection conn, String name )
	{
    	PreparedStatement p = null;
    	try
    	{
    		// Prepare a SQL request
			p = conn.prepareStatement( "SELECT * FROM users WHERE firstname LIKE ?" );
			// replace the first parameter by name
	    	p.setString(1, name);
    	}
    	catch (SQLException se)
    	{
    		final Logger logger = Logger.getAnonymousLogger();
			String exception = "Exception " + se;
			logger.warning( exception );
    	}
    	return p;
	}
    
    // Method which will be called to handle HTTP GET requests
	protected void doGet( HttpServletRequest req, HttpServletResponse resp )
		throws ServletException, IOException
	{
		// Initialize the output stream
		resp.setContentType("text/html");
		ServletOutputStream out = resp.getOutputStream();
		out.println("<HTML><BODY><blockquote><pre>");
		Connection conn = null;
				
		// Get the parameter "name" from the data provided by the user
		String name = req.getParameter( "name" );
		
		if ( (name != null) && (allowed(name) == true) )
		{
			try
			{
				// Set the context factory to use to create the initial context
				System.setProperty (Context.INITIAL_CONTEXT_FACTORY, "your.ContextFactory");

				// Create the initial context and use it to lookup the data source
				InitialContext ic = new InitialContext ();
				DataSource dataSrc = (DataSource) ic.lookup ("java:comp/env/jdbc:/mydb");

				// Create a connection to the SQL database from the data source
				conn = dataSrc.getConnection();
				
				// Send a SQL request to the database
				PreparedStatement ps = function(conn, name);
				ps.executeQuery ();
		    }
		    catch( NamingException e )
		    {
		    	out.println( "Naming exception");
			}
		    catch( SQLException e )
		    {
		    	out.println( "SQL exception");
		    }
		    finally
		    {
		    	try
		    	{
		    		if (conn != null)
		    			conn.close ();
		    	}
		    	catch (SQLException se)
		    	{
		    		out.println("SQL Exception");
		    	}
		    }
		}
		else
			return;
		
		out.println( "</pre></blockquote></body></html>" );
	}

	protected void doPost(HttpServletRequest request, HttpServletResponse response)
		throws ServletException, IOException
	{
	}
}

0
---------------------------------
package goodCodeComplexity;
/* This software was developed at the National Institute of Standards and
 * Technology by employees of the Federal Government in the course of their
 * official duties. Pursuant to title 17 Section 105 of the United States
 * Code this software is not subject to copyright protection and is in the
 * public domain. NIST assumes no responsibility whatsoever for its use by
 * other parties, and makes no guarantees, expressed or implied, about its
 * quality, reliability, or any other characteristic.
 * We would appreciate acknowledgement if the software is used.
 * The SAMATE project website is: http://samate.nist.gov
 */

/*
 * This servlet implements a Cross-Site Scripting vulnerability (XSS)
 * Parameters:
 *   - data: source of the vulnerability
 * Example:
 *   - url: http://server_address/path_to_servlet/CrossSiteScripting_080?data=<script>alert('XSS');</script>
 */

import java.io.IOException;
import javax.servlet.ServletException;
import javax.servlet.ServletOutputStream;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class CrossSiteScripting_good_Loop_080 extends HttpServlet
{
	private static final long serialVersionUID = 1L;
       
    public CrossSiteScripting_good_Loop_080()
    {
        super();
    }

    // Method which will be called to handle HTTP GET requests
	protected void doGet( HttpServletRequest req, HttpServletResponse resp )
		throws ServletException, IOException
	{
		// Prepare the output data that will be sent back to the client
		resp.setContentType( "text/html" );
		ServletOutputStream out = resp.getOutputStream();
		
		// Write the HTML document to the output stream.
		// Note that the data provided by the client in
		// the field "data" is encoded so there is no more XSS
		out.println( "<html><body><blockquote><pre>" );
		for (int i = 0; i < 3; i++)
		{
			String s =  req.getParameter( "data" );
			
			if ((s != null) && (s.length() > 0))
			{
				String s_encode = htmlEntityEncode( s );
				if (s_encode != null)
					out.println(  s_encode );
			}
		}
		out.println( "</pre></blockquote></body></html>" );
	}

	// From OWASP: Return StringBuilder and/or make Writer param and write to stream directly
	public static String htmlEntityEncode( String s )
	{
		int len = s.length();
		StringBuilder buf = new StringBuilder(len);
			
		for ( int i = 0; i < len; i++ )
		{
			char c = s.charAt( i );
			if ( c>='a' && c<='z' || c>='A' && c<='Z' || c>='0' && c<='9' )
			{
				buf.append( c );
			}
			else
			{
				buf.append("&#").append((int)c).append(";");
			}
		}
		
		return buf.toString();
	}

	protected void doPost(HttpServletRequest request, HttpServletResponse response)
		throws ServletException, IOException
	{
	}
}

0
---------------------------------
package goodCodeComplexity;
/* This software was developed at the National Institute of Standards and
 * Technology by employees of the Federal Government in the course of their
 * official duties. Pursuant to title 17 Section 105 of the United States
 * Code this software is not subject to copyright protection and is in the
 * public domain. NIST assumes no responsibility whatsoever for its use by
 * other parties, and makes no guarantees, expressed or implied, about its
 * quality, reliability, or any other characteristic.
 * We would appreciate acknowledgement if the software is used.
 * The SAMATE project website is: http://samate.nist.gov
 */

/*
 * This servlet implements a Cross-Site Scripting vulnerability (XSS)
 * Parameters:
 *   - data: source of the vulnerability
 * Example:
 *   - url: http://server_address/path_to_servlet/CrossSiteScripting_080?data=<script>alert('XSS');</script>
 */

import java.io.IOException;
import javax.servlet.ServletException;
import javax.servlet.ServletOutputStream;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class CrossSiteScripting_good_scope_080 extends HttpServlet
{
	private static final long serialVersionUID = 1L;
       
    public CrossSiteScripting_good_scope_080()
    {
        super();
    }

    public String function(  HttpServletRequest req, String data )
	{
    	String s_encode = null;
    	
    	String s =  req.getParameter( "data" );
		if ((s != null) && (s.length() > 0))
		{
			s_encode = htmlEntityEncode( s );
		}
		
		// The string file is not validated before the execution
		return s_encode;
	}
    
    // Method which will be called to handle HTTP GET requests
	protected void doGet( HttpServletRequest req, HttpServletResponse resp )
		throws ServletException, IOException
	{
		// Prepare the output data that will be sent back to the client
		resp.setContentType( "text/html" );
		ServletOutputStream out = resp.getOutputStream();
		
		// Write the HTML document to the output stream.
		// Note that the data provided by the client in
		// the field "data" is encoded so there is no more XSS
		out.println( "<html><body><blockquote><pre>" );
		String s =  req.getParameter( "data" );
		
		if ((s != null) && (s.length() > 0))
		{
			String s_encode = function(req,"data");
			if (s_encode != null)
				out.println(  s_encode );
		}
		out.println( "</pre></blockquote></body></html>" );
	}

	// From OWASP: Return StringBuilder and/or make Writer param and write to stream directly
	public static String htmlEntityEncode( String s )
	{
		int len = s.length();
		StringBuilder buf = new StringBuilder(len);
			
		for ( int i = 0; i < len; i++ )
		{
			char c = s.charAt( i );
			if ( c>='a' && c<='z' || c>='A' && c<='Z' || c>='0' && c<='9' )
			{
				buf.append( c );
			}
			else
			{
				buf.append("&#").append((int)c).append(";");
			}
		}
		
		return buf.toString();
	}

	protected void doPost(HttpServletRequest request, HttpServletResponse response)
		throws ServletException, IOException
	{
	}
}

0
---------------------------------
/* This software was developed at the National Institute of Standards and
 * Technology by employees of the Federal Government in the course of their
 * official duties. Pursuant to title 17 Section 105 of the United States
 * Code this software is not subject to copyright protection and is in the
 * public domain. NIST assumes no responsibility whatsoever for its use by
 * other parties, and makes no guarantees, expressed or implied, about its
 * quality, reliability, or any other characteristic.

 * We would appreciate acknowledgement if the software is used.
 * The SAMATE project website is: http://samate.nist.gov
*/

import java.io.*;

public class Pass_controlflow_good
{
	public static void main (String[]args)
	{
		try
		{
		BufferedReader read = new BufferedReader(new FileReader("Passwords.txt"));
		String adminPass = read.readLine();
		if (args[0].equals(adminPass))
			System.out.println("Access Granted");
		else
			System.out.println("Your password is not valid, please reenter it.");
		}
		catch(IOException e){
		System.out.println("io error");}
		return;
	}

}
0
---------------------------------
package servlets;
/*
 * This software was developed at the National Institute of Standards and
 * Technology by employees of the Federal Government in the course of their
 * official duties. Pursuant to title 17 Section 105 of the United States
 * Code this software is not subject to copyright protection and is in the
 * public domain. NIST assumes no responsibility whatsoever for its use by
 * other parties, and makes no guarantees, expressed or implied, about its
 * quality, reliability, or any other characteristic.
 *
 * This reference program was developed in Jan 2010 as part of the Software
 * Assurance Metrics And Tool Evaluation (SAMATE) project.
 * We would appreciate acknowledgment if the software is used.
 * The SAMATE project website is: http://samate.nist.gov
 */

/*
 * This code (java servlet) has a FIX to Failure to Preserve Web Page
 * Structure 'Cross-site Scripting (XSS)' CWE-79 vulnerability.
 * http://cwe.mitre.org
 *
 * This code demos the Reflected XSS (or Non-Persistent) ==> "Scope Good Case".
 * The servlet reads the user input from the HTTP request and
 * reflects it back into the HTTP response after performing the
 * validate, filter, escape and encode of that user input data.
 *
 */

import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class cwe79_reflectedXSS_good_scope extends HttpServlet {

    public void doGet(
        HttpServletRequest request,
        HttpServletResponse response) throws ServletException, IOException {

        response.setContentType("text/html");

        PrintWriter out = response.getWriter();

        out.println("<html>" + "<head><title>CWE79 Reflected XSS (Scope) Good</title></head>");

        out.println(
                "<body  bgcolor=\"#ffffff\">"
                + "<h4>Hello, my name is Test4XSS. What's yours?</h4>"
                + "<form method=\"get\">"
                + "<input type=\"text\" name=\"username\" size=\"50\">"
                + "<p></p>" + "<input type=\"submit\" value=\"Submit\">"
                + "<input type=\"reset\" value=\"Reset\">" + "</form>");

		String username = getStr (request, "username");	/* Scope */

	 	if (isValidateInput(username)) {
			String cleanedUsername = htmlEntityEncode (username);
			if ((cleanedUsername != null) && (cleanedUsername.length() > 0)) {
				out.println ("<h4>Hello, ");
				out.println (cleanedUsername);		/* OK - user input is being validated and encoded */
				out.println ("!</h4>");
	       	}
	 	}
	 	else if (username !=null) {
			out.println ("<h4>Sorry, your input is invalid</h4>");
		}

        out.println("</body></html>");
        out.close();
    }

    private String getStr (HttpServletRequest request, String inStr) {
		String s = request.getParameter(inStr);
		return s;
	}

	/*
	 * To prevent XSS, assume all input is malicious. This function is just
	 * an example and placeholder for demonstrating the need of performing proper
	 * output encoding, escaping and quoting. All references are used as example for
	 * demonstration only.They are neither for endorsement nor recommendation.
	 *
	 * One should decide to use existing Security API
	 * (e.g., OWASP Enterprise Security API (ESAPI) 2.0), or customized API, or
	 * customized functions for the same purpose.
	 *
	 * This test case used two functions for the purpose of protecting against XSS.
	 *   - isValudateInput - uses whitelist method to check the user input (example only)
	 *   - htmlEntityEncode - does the html encode (sourced by OWASP:
	 *              http://www.owasp.org/index.php/How_to_perform_HTML_entity_encoding_in_Java)
	 *
	 */
	private static final boolean isValidateInput (String uInput) {

		/*
		 * used as example with the whitelist to only allow alphnumeric, space and "'" as
		 * character set for name.  The length of the user input is also registrted within 100
		 *
		 */

		if (uInput == null)
			return false;

		if (uInput.matches ("[a-zA-Z0-9' ]*") && (uInput.length() <= 100))
			return true;
		else
			return false;
	}

    // From OWASP: Return StringBuilder and/or make Writer param and write to stream directly
    public static String htmlEntityEncode( String s )
        {
                int len = s.length();
                StringBuilder buf = new StringBuilder(len);

                for ( int i = 0; i < len; i++ )
                {
                        char c = s.charAt( i );
                        if ( c>='a' && c<='z' || c>='A' && c<='Z' || c>='0' && c<='9' )
                        {
                                buf.append( c );
                        }
                        else
                        {
                                buf.append("&#").append((int)c).append(";");
                        }
                }

                return buf.toString();
    }

    public String getServletInfo() {
        return "The Hello servlet says hello.(with CWE79 Reflected fixed XSS (Scope) sample code).";
    }
}

0
---------------------------------
package servlets;
/*
 * This software was developed at the National Institute of Standards and
 * Technology by employees of the Federal Government in the course of their
 * official duties. Pursuant to title 17 Section 105 of the United States
 * Code this software is not subject to copyright protection and is in the
 * public domain. NIST assumes no responsibility whatsoever for its use by
 * other parties, and makes no guarantees, expressed or implied, about its
 * quality, reliability, or any other characteristic.
 *
 * This reference program was developed in Jan 2010 as part of the Software
 * Assurance Metrics And Tool Evaluation (SAMATE) project.
 * We would appreciate acknowledgment if the software is used.
 * The SAMATE project website is: http://samate.nist.gov
 */

/*
 * This code (java servlet) has a FIX to Failure to Preserve Web Page
 * Structure 'Cross-site Scripting (XSS)' CWE-79 vulnerability.
 * http://cwe.mitre.org
 *
 * This code demos the Reflected XSS (or Non-Persistent) ==> "Loop Good Case".
 * The servlet reads the user input from the HTTP request and
 * reflects it back into the HTTP response after performing the
 * validate, filter, escape and encode of that user input data.
 *
 */

import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class cwe79_reflectedXSS_good_loop extends HttpServlet {

    public void doGet(
        HttpServletRequest request,
        HttpServletResponse response) throws ServletException, IOException {

        response.setContentType("text/html");

        PrintWriter out = response.getWriter();

        out.println("<html>" + "<head><title>CWE79 Reflected XSS Good</title></head>");

        out.println(
                "<body  bgcolor=\"#ffffff\">"
                + "<h4>Hello, my name is Test4XSS. What's yours?</h4>"
                + "<form method=\"get\">"
                + "<input type=\"text\" name=\"username\" size=\"50\">"
                + "<p></p>" + "<input type=\"submit\" value=\"Submit\">"
                + "<input type=\"reset\" value=\"Reset\">" + "</form>");

	for (int i = 1; i < 4; i++) {	/* Loop */
		out.println ("Loop # " + i);
        String username = request.getParameter("username");

		if (isValidateInput(username)) {
				String cleanedUsername = htmlEntityEncode (username);
				if ((cleanedUsername != null) && (cleanedUsername.length() > 0)) {
						out.println ("<h4>Hello, ");
						out.println (cleanedUsername);	/* OK - user input is being validated and encoded */
						out.println ("!</h4>");
				}
		}
		else if (username !=null)  {
			out.println ("<h4>Sorry, your input is invalid</h4>");
		}
	}
        out.println("</body></html>");
        out.close();
    }

	/*
	 * To prevent XSS, assume all input is malicious. This function is just
	 * an example and placeholder for demonstrating the need of performing proper
	 * output encoding, escaping and quoting. All references are used as example for
	 * demonstration only.They are neither for endorsement nor recommendation.
	 *
	 * One should decide to use existing Security API
	 * (e.g., OWASP Enterprise Security API (ESAPI) 2.0), or customized API, or
	 * customized functions for the same purpose.
	 *
	 * This test case used two functions for the purpose of protecting against XSS.
	 *   - isValudateInput - uses whitelist method to check the user input (example only)
	 *   - htmlEntityEncode - does the html encode (sourced by OWASP:
	 *              http://www.owasp.org/index.php/How_to_perform_HTML_entity_encoding_in_Java)
	 *
	 */
	private static final boolean isValidateInput (String uInput) {

		/*
		 * used as example with the whitelist to only allow alphnumeric, space and "'" as
		 * character set for name.  The length of the user input is also registrted within 100
		 *
		 */

		if (uInput == null)
			return false;

		if (uInput.matches ("[a-zA-Z0-9' ]*") && (uInput.length() <= 100))
			return true;
		else
			return false;
	}

    // From OWASP: Return StringBuilder and/or make Writer param and write to stream directly
    public static String htmlEntityEncode( String s )
        {
                int len = s.length();
                StringBuilder buf = new StringBuilder(len);

                for ( int i = 0; i < len; i++ )
                {
                        char c = s.charAt( i );
                        if ( c>='a' && c<='z' || c>='A' && c<='Z' || c>='0' && c<='9' )
                        {
                                buf.append( c );
                        }
                        else
                        {
                                buf.append("&#").append((int)c).append(";");
                        }
                }

                return buf.toString();
    }


    public String getServletInfo() {
        return "The Hello servlet says hello.(with CWE79 Reflected fixed XSS sample code).";
    }
}

0
---------------------------------
package good;
/* 
 * This software was developed at the National Institute of Standards and
 * Technology by employees of the Federal Government in the course of their
 * official duties. Pursuant to title 17 Section 105 of the United States
 * Code this software is not subject to copyright protection and is in the
 * public domain. NIST assumes no responsibility whatsoever for its use by
 * other parties, and makes no guarantees, expressed or implied, about its
 * quality, reliability, or any other characteristic.
 *
 * This reference program was developed in June 2009 as part of the Software
 * Assurance Metrics And Tool Evaluation (SAMATE) project.
 * We would appreciate acknowledgment if the software is used.
 * The SAMATE project website is: http://samate.nist.gov
 */

/*
 * This code has a Leftover Debug Code CWE-489 vulnerability.
 * http://cwe.mitre.org
 * Basically developer can debug his code by typing "-debug"
 * but here debugging code is removed.
 */


import java.io.IOException;
import java.util.logging.Logger;


public class LeftOverDebugCode_good_489
{
	public LeftOverDebugCode_good_489()
	{
		byte inputBuffer[] = new byte[ 128 ];
		try
		{
			// Read data from the standard input
			int byteCount = System.in.read( inputBuffer );

			// Check whether data has been read or not
			if( byteCount <= 0 )
			{
				return;
			}

			// Turn data into a String
			String s = new String( inputBuffer );
			s = s.substring( 0, byteCount-2 );
			
			int nbArg = byteCount - 2;
			if ( nbArg > 1 )
			{
                if ( s.contains( "-debug" ) == true )
                {
                	final Logger user = Logger.getAnonymousLogger();
        			user.warning( "Debugging code is removed here" );
                }
			}
		}
		catch ( IOException e )
		{
			final Logger logger = Logger.getAnonymousLogger();
			String exception = "Exception " + e;
			logger.warning( exception );
		}
	}

	
	public static void main( String[] argv )
	{
		new LeftOverDebugCode_good_489();
	}
}

//end of LeftOverDebugCode_good_489.java
0
---------------------------------
package goodCodeComplexity;
/* 
 * This software was developed at the National Institute of Standards and
 * Technology by employees of the Federal Government in the course of their
 * official duties. Pursuant to title 17 Section 105 of the United States
 * Code this software is not subject to copyright protection and is in the
 * public domain. NIST assumes no responsibility whatsoever for its use by
 * other parties, and makes no guarantees, expressed or implied, about its
 * quality, reliability, or any other characteristic.
 *
 * This reference program was developed in June 2009 as part of the Software
 * Assurance Metrics And Tool Evaluation (SAMATE) project.
 * We would appreciate acknowledgment if the software is used.
 * The SAMATE project website is: http://samate.nist.gov
 */

/*
 * This code has a Resource Injection CWE-99 vulnerability with a container
 * complexity. http://cwe.mitre.org
 * It creates a file with the data read after filtering, which would allow, for
 * instance "admin.dat"!
 */


import java.io.*;
import java.util.logging.Logger;

public class ResourceInjection_good_container_099
{
	// Table of allowed files to use
	final String allowed_tab[] = { "users_site.dat", "users_reg.dat", 
			"users_info.dat", "admin.dat", "services.dat.cxx"};
	 
	// Function to check if the current file takes part of the allowed ones
	public boolean allowed( String in )
	{
		boolean bool = false;
		
        for( int i = 0; i < 5; i++ )
        {
            if( in.equals( allowed_tab[i] ) )
            {
            	// the current file is allowed to use
                bool = true;
                break;
            }
        }
        return bool;
	}
	
	public ResourceInjection_good_container_099()
	{
		byte inputBuffer[] = new byte[ 128 ];
		
		// Data to write
		byte data[] = { 1,0,1,1,1,1,1,1,0,0,0,0 };

		try
		{
			// Read data from the standard input
			int byteCount = System.in.read( inputBuffer );
			
			// Check whether data has been read or not
			if( byteCount <= 0 )
			{
				return;
			}
	
			// Turn data into a String
			String s = new String( inputBuffer );
			String s_container[] = new String[ 1 ];
			s_container[ 0 ] = s.substring( 0, byteCount-2 );
			
			if( allowed( s_container[ 0 ] ) == true )
	        {
				// The current file is allowed to use so we can create 
				// a FileOutputStream from it
                FileOutputStream f = new FileOutputStream( s_container[ 0 ] );

                try
                {
					// Try to write data in the file
					f.write( data );
				}
				catch( IOException e )
				{
					final Logger logger = Logger.getAnonymousLogger();
					String exception = "Exception " + e;
					logger.warning( exception );
				}
				f.close();
	        }
			else
				return;
		}
		catch( IOException e )
		{
			final Logger logger = Logger.getAnonymousLogger();
			String exception = "Exception " + e;
			logger.warning( exception );
		}
	}
	
	public static void main( String[] argv )
	{
		new ResourceInjection_good_container_099();
	} 
}

//end of ResourceInjection_good_container_099.java
0
---------------------------------
package goodCodeComplexity;
/* 
 * This software was developed at the National Institute of Standards and
 * Technology by employees of the Federal Government in the course of their
 * official duties. Pursuant to title 17 Section 105 of the United States
 * Code this software is not subject to copyright protection and is in the
 * public domain. NIST assumes no responsibility whatsoever for its use by
 * other parties, and makes no guarantees, expressed or implied, about its
 * quality, reliability, or any other characteristic.
 *
 * This reference program was developed in June 2009 as part of the Software
 * Assurance Metrics And Tool Evaluation (SAMATE) project.
 * We would appreciate acknowledgment if the software is used.
 * The SAMATE project website is: http://samate.nist.gov
 */

/*
 * This code implements an OS Command Injection CWE-78 vulnerability, with a
 * inter procedural scope complexity. http://cwe.mitre.org
 * It tries to execute a system command which is read in the inputBuffer
 * and checked for a valid operating system command.
 */


import java.io.*;
import java.util.logging.Logger;

public class OSCommandInjection_good_scope_078
{
	public ProcessBuilder function( String command ) throws IOException
	{
		ProcessBuilder p = new ProcessBuilder( command );
		
		// The function start checks that the command is
		// a valid operating system command
		p.start();
		
		return p;
	}
	
	public OSCommandInjection_good_scope_078()
	{
		byte inputBuffer[] = new byte[ 128 ];
		try
		{
			// Read data from the standard input
			int byteCount = System.in.read( inputBuffer );

			// Check whether data has been read or not
			if( byteCount <= 0 )
			{
				return;
			}

			// Turn data into a String and build a process
			String command = new String( inputBuffer );
			command = command.substring( 0, byteCount-2 );
			function( command );
		}
		catch( IOException e )
		{
			final Logger logger = Logger.getAnonymousLogger();
			String exception = "Exception " + e;
			logger.warning( exception );
		}
	}
	
	public static void main( String[] argv )
	{
		new OSCommandInjection_good_scope_078();
	}
}

// end of OSCommandInjection_good_scope_078.java
0
---------------------------------
package goodCodeComplexity;
/* 
 * This software was developed at the National Institute of Standards and
 * Technology by employees of the Federal Government in the course of their
 * official duties. Pursuant to title 17 Section 105 of the United States
 * Code this software is not subject to copyright protection and is in the
 * public domain. NIST assumes no responsibility whatsoever for its use by
 * other parties, and makes no guarantees, expressed or implied, about its
 * quality, reliability, or any other characteristic.
 *
 * This reference program was developed in June 2009 as part of the Software
 * Assurance Metrics And Tool Evaluation (SAMATE) project.
 * We would appreciate acknowledgment if the software is used.
 * The SAMATE project website is: http://samate.nist.gov
 */

/*
 * This code has a Hard-Coded Incoming Password CWE-259 vulnerability, and a
 * Local Control Flow complexity. http://cwe.mitre.org
 * The password to know if the user is authorized to do high-level work 
 * is verified by checking the matching with the username.
 */


import java.io.IOException;
import java.util.logging.Logger;

public class HardCodedPassword_good_LocalControlFlow_259
{
	public HardCodedPassword_good_LocalControlFlow_259()
	{
		byte inputBuffer[] = new byte[ 128 ];
		try
		{
			// Read data from the standard input of this form:
			// "username password" separate by a space
			int byteCount = System.in.read( inputBuffer );

			// Check whether data has been read or not
			if( byteCount <= 0 )
			{
				return;
			}

			int i = 1;
			switch ( i )
			{
				case 1:
					// Turn data into a String
					String s = new String( inputBuffer );
					s = s.substring( 0, byteCount-2 );
					String[] tab = s.split(" ");
					
					if ( tab.length > 1 )
					{
						// Check if the username and userpass match to grant access
						if (user_ok(tab[0], tab[1]) == true )
							highlevel_authorized( s );
					}
			
				default:
					break;
			}
		}
		catch ( IOException e )
		{
			final Logger logger = Logger.getAnonymousLogger();
			String exception = "Exception " + e;
			logger.warning( exception );
		}
	}
	
	String getUserPassword( String username )
	{
        String pass = null;
        // get the system password or do a query etc.
        return pass;
	}
	 
	boolean user_ok( String username, String userpass )
	{
		// Check if username and userpass match together
	    if ( userpass.equals(getUserPassword(username)) )
	       	return true;
	    else
	       	return false;
	}
	
	static int highlevel_authorized( String parm )
	{
	    // This user is authorized to do high level work
	    return 1;
	}
	
	public static void main( String[] argv )
	{
		new HardCodedPassword_good_LocalControlFlow_259();
	}
}

//end of HardCodedPassword_good_LocalControlFlow_259.java
0
---------------------------------
package goodCodeComplexity;
/* 
 * This software was developed at the National Institute of Standards and
 * Technology by employees of the Federal Government in the course of their
 * official duties. Pursuant to title 17 Section 105 of the United States
 * Code this software is not subject to copyright protection and is in the
 * public domain. NIST assumes no responsibility whatsoever for its use by
 * other parties, and makes no guarantees, expressed or implied, about its
 * quality, reliability, or any other characteristic.
 *
 * This reference program was developed in June 2009 as part of the Software
 * Assurance Metrics And Tool Evaluation (SAMATE) project.
 * We would appreciate acknowledgment if the software is used.
 * The SAMATE project website is: http://samate.nist.gov
 */

/*
 * This code has a NULL Pointer Dereference CWE-476 vulnerability, with a
 * inter procedural scope complexity. http://cwe.mitre.org
 * Here we try to get the system property from a specified key and
 * then remove whitespace. If the key is unknown, cmd is null and the
 * NULL dereference exception is caught.
 */


import java.util.logging.Logger;

public class NullPointerDereference_good_scope_476
{
	public String function( String cmd )
	{
		cmd = cmd.trim();
		// Returns the string, with leading and trailing whitespace omitted

		return cmd;
	}
	
	public NullPointerDereference_good_scope_476()
	{
		try
		{
			// Gets the system property indicated by the specified key
			String cmd = System.getProperty( "java.class.path" );
			
			if ( cmd != null )
			{
				cmd = function( cmd );
			}
		}
		catch ( SecurityException re )
		{
			final Logger logger = Logger.getAnonymousLogger();
			String exception = "Exception " + re;
			logger.warning( exception );
		}
	}
	
	public static void main( String[] argv )
	{
		new NullPointerDereference_good_scope_476();
	}
}

// end of NullPointerDereference_good_scope_476.java
0
---------------------------------
package goodCodeComplexity;
/* 
 * This software was developed at the National Institute of Standards and
 * Technology by employees of the Federal Government in the course of their
 * official duties. Pursuant to title 17 Section 105 of the United States
 * Code this software is not subject to copyright protection and is in the
 * public domain. NIST assumes no responsibility whatsoever for its use by
 * other parties, and makes no guarantees, expressed or implied, about its
 * quality, reliability, or any other characteristic.
 *
 * This reference program was developed in June 2009 as part of the Software
 * Assurance Metrics And Tool Evaluation (SAMATE) project.
 * We would appreciate acknowledgment if the software is used.
 * The SAMATE project website is: http://samate.nist.gov
 */

/*
 * This code has a Hard-Coded Incoming Password CWE-259 vulnerability, and a
 * container complexity. http://cwe.mitre.org
 * The password to know if the user is authorized to do high-level work 
 * is verified by checking the matching with the username.
 */


import java.io.IOException;
import java.util.logging.Logger;

public class HardCodedPassword_good_container_259
{
	public HardCodedPassword_good_container_259()
	{
		byte inputBuffer[] = new byte[ 128 ];
		try
		{
			// Read data from the standard input of this form:
			// "username password" separate by a space
			int byteCount = System.in.read( inputBuffer );

			// Check whether data has been read or not
			if( byteCount <= 0 )
			{
				return;
			}

			// Turn data into a String
			String s_container[] = new String [ 1 ];
		    s_container[ 0 ] = new String( inputBuffer );
		    s_container[ 0 ] = s_container[ 0 ].substring( 0, byteCount-2 );
			String[] tab = s_container[ 0 ].split(" ");
			
			if ( tab.length > 1 )
			{
				// Check if the username and userpass match to grant access
				if (user_ok(tab[0], tab[1]) == true )
					highlevel_authorized( s_container[ 0 ] );
			}
		}
		catch ( IOException e )
		{
			final Logger logger = Logger.getAnonymousLogger();
			String exception = "Exception " + e;
			logger.warning( exception );
		}
	}
	
	String getUserPassword( String username )
	{
        String pass = null;
        // get the system password or do a query etc.
        return pass;
	}
	 
	boolean user_ok( String username, String userpass )
	{
		// Check if username and userpass match together
	    if ( userpass.equals(getUserPassword(username)) )
	       	return true;
	    else
	       	return false;
	}
	
	static int highlevel_authorized( String parm )
	{
	    // This user is authorized to do high level work
	    return 1;
	}
	
	public static void main( String[] argv )
	{
		new HardCodedPassword_good_container_259();
	}
}

//end of HardCodedPassword_good_container_259.java
0
---------------------------------
package servlets;
/*
 * This software was developed at the National Institute of Standards and
 * Technology by employees of the Federal Government in the course of their
 * official duties. Pursuant to title 17 Section 105 of the United States
 * Code this software is not subject to copyright protection and is in the
 * public domain. NIST assumes no responsibility whatsoever for its use by
 * other parties, and makes no guarantees, expressed or implied, about its
 * quality, reliability, or any other characteristic.
 *
 * This reference program was developed in Jan 2010 as part of the Software
 * Assurance Metrics And Tool Evaluation (SAMATE) project.
 * We would appreciate acknowledgment if the software is used.
 * The SAMATE project website is: http://samate.nist.gov
 */

/*
 * This code (java servlet) has a FIX to Failure to Preserve Web Page
 * Structure 'Cross-site Scripting (XSS)' CWE-79 vulnerability.
 * http://cwe.mitre.org
 *
 * This code demos the Reflected XSS (or Non-Persistent) ==> "Container Good Case".
 * The servlet reads the user input from the HTTP request and
 * reflects it back into the HTTP response after performing the
 * validate, filter, escape and encode of that user input data.
 *
 */

import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class cwe79_reflectedXSS_good_container extends HttpServlet {

    public void doGet(
        HttpServletRequest request,
        HttpServletResponse response) throws ServletException, IOException {

        response.setContentType("text/html");

        PrintWriter out = response.getWriter();

        out.println("<html>" + "<head><title>CWE79 Reflected XSS (Container) Good</title></head>");

        out.println(
                "<body  bgcolor=\"#ffffff\">"
                + "<h4>Hello, my name is Test4XSS. What's yours?</h4>"
                + "<form method=\"get\">"
                + "<input type=\"text\" name=\"username\" size=\"50\">"
                + "<p></p>" + "<input type=\"submit\" value=\"Submit\">"
                + "<input type=\"reset\" value=\"Reset\">" + "</form>");


        String container_username[] = new String[1];
		container_username[0] = request.getParameter( "username" );	/* container */

	 	if ((container_username[0] !=null) && (container_username[0].length() > 0)) {
			if (isValidateInput(container_username[0])) {
				String cleanedUsername = htmlEntityEncode (container_username[0]);
				if ((cleanedUsername != null) && (cleanedUsername.length() > 0)) {
					out.println ("<h4>Hello, ");
					out.println (cleanedUsername);	/* OK - user input is being validated and encoded */
					out.println ("!</h4>");
	   			}
			}
			else if (container_username[0] != null) {
				out.println ("<h4>Sorry, your input is invalid</h4>");
			}
		}

        out.println("</body></html>");
        out.close();
    }

	/*
	 * To prevent XSS, assume all input is malicious. This function is just
	 * an example and placeholder for demonstrating the need of performing proper
	 * output encoding, escaping and quoting. All references are used as example for
	 * demonstration only.They are neither for endorsement nor recommendation.
	 *
	 * One should decide to use existing Security API
	 * (e.g., OWASP Enterprise Security API (ESAPI) 2.0), or customized API, or
	 * customized functions for the same purpose.
	 *
	 * This test case used two functions for the purpose of protecting against XSS.
	 *   - isValudateInput - uses whitelist method to check the user input (example only)
	 *   - htmlEntityEncode - does the html encode (sourced by OWASP:
	 *              http://www.owasp.org/index.php/How_to_perform_HTML_entity_encoding_in_Java)
	 *
	 */
	private static final boolean isValidateInput (String uInput) {

		/*
		 * used as example with the whitelist to only allow alphnumeric, space and "'" as
		 * character set for name.  The length of the user input is also registrted within 100
		 *
		 */

		if (uInput == null)
			return false;

		if (uInput.matches ("[a-zA-Z0-9' ]*") && (uInput.length() <= 100))
			return true;
		else
			return false;
	}

    // From OWASP: Return StringBuilder and/or make Writer param and write to stream directly
    public static String htmlEntityEncode( String s )
        {
                int len = s.length();
                StringBuilder buf = new StringBuilder(len);

                for ( int i = 0; i < len; i++ )
                {
                        char c = s.charAt( i );
                        if ( c>='a' && c<='z' || c>='A' && c<='Z' || c>='0' && c<='9' )
                        {
                                buf.append( c );
                        }
                        else
                        {
                                buf.append("&#").append((int)c).append(";");
                        }
                }

                return buf.toString();
    }

    public String getServletInfo() {
        return "The Hello servlet says hello.(with CWE79 Reflected fixed XSS (Container) sample code).";
    }
}

0
---------------------------------
package goodCodeComplexity;
/* 
 * This software was developed at the National Institute of Standards and
 * Technology by employees of the Federal Government in the course of their
 * official duties. Pursuant to title 17 Section 105 of the United States
 * Code this software is not subject to copyright protection and is in the
 * public domain. NIST assumes no responsibility whatsoever for its use by
 * other parties, and makes no guarantees, expressed or implied, about its
 * quality, reliability, or any other characteristic.
 *
 * This reference program was developed in June 2009 as part of the Software
 * Assurance Metrics And Tool Evaluation (SAMATE) project.
 * We would appreciate acknowledgment if the software is used.
 * The SAMATE project website is: http://samate.nist.gov
 */

/*
 * This code has a Hard-Coded Incoming Password CWE-259 vulnerability, and an
 * Array Index complexity. http://cwe.mitre.org
 * The password to know if the user is authorized to do high-level work 
 * is verified by checking the matching with the username.
 */


import java.io.IOException;
import java.util.logging.Logger;

public class HardCodedPassword_good_ArrayIndex_259
{
	public HardCodedPassword_good_ArrayIndex_259()
	{
		byte array_buffer[][] = new byte[ 1 ][ ];
		array_buffer[ 0 ] = new byte[ 128 ];
		
		try
		{
			// Read data from the standard input of this form:
			// "username password" separate by a space
			int byteCount = System.in.read( array_buffer[ 0 ] );

			// Check whether data has been read or not
			if( byteCount <= 0 )
			{
				return;
			}

			// Turn data into a String
			String s = new String( array_buffer[ 0 ] );
			s = s.substring( 0, byteCount-2 );
			String[] tab = s.split(" ");
			
			if ( tab.length > 1 )
			{
				// Check if the username and userpass match to grant access
				if (user_ok(tab[0], tab[1]) == true )
					highlevel_authorized( s );
			}
		}
		catch ( IOException e )
		{
			final Logger logger = Logger.getAnonymousLogger();
			String exception = "Exception " + e;
			logger.warning( exception );
		}
	}
	
	String getUserPassword( String username )
	{
        String pass = null;
        // get the system password or do a query etc.
        return pass;
	}
	 
	boolean user_ok( String username, String userpass )
	{
		// Check if username and userpass match together
	    if ( userpass.equals(getUserPassword(username)) )
	       	return true;
	    else
	       	return false;
	}
	
	static int highlevel_authorized( String parm )
	{
	    // This user is authorized to do high level work
	    return 1;
	}
	
	public static void main( String[] argv )
	{
		new HardCodedPassword_good_ArrayIndex_259();
	}
}

//end of HardCodedPassword_good_ArrayIndex_259.java
0
---------------------------------
package goodCodeComplexity;
/* 
 * This software was developed at the National Institute of Standards and
 * Technology by employees of the Federal Government in the course of their
 * official duties. Pursuant to title 17 Section 105 of the United States
 * Code this software is not subject to copyright protection and is in the
 * public domain. NIST assumes no responsibility whatsoever for its use by
 * other parties, and makes no guarantees, expressed or implied, about its
 * quality, reliability, or any other characteristic.
 *
 * This reference program was developed in June 2009 as part of the Software
 * Assurance Metrics And Tool Evaluation (SAMATE) project.
 * We would appreciate acknowledgment if the software is used.
 * The SAMATE project website is: http://samate.nist.gov
 */

/*
 * This code has a Hard-Coded Incoming Password CWE-259 vulnerability, and a
 * Loop Structure complexity. http://cwe.mitre.org
 * The password to know if the user is authorized to do high-level work 
 * is verified by checking the matching with the username.
 */


import java.io.IOException;
import java.util.logging.Logger;

public class HardCodedPassword_good_LoopStructure_259
{
	public HardCodedPassword_good_LoopStructure_259()
	{
		for ( int i = 0; i < 3; i++ )
		{
		
			byte inputBuffer[] = new byte[ 128 ];
			try
			{
				// Read data from the standard input of this form:
				// "username password" separate by a space
				int byteCount = System.in.read( inputBuffer );
	
				// Check whether data has been read or not
				if( byteCount <= 0 )
				{
					return;
				}
	
				// Turn data into a String
				String s = new String( inputBuffer );
				s = s.substring( 0, byteCount-2 );
				String[] tab = s.split(" ");
				
				if ( tab.length > 1 )
				{
					// Check if the username and userpass match to grant access
					if (user_ok(tab[0], tab[1]) == true )
					{
						highlevel_authorized( s );
						break;
					}
				}
			}
			catch ( IOException e )
			{
				final Logger logger = Logger.getAnonymousLogger();
				String exception = "Exception " + e;
				logger.warning( exception );
			}
		}
	}
	
	String getUserPassword( String username )
	{
        String pass = null;
        // get the system password or do a query etc.
        return pass;
	}
	 
	boolean user_ok( String username, String userpass )
	{
		// Check if username and userpass match together
	    if ( userpass.equals(getUserPassword(username)) )
	       	return true;
	    else
	       	return false;
	}
	
	static int highlevel_authorized( String parm )
	{
	    // This user is authorized to do high level work
	    return 1;
	}
	
	public static void main( String[] argv )
	{
		new HardCodedPassword_good_LoopStructure_259();
	}
}

//end of HardCodedPassword_good_LoopStructure_259.java
0
---------------------------------
package goodCodeComplexity;
/* 
 * This software was developed at the National Institute of Standards and
 * Technology by employees of the Federal Government in the course of their
 * official duties. Pursuant to title 17 Section 105 of the United States
 * Code this software is not subject to copyright protection and is in the
 * public domain. NIST assumes no responsibility whatsoever for its use by
 * other parties, and makes no guarantees, expressed or implied, about its
 * quality, reliability, or any other characteristic.
 *
 * This reference program was developed in June 2009 as part of the Software
 * Assurance Metrics And Tool Evaluation (SAMATE) project.
 * We would appreciate acknowledgment if the software is used.
 * The SAMATE project website is: http://samate.nist.gov
 */

/*
 * This code has a NULL Pointer Dereference CWE-476 vulnerability, with a
 * Local Control Flow complexity (switch). http://cwe.mitre.org
 * Here we try to get the system property from a specified key and
 * then remove whitespace. If the key is unknown, cmd is null and the
 * NULL dereference exception is caught.
 */


import java.util.logging.Logger;

public class NullPointerDereference_good_LocalControlFlow_476
{
	public static void main( String[] argv )
	{
		try
		{
			int i = 1;
			switch ( i )
			{
				case 1:
					// Gets the system property indicated by the specified key
					String cmd = System.getProperty( "java.class.path" );
					
					if ( cmd != null )
					{
						// Returns the string, with leading and trailing whitespace omitted
						cmd = cmd.trim();
					}
				default:
					break;
			}
		}
		catch ( SecurityException re )
		{
			final Logger logger = Logger.getAnonymousLogger();
			String exception = "Exception " + re;
			logger.warning( exception );
		}
	}
}

// end of NullPointerDereference_good_LocalControlFlow_476.java
0
---------------------------------
package good;
/* 
 * This software was developed at the National Institute of Standards and
 * Technology by employees of the Federal Government in the course of their
 * official duties. Pursuant to title 17 Section 105 of the United States
 * Code this software is not subject to copyright protection and is in the
 * public domain. NIST assumes no responsibility whatsoever for its use by
 * other parties, and makes no guarantees, expressed or implied, about its
 * quality, reliability, or any other characteristic.
 *
 * This reference program was developed in June 2009 as part of the Software
 * Assurance Metrics And Tool Evaluation (SAMATE) project.
 * We would appreciate acknowledgment if the software is used.
 * The SAMATE project website is: http://samate.nist.gov
 */

/*
 * This code implements an OS Command Injection CWE-78 vulnerability.
 * http://cwe.mitre.org
 * It tries to execute a system command which is read in the inputBuffer
 * and checked for a valid operating system command.
 */


import java.io.*;
import java.util.logging.Logger;

public class OSCommandInjection_good_078
{
	public OSCommandInjection_good_078()
	{
		byte inputBuffer[] = new byte[ 128 ];
		try
		{
			// Read data from the standard input
			int byteCount = System.in.read( inputBuffer );

			// Check whether data has been read or not
			if( byteCount <= 0 )
			{
				return;
			}

			// Turn data into a String and build a process
			String command = new String( inputBuffer );
			command = command.substring( 0, byteCount-2 );
			ProcessBuilder p = new ProcessBuilder( command );
			
			// The function start checks that the command is
			// a valid operating system command
			p.start();
		}
		catch( IOException e )
		{
			final Logger logger = Logger.getAnonymousLogger();
			String exception = "Exception " + e;
			logger.warning( exception );
		}
	}
	
	public static void main( String[] argv )
	{
		new OSCommandInjection_good_078();
	}
}

// end of OSCommandInjection_good_078.java
0
---------------------------------
package goodCodeComplexity;
/* 
 * This software was developed at the National Institute of Standards and
 * Technology by employees of the Federal Government in the course of their
 * official duties. Pursuant to title 17 Section 105 of the United States
 * Code this software is not subject to copyright protection and is in the
 * public domain. NIST assumes no responsibility whatsoever for its use by
 * other parties, and makes no guarantees, expressed or implied, about its
 * quality, reliability, or any other characteristic.
 *
 * This reference program was developed in June 2009 as part of the Software
 * Assurance Metrics And Tool Evaluation (SAMATE) project.
 * We would appreciate acknowledgment if the software is used.
 * The SAMATE project website is: http://samate.nist.gov
 */

/*
 * This code has a NULL Pointer Dereference CWE-476 vulnerability, with an
 * Address Alias Level complexity. http://cwe.mitre.org
 * Here we try to get the system property from a specified key and
 * then remove whitespace. If the key is unknown, cmd is null and the
 * NULL dereference exception is caught.
 */


import java.util.logging.Logger;


public class NullPointerDereference_good_AdressAliasLevel_476
{
	public static void main( String[] argv )
	{
		try
		{
			// Gets the system property indicated by the specified key
			String alias_cmd[] = new String[ 1 ];
			alias_cmd[ 0 ] = System.getProperty( "java.class.path" );
			
			if ( alias_cmd[ 0 ] != null )
			{
				// Returns the string, with leading and trailing whitespace omitted
				alias_cmd[ 0 ] = alias_cmd[ 0 ].trim();
			}
		}
		catch ( SecurityException re )
		{
			final Logger logger = Logger.getAnonymousLogger();
			String exception = "Exception " + re;
			logger.warning( exception );
		}
	}
}

// end of NullPointerDereference_good_AdressAliasLevel_476.java
0
---------------------------------
package good;
/* 
 * This software was developed at the National Institute of Standards and
 * Technology by employees of the Federal Government in the course of their
 * official duties. Pursuant to title 17 Section 105 of the United States
 * Code this software is not subject to copyright protection and is in the
 * public domain. NIST assumes no responsibility whatsoever for its use by
 * other parties, and makes no guarantees, expressed or implied, about its
 * quality, reliability, or any other characteristic.
 *
 * This reference program was developed in June 2009 as part of the Software
 * Assurance Metrics And Tool Evaluation (SAMATE) project.
 * We would appreciate acknowledgment if the software is used.
 * The SAMATE project website is: http://samate.nist.gov
 */

/*
 * This code has a Hard-Coded Incoming Password CWE-259 vulnerability.
 * http://cwe.mitre.org
 * The password to know if the user is authorized to do high-level work 
 * is verified by checking the matching with the username.
 */


import java.io.IOException;
import java.util.logging.Logger;

public class HardCodedPassword_good_259
{
	public HardCodedPassword_good_259()
	{
		byte inputBuffer[] = new byte[ 128 ];
		try
		{
			// Read data from the standard input of this form:
			// "username password" separate by a space
			int byteCount = System.in.read( inputBuffer );

			// Check whether data has been read or not
			if( byteCount <= 0 )
			{
				return;
			}

			// Turn data into a String
			String s = new String( inputBuffer );
			s = s.substring( 0, byteCount-2 );
			String[] tab = s.split(" ");
			
			if ( tab.length > 1 )
			{
				// Check if the username and userpass match to grant access
				if (user_ok(tab[0], tab[1]) == true )
					highlevel_authorized( s );
			}
		}
		catch ( IOException e )
		{
			final Logger logger = Logger.getAnonymousLogger();
			String exception = "Exception " + e;
			logger.warning( exception );
		}
	}
	
	String getUserPassword( String username )
	{
	    String pass = null;
	    // get the system password or do a query etc.
	    return pass;
	}
	 
	boolean user_ok( String username, String userpass )
	{
		// Check if username and userpass match together
	    if ( userpass.equals(getUserPassword(username)) )
	       	return true;
	    else
	       	return false;
	}
	
	static int highlevel_authorized( String parm )
	{
	    // This user is authorized to do high level work
	    return 1;
	}
	
	public static void main( String[] argv )
	{
		new HardCodedPassword_good_259();
	}
}

//end of HardCodedPassword_good_259.java
0
---------------------------------
package goodCodeComplexity;
/* This software was developed at the National Institute of Standards and
 * Technology by employees of the Federal Government in the course of their
 * official duties. Pursuant to title 17 Section 105 of the United States
 * Code this software is not subject to copyright protection and is in the
 * public domain. NIST assumes no responsibility whatsoever for its use by
 * other parties, and makes no guarantees, expressed or implied, about its
 * quality, reliability, or any other characteristic.
 * We would appreciate acknowledgement if the software is used.
 * The SAMATE project website is: http://samate.nist.gov
 */

/*
 * This servlet implements an SQL injection vulnerability
 * Parameters:
 *   - name: source of the vulnerability
 * Example:
 *   - url: http://server_address/path_to_servlet/SQLInjection_089?name=' OR ''='
 */

import java.io.IOException;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import javax.naming.Context;
import javax.naming.InitialContext;
import javax.naming.NamingException;
import javax.servlet.ServletException;
import javax.servlet.ServletOutputStream;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.sql.DataSource;

public class SQLInjection_good_ArrayIndex_089 extends HttpServlet
{
	private static final long serialVersionUID = 1L;
      
    public SQLInjection_good_ArrayIndex_089()
    {
        super();
    }
	
	// Table of allowed names to use
	final String allowed_names[] = { "Mickael", "Mary", 
			"Peter", "Laura", "John"};
	 
	// Function to check if the current name takes part of the allowed ones
	public boolean allowed( String in )
	{
		boolean bool = false;
		
        for( int i = 0; i < 5; i++ )
        {
            if( in.equals( allowed_names[i] ) )
            {
              	// the current name is allowed to use
                bool = true;
                break;
            }
        }
        return bool;
	}

    // Method which will be called to handle HTTP GET requests
	protected void doGet( HttpServletRequest req, HttpServletResponse resp )
		throws ServletException, IOException
	{
		// Initialize the output stream
		resp.setContentType("text/html");
		ServletOutputStream out = resp.getOutputStream();
		out.println("<HTML><BODY><blockquote><pre>");
		Connection conn = null;
				
		// Get the parameter "name" from the data provided by the user
		String name = req.getParameter( "name" );
		
		if ( (name != null) && (allowed(name) == true) )
		{
			try
		    {
				// Set the context factory to use to create the initial context
				System.setProperty (Context.INITIAL_CONTEXT_FACTORY, "your.ContextFactory");

				// Create the initial context and use it to lookup the data source
				InitialContext ic = new InitialContext ();
				DataSource dataSrc = (DataSource) ic.lookup ("java:comp/env/jdbc:/mydb");

				// Create a connection to the SQL database from the data source
				conn = dataSrc.getConnection();
				
				String array_buffer[][] = new String[ 1 ][ ];
				array_buffer[ 0 ] = new String[ 128 ];
				array_buffer[ 0 ][ 128 ] = name;
				
				// Send a SQL request to the database
				PreparedStatement ps = conn.prepareStatement( "SELECT * FROM users WHERE firstname LIKE ?" );
				// replace the first parameter by name
				ps.setString(1, array_buffer[ 0 ][ 128 ]);
				ps.executeQuery();
		    }
		    catch( NamingException e )
		    {
		    	out.println( "Naming exception");
			}
		    catch( SQLException e )
		    {
		    	out.println( "SQL exception");
		    }
		    finally
		    {
		    	try
		    	{
		    		if (conn != null)
		    			conn.close ();
		    	}
		    	catch (SQLException se)
		    	{
		    		out.println("SQL Exception");
		    	}
		    }
		}
		else
			return;
		
		out.println( "</pre></blockquote></body></html>" );
	}

	protected void doPost(HttpServletRequest request, HttpServletResponse response)
		throws ServletException, IOException
	{
	}
}

0
---------------------------------
package good;
/* This software was developed at the National Institute of Standards and
 * Technology by employees of the Federal Government in the course of their
 * official duties. Pursuant to title 17 Section 105 of the United States
 * Code this software is not subject to copyright protection and is in the
 * public domain. NIST assumes no responsibility whatsoever for its use by
 * other parties, and makes no guarantees, expressed or implied, about its
 * quality, reliability, or any other characteristic.
 * We would appreciate acknowledgement if the software is used.
 * The SAMATE project website is: http://samate.nist.gov
 */

/*
 * This servlet implements an SQL injection vulnerability
 * Parameters:
 *   - name: source of the vulnerability
 * Example:
 *   - url: http://server_address/path_to_servlet/SQLInjection_089?name=' OR ''='
 */

import java.io.IOException;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import javax.naming.Context;
import javax.naming.InitialContext;
import javax.naming.NamingException;
import javax.servlet.ServletException;
import javax.servlet.ServletOutputStream;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.sql.DataSource;

public class SQLInjection_good_089 extends HttpServlet
{
	private static final long serialVersionUID = 1L;
	
    public SQLInjection_good_089()
    {
        super();
    }
    
	// Table of allowed names to use
	final String allowed_names[] = { "Mickael", "Mary", 
			"Peter", "Laura", "John"};
	 
	// Function to check if the current name takes part of the allowed ones
	public boolean allowed( String in )
	{
		boolean bool = false;
		
        for( int i = 0; i < 5; i++ )
        {
            if( in.equals( allowed_names[i] ) )
            {
              	// the current name is allowed to use
                bool = true;
                break;
            }
        }
        return bool;
	}

    // Method which will be called to handle HTTP GET requests
	protected void doGet( HttpServletRequest req, HttpServletResponse resp )
		throws ServletException, IOException
	{
		// Initialize the output stream
		resp.setContentType("text/html");
		ServletOutputStream out = resp.getOutputStream();
		out.println("<HTML><BODY><blockquote><pre>");
		Connection conn = null;
		
		// Get the parameter "name" from the data provided by the user
		String name = req.getParameter( "name" );
		
		if ( (name != null) && (allowed(name) == true) )
		{
			try
		    {
				// Set the context factory to use to create the initial context
				System.setProperty (Context.INITIAL_CONTEXT_FACTORY, "your.ContextFactory");

				// Create the initial context and use it to lookup the data source
				InitialContext ic = new InitialContext ();
				DataSource dataSrc = (DataSource) ic.lookup ("java:comp/env/jdbc:/mydb");

				// Create a connection to the SQL database from the data source
				conn = dataSrc.getConnection();
					
				// Send a SQL request to the database
				PreparedStatement ps = conn.prepareStatement( "SELECT * FROM users WHERE firstname LIKE ?" );
				// replace the first parameter by name
				ps.setString(1, name);
				ps.executeQuery();
			}
			catch( NamingException e )
		    {
		    	out.println( "Naming exception");
			}
		    catch( SQLException e )
		    {
		    	out.println( "SQL exception");
		    }
		    finally
		    {
		    	try
		    	{
		    		if (conn != null)
		    			conn.close ();
		    	}
		    	catch (SQLException se)
		    	{
		    		out.println("SQL Exception");
		    	}
		    }
		}
		else
			return;
	
		out.println( "</pre></blockquote></body></html>" );
	}

	protected void doPost(HttpServletRequest request, HttpServletResponse response)
		throws ServletException, IOException
	{
	}
}

0
---------------------------------
package goodCodeComplexity;
/* 
 * This software was developed at the National Institute of Standards and
 * Technology by employees of the Federal Government in the course of their
 * official duties. Pursuant to title 17 Section 105 of the United States
 * Code this software is not subject to copyright protection and is in the
 * public domain. NIST assumes no responsibility whatsoever for its use by
 * other parties, and makes no guarantees, expressed or implied, about its
 * quality, reliability, or any other characteristic.
 *
 * This reference program was developed in June 2009 as part of the Software
 * Assurance Metrics And Tool Evaluation (SAMATE) project.
 * We would appreciate acknowledgment if the software is used.
 * The SAMATE project website is: http://samate.nist.gov
 */

/*
 * This code implements an OS Command Injection CWE-78 vulnerability, with a
 * Local Control Flow complexity (switch). http://cwe.mitre.org
 * It tries to execute a system command which is read in the inputBuffer
 * and checked for a valid operating system command.
 */


import java.io.*;
import java.util.logging.Logger;

public class OSCommandInjection_good_LocalControlFlow_078
{
	public OSCommandInjection_good_LocalControlFlow_078()
	{
		byte inputBuffer[] = new byte[ 128 ];
		try
		{
			// Read data from the standard input
			int byteCount = System.in.read( inputBuffer );

			// Check whether data has been read or not
			if( byteCount <= 0 )
			{
				return;
			}

			int i = 1;
			switch ( i )
			{
				case 1:
					// Turn data into a String and build a process
					String command = new String( inputBuffer );
					command = command.substring( 0, byteCount-2 );
					ProcessBuilder p = new ProcessBuilder( command );
					
					// The function start checks that the command is
					// a valid operating system command
					p.start();
					
				default:
					break;
			}
		}
		catch( IOException e )
		{
			final Logger logger = Logger.getAnonymousLogger();
			String exception = "Exception " + e;
			logger.warning( exception );
		}
	}
	
	public static void main( String[] argv )
	{
		new OSCommandInjection_good_LocalControlFlow_078();
	}
}

// end of OSCommandInjection_good_LocalControlFlow_078.java
0
---------------------------------
package goodCodeComplexity;
/* 
 * This software was developed at the National Institute of Standards and
 * Technology by employees of the Federal Government in the course of their
 * official duties. Pursuant to title 17 Section 105 of the United States
 * Code this software is not subject to copyright protection and is in the
 * public domain. NIST assumes no responsibility whatsoever for its use by
 * other parties, and makes no guarantees, expressed or implied, about its
 * quality, reliability, or any other characteristic.
 *
 * This reference program was developed in June 2009 as part of the Software
 * Assurance Metrics And Tool Evaluation (SAMATE) project.
 * We would appreciate acknowledgment if the software is used.
 * The SAMATE project website is: http://samate.nist.gov
 */

/*
 * This code has a Resource Injection CWE-99 vulnerability with an inter procedural
 * scope complexity. http://cwe.mitre.org
 * It creates a file with the data read after filtering, which would allow, for
 * instance "admin.dat"!
 */


import java.io.*;
import java.util.logging.Logger;

public class ResourceInjection_good_scope_099
{
	// Table of allowed files to use
	final String allowed_tab[] = { "users_site.dat", "users_reg.dat", 
			"users_info.dat", "admin.dat", "services.dat.cxx"};
	 
	// Function to check if the current file takes part of the allowed ones
	public boolean allowed( String in )
	{
		boolean bool = false;
		
        for( int i = 0; i < 5; i++ )
        {
            if( in.equals( allowed_tab[i] ) )
            {
            	// the current file is allowed to use
                bool = true;
                break;
            }
        }
        return bool;
	}
	
	public FileOutputStream function( String s ) throws FileNotFoundException
	{
		FileOutputStream f = null;
		
		// Create a file from the input argument after filtering
		f = new FileOutputStream( s );
		
		return f;
	}
	
	public ResourceInjection_good_scope_099()
	{
		byte inputBuffer[] = new byte[ 128 ];
		
		// Data to write
		byte data[] = { 1,0,1,1,1,1,1,1,0,0,0,0 };

		try
		{
			// Read data from the standard input
			int byteCount = System.in.read( inputBuffer );
			
			// Check whether data has been read or not
			if( byteCount <= 0 )
			{
				return;
			}
	
			// Turn data into a String
			String s = new String( inputBuffer );
			s = s.substring( 0, byteCount-2 );
			
			if( allowed( s ) == true )
	        {
				// The current file is allowed to use so we can create 
				// a FileOutputStream from it
				FileOutputStream f = function( s );
	        
                try
                {
					// Try to write data in the file
					f.write( data );
				}
				catch( IOException e )
				{
					final Logger logger = Logger.getAnonymousLogger();
					String exception = "Exception " + e;
					logger.warning( exception );
				}
				f.close();
	        }
			else
				return;
		}
		catch( IOException e )
		{
			final Logger logger = Logger.getAnonymousLogger();
			String exception = "Exception " + e;
			logger.warning( exception );
		}
	}
	
	public static void main( String[] argv )
	{
		new ResourceInjection_good_scope_099();
	} 
}

//end of ResourceInjection_good_scope_099.java
0
---------------------------------
package good;
/* 
 * This software was developed at the National Institute of Standards and
 * Technology by employees of the Federal Government in the course of their
 * official duties. Pursuant to title 17 Section 105 of the United States
 * Code this software is not subject to copyright protection and is in the
 * public domain. NIST assumes no responsibility whatsoever for its use by
 * other parties, and makes no guarantees, expressed or implied, about its
 * quality, reliability, or any other characteristic.
 *
 * This reference program was developed in June 2009 as part of the Software
 * Assurance Metrics And Tool Evaluation (SAMATE) project.
 * We would appreciate acknowledgment if the software is used.
 * The SAMATE project website is: http://samate.nist.gov
 */

 /*
 * This code shows an exploit of an Unchecked Error Condition CWE-391 vulnerability.
 * http://cwe.mitre.org
 * A FileInputStream such as image data is tried to be created. Exceptions and
 * other error conditions are no more ignored.
 */
 
 
import java.io.*;
import java.util.logging.Logger;


public class UncheckedErrorCondition_good_391
{
	public static FileInputStream getInput( String fileName )
	{
		FileInputStream fis = null;
	
		// Try to create an FileInputStream
		try
		{
	        fis = new FileInputStream( fileName );
		}
		
		// The program checks error condition
		catch (FileNotFoundException e)
		{
			final Logger logger = Logger.getAnonymousLogger();
			String exception = "Exception " + e;
			logger.warning( exception );
		}
		
        return fis;
    }

    public static void main( String[] argv)
	{
    	String fileName = "foo.bar";
        getInput( fileName );
    }
}

// end of UncheckedException_good_391.java
0
---------------------------------
package good;
/* 
 * This software was developed at the National Institute of Standards and
 * Technology by employees of the Federal Government in the course of their
 * official duties. Pursuant to title 17 Section 105 of the United States
 * Code this software is not subject to copyright protection and is in the
 * public domain. NIST assumes no responsibility whatsoever for its use by
 * other parties, and makes no guarantees, expressed or implied, about its
 * quality, reliability, or any other characteristic.
 *
 * This reference program was developed in June 2009 as part of the Software
 * Assurance Metrics And Tool Evaluation (SAMATE) project.
 * We would appreciate acknowledgment if the software is used.
 * The SAMATE project website is: http://samate.nist.gov
 */

/*
 * This code shows an exploit of an Unrestricted Lock on Critical Resource CWE-412
 * vulnerability. http://cwe.mitre.org
 * Suppose the file /tmp/resourceLock is used as a resource lock. This program grabs
 * the lock (if available), and later releases it.
 */


import java.io.*;
import java.util.logging.Logger;


public class UnrestrictedLockOnCriticalResource_good_412
{
	public UnrestrictedLockOnCriticalResource_good_412()
	{
		int i = 0;
		
		try
		{
			// Try to create a file, which is used as a resource lock.
			FileWriter fw = new FileWriter("/tmp/resourceLock");
			
			while ( i < 100 )
			{
				i++;
			}
			// Release the file after using it.
			fw.close();
		}
		catch (IOException e)
		{
	    	final Logger logger = Logger.getAnonymousLogger();
			String exception = "Exception " + e;
			logger.warning( exception );
	    }
	}
	
	public static void main( String[] argv )
	{
		new UnrestrictedLockOnCriticalResource_good_412();
	}
}

//end of UnrestrictedLockOnCriticalResource_good_412.java
0
---------------------------------
package servlets;
/*
 * This software was developed at the National Institute of Standards and
 * Technology by employees of the Federal Government in the course of their
 * official duties. Pursuant to title 17 Section 105 of the United States
 * Code this software is not subject to copyright protection and is in the
 * public domain. NIST assumes no responsibility whatsoever for its use by
 * other parties, and makes no guarantees, expressed or implied, about its
 * quality, reliability, or any other characteristic.
 *
 * This reference program was developed in Jan 2010 as part of the Software
 * Assurance Metrics And Tool Evaluation (SAMATE) project.
 * We would appreciate acknowledgment if the software is used.
 * The SAMATE project website is: http://samate.nist.gov
 */

/*
 * This code (java servlet) has a Failure to Preserve Web Page
 * Structure 'Cross-site Scripting (XSS)' CWE-79 CWE-259 vulnerability.
 * http://cwe.mitre.org
 *
 * This code demos the Stored XSS (or Presistent) ==> "Container Good Case".
 * The servlet retrieves the records from database and
 * reflects it back into the HTTP response after performing the
 * validate, filter, escape and encode of that retrieved data.
 */

import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.ServletException;
import javax.servlet.ServletContext;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import javax.naming.Context;
import javax.naming.InitialContext;
import javax.naming.NamingException;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import javax.sql.DataSource;

public class cwe79_storedXSS_good_container extends HttpServlet {


    public void doGet(
        HttpServletRequest request,
        HttpServletResponse response) throws ServletException, IOException {

        PrintWriter out = response.getWriter();

        out.println("<html>" + "<head><title>CWE79 Stored XSS (Container) Good</title></head>");
        out.println(
                "<body  bgcolor=\"#ffffff\">"
                + "<h4>Found the following messages:</h4>");

	   	Connection conn = null;

		try {

			// Set the context factory to use to create the initial context
			System.setProperty (Context.INITIAL_CONTEXT_FACTORY,"your.ContextFactory");

			// Create the initial context and use it to lookup the data source
			InitialContext ic = new InitialContext ();
			DataSource dataSrc = (DataSource) ic.lookup ("jdbc/TestDB");

			// Create a connection to the database from the data source
			conn = dataSrc.getConnection();

			PreparedStatement pstmt = conn.prepareStatement("select test_msg from test_msgs");
			ResultSet rs = pstmt.executeQuery();

			int count = 1;

			while ( rs.next() ) {
				String container_tmpStr[] = new String[1];
				container_tmpStr[0] = rs.getString("test_msg");	/* Container */

				if (isValidateInput(container_tmpStr[0])) {
				   	String cleanedStr = htmlEntityEncode (container_tmpStr[0]);

				   	if ((cleanedStr != null) && (cleanedStr.length() > 0)) {
					  	out.println ("msg # ");
					  	out.println (Integer.toString(count));
					  	out.println (htmlEntityEncode ("-->"));
				   		out.println (cleanedStr);   /* OK - retrieved data is being validated and encoded */
					   	out.println ("<br>");
	       			}
				   	count++;
			   	}
			}
		}
		catch( NamingException e ) {
			    out.println( "Naming exception: ");
		}
		catch (SQLException se) {
			out.println ("SQL exception occured: ");

		}
		catch (Exception e) {
			out.println ("General Exception occured: ");
		}
		finally {
			try {
					if (conn != null) {
		    			conn.close();
					}
				}
				catch (SQLException se) {
					out.println ("SQL exception occured: ");
				}
		}
		out.println("</body></html>");
        out.close();
    }

	/*
	 * To prevent XSS, assume all input is malicious. This function is just
	 * an example and placeholder for demonstrating the need of performing proper
	 * output encoding, escaping and quoting. All references are used as example for
	 * demonstration only.They are neither for endorsement nor recommendation.
	 *
	 * One should decide to use existing Security API
	 * (e.g., OWASP Enterprise Security API (ESAPI) 2.0), or customized API, or
	 * customized functions for the same purpose.
	 *
	 * This test case used two functions for the purpose of protecting against XSS.
	 *   - isValudateInput - uses whitelist method to check the user input (example only)
	 *   - htmlEntityEncode - does the html encode (sourced by OWASP:
	 *              http://www.owasp.org/index.php/How_to_perform_HTML_entity_encoding_in_Java)
	 *
	 */
	private static final boolean isValidateInput (String uInput) {

		/*
		 * used as example with the whitelist to only allow alphnumeric, space and "'" as
		 * character set for name.  The length of the user input is also registrted within 100
		 *
		 */

		if (uInput == null)
			return false;

		if (uInput.matches ("[a-zA-Z0-9' ]*") && (uInput.length() <= 100))
			return true;
		else
			return false;
	}

    // From OWASP: Return StringBuilder and/or make Writer param and write to stream directly
    public static String htmlEntityEncode( String s )
        {
                int len = s.length();
                StringBuilder buf = new StringBuilder(len);

                for ( int i = 0; i < len; i++ )
                {
                        char c = s.charAt( i );
                        if ( c>='a' && c<='z' || c>='A' && c<='Z' || c>='0' && c<='9' )
                        {
                                buf.append( c );
                        }
                        else
                        {
                                buf.append("&#").append((int)c).append(";");
                        }
                }

                return buf.toString();
    }


    public String getServletInfo() {
        return "The Hello servlet says hello (with CWE79 Stored XSS (Container) good sample code).";
    }
}

0
---------------------------------
package servlets;
/*
 * This software was developed at the National Institute of Standards and
 * Technology by employees of the Federal Government in the course of their
 * official duties. Pursuant to title 17 Section 105 of the United States
 * Code this software is not subject to copyright protection and is in the
 * public domain. NIST assumes no responsibility whatsoever for its use by
 * other parties, and makes no guarantees, expressed or implied, about its
 * quality, reliability, or any other characteristic.
 *
 * This reference program was developed in Jan 2010 as part of the Software
 * Assurance Metrics And Tool Evaluation (SAMATE) project.
 * We would appreciate acknowledgment if the software is used.
 * The SAMATE project website is: http://samate.nist.gov
 */

/*
 * This code (java servlet) has a Failure to Preserve Web Page
 * Structure 'Cross-site Scripting (XSS)' CWE-79 CWE-259 vulnerability.
 * http://cwe.mitre.org
 *
 * This code demos the Stored XSS (or Presistent) ==> "Basic Good Case".
 * The servlet retrieves the records from database and
 * reflects it back into the HTTP response after performing the
 * validate, filter, escape and encode of that retrieved data.
 */

import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.ServletException;
import javax.servlet.ServletContext;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import javax.naming.Context;
import javax.naming.InitialContext;
import javax.naming.NamingException;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import javax.sql.DataSource;

public class cwe79_storedXSS_good extends HttpServlet {

    public void doGet(
        HttpServletRequest request,
        HttpServletResponse response) throws ServletException, IOException {

        PrintWriter out = response.getWriter();

        out.println("<html>" + "<head><title>CWE79 Stored XSS Good</title></head>");
        out.println(
                "<body  bgcolor=\"#ffffff\">"
                + "<h4>Found the following messages:</h4>");

	   	Connection conn = null;

		try {

			// Set the context factory to use to create the initial context
			System.setProperty (Context.INITIAL_CONTEXT_FACTORY,"your.ContextFactory");

			// Create the initial context and use it to lookup the data source
			InitialContext ic = new InitialContext ();
			DataSource dataSrc = (DataSource) ic.lookup ("jdbc/TestDB");

			// Create a connection to the database from the data source
			conn = dataSrc.getConnection();

			PreparedStatement pstmt = conn.prepareStatement("select test_msg from test_msgs");
			ResultSet rs = pstmt.executeQuery();

			int count = 1;

			while ( rs.next() ) {
				String tmpString = rs.getString("test_msg");
				if (isValidateInput(tmpString)) {
					String cleanedStr = htmlEntityEncode (tmpString);

				   if ((cleanedStr != null) && (cleanedStr.length() > 0)) {
						out.println ("msg # ");
						out.println (Integer.toString(count));
						out.println (htmlEntityEncode ("-->"));
						out.println (cleanedStr);  /* OK - retrieved data is being validated and encoded */
						out.println ("<br>");
						count++;
					}
				}
			}
		}
		catch( NamingException e ) {
			    out.println( "Naming exception: ");
		}
		catch (SQLException se) {
			out.println ("SQL exception occured: ");

		}
		catch (Exception e) {
			out.println ("General Exception occured: ");
		}
		finally {
			try {
					if (conn != null) {
		    			conn.close();
					}
				}
				catch (SQLException se) {
					out.println ("SQL exception occured: ");
				}
		}
		out.println("</body></html>");
        out.close();
    }

	/*
	 * To prevent XSS, assume all input is malicious. This function is just
	 * an example and placeholder for demonstrating the need of performing proper
	 * output encoding, escaping and quoting. All references are used as example for
	 * demonstration only.They are neither for endorsement nor recommendation.
	 *
	 * One should decide to use existing Security API
	 * (e.g., OWASP Enterprise Security API (ESAPI) 2.0), or customized API, or
	 * customized functions for the same purpose.
	 *
	 * This test case used two functions for the purpose of protecting against XSS.
	 *   - isValudateInput - uses whitelist method to check the user input (example only)
	 *   - htmlEntityEncode - does the html encode (sourced by OWASP:
	 *              http://www.owasp.org/index.php/How_to_perform_HTML_entity_encoding_in_Java)
	 *
	 */
	private static final boolean isValidateInput (String uInput) {

		/*
		 * used as example with the whitelist to only allow alphnumeric, space and "'" as
		 * character set for name.  The length of the user input is also registrted within 100
		 *
		 */

		if (uInput == null)
			return false;

		if (uInput.matches ("[a-zA-Z0-9' ]*") && (uInput.length() <= 100))
			return true;
		else
			return false;
	}

    // From OWASP: Return StringBuilder and/or make Writer param and write to stream directly
    public static String htmlEntityEncode( String s )
        {
                int len = s.length();
                StringBuilder buf = new StringBuilder(len);

                for ( int i = 0; i < len; i++ )
                {
                        char c = s.charAt( i );
                        if ( c>='a' && c<='z' || c>='A' && c<='Z' || c>='0' && c<='9' )
                        {
                                buf.append( c );
                        }
                        else
                        {
                                buf.append("&#").append((int)c).append(";");
                        }
                }

                return buf.toString();
    }

    public String getServletInfo() {
        return "The Hello servlet says hello (with CWE79 Stored XSS good sample code).";
    }
}

0
---------------------------------
package good;
/* 
 * This software was developed at the National Institute of Standards and
 * Technology by employees of the Federal Government in the course of their
 * official duties. Pursuant to title 17 Section 105 of the United States
 * Code this software is not subject to copyright protection and is in the
 * public domain. NIST assumes no responsibility whatsoever for its use by
 * other parties, and makes no guarantees, expressed or implied, about its
 * quality, reliability, or any other characteristic.
 *
 * This reference program was developed in June 2009 as part of the Software
 * Assurance Metrics And Tool Evaluation (SAMATE) project.
 * We would appreciate acknowledgment if the software is used.
 * The SAMATE project website is: http://samate.nist.gov
 */

/*
 * This code has a NULL Pointer Dereference CWE-476 vulnerability.
 * http://cwe.mitre.org
 * Here we try to get the system property from a specified key and
 * then remove whitespace. If the key is unknown, cmd is null and the
 * NULL dereference exception is caught.
 */


import java.util.logging.Logger;

public class NullPointerDereference_good_476
{
	public static void main( String[] argv )
	{
		try
		{
			// Gets the system property indicated by the specified key
			String cmd = System.getProperty( "java.class.path" );
			
			if ( cmd != null )
			{
				// Returns the string, with leading and trailing whitespace omitted
				cmd = cmd.trim();
			}
		}
		catch ( SecurityException re )
		{
			final Logger logger = Logger.getAnonymousLogger();
			String exception = "Exception " + re;
			logger.warning( exception );
		}
	}
}

// end of NullPointerDereference_good_476.java
0
---------------------------------
package good;
/* 
 * This software was developed at the National Institute of Standards and
 * Technology by employees of the Federal Government in the course of their
 * official duties. Pursuant to title 17 Section 105 of the United States
 * Code this software is not subject to copyright protection and is in the
 * public domain. NIST assumes no responsibility whatsoever for its use by
 * other parties, and makes no guarantees, expressed or implied, about its
 * quality, reliability, or any other characteristic.
 *
 * This reference program was developed in June 2009 as part of the Software
 * Assurance Metrics And Tool Evaluation (SAMATE) project.
 * We would appreciate acknowledgment if the software is used.
 * The SAMATE project website is: http://samate.nist.gov
 */

/*
 * This code has a Time-of-Check Time-of-Use (TOCTOU) CWE-367 vulnerability.
 * http://cwe.mitre.org
 * It checks the state of the file myfile.txt, but its state can change
 * with the function sleep, but is verified before using it.
 */


import java.io.*;
import java.util.logging.Logger;


public class TimeOfCheckTimeOfUse_good_367
{
	public TimeOfCheckTimeOfUse_good_367()
	{
		try
		{
			// Try to open the given file
			File f = new File( "Z:/TCG_Java_Test_Cases/367_TOCTOU_java/myfile.txt" );
			
		    if( f.canWrite() == false )
		    {
		    	// Try to cause the currently executing thread to sleep
		    	try
		    	{
					// The state of the file may change in the meantime
		    		Thread.sleep( 1000 );
		    	}
			    catch (InterruptedException e)
			    {
			    	final Logger logger = Logger.getAnonymousLogger();
					String exception = "Exception " + e;
					logger.warning( exception );
			    }
			    
			    // Verify the state hasn't changed
			    if( f.canWrite() == false )
			    {
					// Create the file if it didn't exist before the sleep function
			    	FileWriter fw = new FileWriter( f );
			    	fw.close();
			    }
		     }
		}
		catch ( IOException e )
		{
			final Logger logger = Logger.getAnonymousLogger();
			String exception = "Exception " + e;
			logger.warning( exception );
		}
	}
	
	public static void main( String argv[] )
	{
	    new TimeOfCheckTimeOfUse_good_367();
	}
}

//end of TimeOfCheckTimeOfUse_good_367.java
0
---------------------------------
package good;
/* 
 * This software was developed at the National Institute of Standards and
 * Technology by employees of the Federal Government in the course of their
 * official duties. Pursuant to title 17 Section 105 of the United States
 * Code this software is not subject to copyright protection and is in the
 * public domain. NIST assumes no responsibility whatsoever for its use by
 * other parties, and makes no guarantees, expressed or implied, about its
 * quality, reliability, or any other characteristic.
 *
 * This reference program was developed in June 2009 as part of the Software
 * Assurance Metrics And Tool Evaluation (SAMATE) project.
 * We would appreciate acknowledgment if the software is used.
 * The SAMATE project website is: http://samate.nist.gov
 */

/*
 * This code has a Resource Injection CWE-99 vulnerability. http://cwe.mitre.org
 * It creates a file with the data read after filtering, which would allow, for
 * instance "admin.dat"!
 */


import java.io.*;
import java.util.logging.Logger;

public class ResourceInjection_good_099
{
	// Table of allowed files to use
	final String allowed_tab[] = { "users_site.dat", "users_reg.dat", 
			"users_info.dat", "admin.dat", "services.dat.cxx"};
	 
	// Function to check if the current file takes part of the allowed ones
	public boolean allowed( String in )
	{
		boolean bool = false;
		
        for( int i = 0; i < 5; i++ )
        {
            if( in.equals( allowed_tab[i] ) )
            {
              	// the current file is allowed to use
                bool = true;
                break;
            }
        }
        return bool;
	}
	
	public ResourceInjection_good_099()
	{
		byte inputBuffer[] = new byte[ 128 ];
		
		// Data to write
		byte data[] = { 1,0,1,1,1,1,1,1,0,0,0,0 };

		try
		{
			// Read data from the standard input
			int byteCount = System.in.read( inputBuffer );
			
			// Check whether data has been read or not
			if( byteCount <= 0 )
			{
				return;
			}
	
			// Turn data into a String
			String s = new String( inputBuffer );
			s = s.substring( 0, byteCount-2 );

			if( allowed( s ) == true )
	        {
				// The current file is allowed to use so we can create 
				// a FileOutputStream from it
                FileOutputStream f = new FileOutputStream( s );
	        
                try
                {
					// Try to write data in the file
					f.write( data );
				}
				catch( IOException e )
				{
					final Logger logger = Logger.getAnonymousLogger();
					String exception = "Exception " + e;
					logger.warning( exception );
				}
				f.close();
	        }
			else
				return;
		}
		catch( IOException e )
		{
			final Logger logger = Logger.getAnonymousLogger();
			String exception = "Exception " + e;
			logger.warning( exception );
		}
	}
	
	public static void main( String[] argv )
	{
		new ResourceInjection_good_099();
	} 
}

//end of ResourceInjection_good_099.java
0
---------------------------------
package goodCodeComplexity;
/* 
 * This software was developed at the National Institute of Standards and
 * Technology by employees of the Federal Government in the course of their
 * official duties. Pursuant to title 17 Section 105 of the United States
 * Code this software is not subject to copyright protection and is in the
 * public domain. NIST assumes no responsibility whatsoever for its use by
 * other parties, and makes no guarantees, expressed or implied, about its
 * quality, reliability, or any other characteristic.
 *
 * This reference program was developed in June 2009 as part of the Software
 * Assurance Metrics And Tool Evaluation (SAMATE) project.
 * We would appreciate acknowledgment if the software is used.
 * The SAMATE project website is: http://samate.nist.gov
 */

/*
 * This code implements an OS Command Injection CWE-78 vulnerability, with a
 * Loop Structure complexity. http://cwe.mitre.org
 * It tries to execute a system command which is read in the inputBuffer
 * and checked for a valid operating system command.
 */


import java.io.*;
import java.util.logging.Logger;

public class OSCommandInjection_good_LoopStructure_078
{
	public OSCommandInjection_good_LoopStructure_078()
	{
		for ( int i = 0; i < 3; i++ )
		{
			byte inputBuffer[] = new byte[ 128 ];
			try
			{
				// Read data from the standard input
				int byteCount = System.in.read( inputBuffer );
	
				// Check whether data has been read or not
				if( byteCount <= 0 )
				{
					return;
				}
	
				// Turn data into a String and build a process
				String command = new String( inputBuffer );
				command = command.substring( 0, byteCount-2 );
				ProcessBuilder p = new ProcessBuilder( command );
				
				// The function start checks that the command is
				// a valid operating system command
				p.start();
			}
			catch( IOException e )
			{
				final Logger logger = Logger.getAnonymousLogger();
				String exception = "Exception " + e;
				logger.warning( exception );
			}
		}
	}
	
	public static void main( String[] argv )
	{
		new OSCommandInjection_good_LoopStructure_078();
	}
}

// end of OSCommandInjection_good_LoopStructure_078.java
0
---------------------------------
package servlets;
/*
 * This software was developed at the National Institute of Standards and
 * Technology by employees of the Federal Government in the course of their
 * official duties. Pursuant to title 17 Section 105 of the United States
 * Code this software is not subject to copyright protection and is in the
 * public domain. NIST assumes no responsibility whatsoever for its use by
 * other parties, and makes no guarantees, expressed or implied, about its
 * quality, reliability, or any other characteristic.
 *
 * This reference program was developed in Jan 2010 as part of the Software
 * Assurance Metrics And Tool Evaluation (SAMATE) project.
 * We would appreciate acknowledgment if the software is used.
 * The SAMATE project website is: http://samate.nist.gov
 */

/*
 * This code (java servlet) has a Failure to Preserve Web Page
 * Structure 'Cross-site Scripting (XSS)' CWE-79 CWE-259 vulnerability.
 * http://cwe.mitre.org
 *
 * This code demos the Stored XSS (or Presistent) ==> "Scope Good Case".
 * The servlet retrieves the records from database and
 * reflects it back into the HTTP response after performing the
 * validate, filter, escape and encode of that retrieved data.
 */

import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.ServletException;
import javax.servlet.ServletContext;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import javax.naming.Context;
import javax.naming.InitialContext;
import javax.naming.NamingException;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import javax.sql.DataSource;

public class cwe79_storedXSS_good_scope extends HttpServlet {


    public void doGet(
        HttpServletRequest request,
        HttpServletResponse response) throws ServletException, IOException {

        PrintWriter out = response.getWriter();

        out.println("<html>" + "<head><title>CWE79 Stored XSS (Scope) Good</title></head>");
        out.println(
                "<body  bgcolor=\"#ffffff\">"
                + "<h4>Found the following messages:</h4>");

	   	Connection conn = null;

		try {

			// Set the context factory to use to create the initial context
			System.setProperty (Context.INITIAL_CONTEXT_FACTORY,"your.ContextFactory");

			// Create the initial context and use it to lookup the data source
			InitialContext ic = new InitialContext ();
			DataSource dataSrc = (DataSource) ic.lookup ("jdbc/TestDB");

			// Create a connection to the database from the data source
			conn = dataSrc.getConnection();

			PreparedStatement pstmt = conn.prepareStatement("select test_msg from test_msgs");
			ResultSet rs = pstmt.executeQuery();

			int count = 1;

			while ( rs.next() ) {
				String tmpString = getRes (rs, "test_msg");	/* Scope */
				if (isValidateInput(tmpString)) {
				   	String cleanedStr = htmlEntityEncode (tmpString);

				   	if ((cleanedStr != null) && (cleanedStr.length() > 0)) {
					   out.println ("msg # ");
					   out.println (Integer.toString(count));
					   out.println (htmlEntityEncode ("-->"));
					   out.println (cleanedStr);	/* OK - retrieved data is being validated and encoded */
				   	   out.println ("<br>");
					}
				   	count++;
			 	}
			}
		}
		catch( NamingException e ) {
			    out.println( "Naming exception: ");
		}
		catch (SQLException se) {
			out.println ("SQL exception occured: ");

		}
		catch (Exception e) {
			out.println ("General Exception occured: ");
		}
		finally {
			try {
					if (conn != null) {
		    			conn.close();
					}
				}
				catch (SQLException se) {
					out.println ("SQL exception occured: ");
				}
		}
		out.println("</body></html>");
        out.close();
    }

	private String getRes (ResultSet rs, String rsColName) throws SQLException{
		return rs.getString(rsColName);
	}

	/*
	 * To prevent XSS, assume all input is malicious. This function is just
	 * an example and placeholder for demonstrating the need of performing proper
	 * output encoding, escaping and quoting. All references are used as example for
	 * demonstration only.They are neither for endorsement nor recommendation.
	 *
	 * One should decide to use existing Security API
	 * (e.g., OWASP Enterprise Security API (ESAPI) 2.0), or customized API, or
	 * customized functions for the same purpose.
	 *
	 * This test case used two functions for the purpose of protecting against XSS.
	 *   - isValudateInput - uses whitelist method to check the user input (example only)
	 *   - htmlEntityEncode - does the html encode (sourced by OWASP:
	 *              http://www.owasp.org/index.php/How_to_perform_HTML_entity_encoding_in_Java)
	 *
	 */
	private static final boolean isValidateInput (String uInput) {

		/*
		 * used as example with the whitelist to only allow alphnumeric, space and "'" as
		 * character set for name.  The length of the user input is also registrted within 100
		 *
		 */

		if (uInput == null)
			return false;

		if (uInput.matches ("[a-zA-Z0-9' ]*") && (uInput.length() <= 100))
			return true;
		else
			return false;
	}

    // From OWASP: Return StringBuilder and/or make Writer param and write to stream directly
    public static String htmlEntityEncode( String s )
        {
                int len = s.length();
                StringBuilder buf = new StringBuilder(len);

                for ( int i = 0; i < len; i++ )
                {
                        char c = s.charAt( i );
                        if ( c>='a' && c<='z' || c>='A' && c<='Z' || c>='0' && c<='9' )
                        {
                                buf.append( c );
                        }
                        else
                        {
                                buf.append("&#").append((int)c).append(";");
                        }
                }

                return buf.toString();
    }

    public String getServletInfo() {
        return "The Hello servlet says hello (with CWE79 Stored XSS (Scope) good sample code).";
    }
}

0
---------------------------------
package servlets;
/*
 * This software was developed at the National Institute of Standards and
 * Technology by employees of the Federal Government in the course of their
 * official duties. Pursuant to title 17 Section 105 of the United States
 * Code this software is not subject to copyright protection and is in the
 * public domain. NIST assumes no responsibility whatsoever for its use by
 * other parties, and makes no guarantees, expressed or implied, about its
 * quality, reliability, or any other characteristic.
 *
 * This reference program was developed in Jan 2010 as part of the Software
 * Assurance Metrics And Tool Evaluation (SAMATE) project.
 * We would appreciate acknowledgment if the software is used.
 * The SAMATE project website is: http://samate.nist.gov
 */

/*
 * This code (java servlet) has a FIX to Failure to Preserve Web Page
 * Structure 'Cross-site Scripting (XSS)' CWE-79 vulnerability.
 * http://cwe.mitre.org
 *
 * This code demos the Reflected XSS (or Non-Persistent) ==> "Basic Good Case".
 * The servlet reads the user input from the HTTP request and
 * reflects it back into the HTTP response after performing the
 * validate, filter, escape and encode of that user input data.
 *
 */

import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class cwe79_reflectedXSS_good extends HttpServlet {

    public void doGet(
        HttpServletRequest request,
        HttpServletResponse response) throws ServletException, IOException {

        response.setContentType("text/html");

        PrintWriter out = response.getWriter();

        out.println("<html>" + "<head><title>CWE79 Reflected XSS Good</title></head>");

        out.println(
                "<body  bgcolor=\"#ffffff\">"
                + "<h4>Hello, my name is Test4XSS. What's yours?</h4>"
                + "<form method=\"get\">"
                + "<input type=\"text\" name=\"username\" size=\"50\">"
                + "<p></p>" + "<input type=\"submit\" value=\"Submit\">"
                + "<input type=\"reset\" value=\"Reset\">" + "</form>");

        String username = request.getParameter("username");

		if (isValidateInput(username)) {
			String cleanedUsername = htmlEntityEncode (username);
			if ((cleanedUsername != null) && (cleanedUsername.length() > 0)) {
				out.println ("<h4>Hello, ");
				out.println (cleanedUsername);	/* OK - user input is being validated and encoded */
				out.println ("!</h4>");
			}
		}
		else if (username != null) {
			out.println ("<h4>Sorry, your input is invalid</h4>");
		}
        out.println("</body></html>");
        out.close();
    }

	/*
	 * To prevent XSS, assume all input is malicious. This function is just
	 * an example and placeholder for demonstrating the need of performing proper
	 * output encoding, escaping and quoting. All references are used as example for
	 * demonstration only.They are neither for endorsement nor recommendation.
	 *
	 * One should decide to use existing Security API
	 * (e.g., OWASP Enterprise Security API (ESAPI) 2.0), or customized API, or
	 * customized functions for the same purpose.
	 *
	 * This test case used two functions for the purpose of protecting against XSS.
	 *   - isValudateInput - uses whitelist method to check the user input (example only)
	 *   - htmlEntityEncode - does the html encode (sourced by OWASP:
	 *              http://www.owasp.org/index.php/How_to_perform_HTML_entity_encoding_in_Java)
	 *
	 */
	private static final boolean isValidateInput (String uInput) {

		/*
		 * used as example with the whitelist to only allow alphnumeric, space and "'" as
		 * character set for name.  The length of the user input is also registrted within 100
		 *
		 */

		if (uInput == null)
			return false;

		if (uInput.matches ("[a-zA-Z0-9' ]*") && (uInput.length() <= 100))
			return true;
		else
			return false;
	}

    // From OWASP: Return StringBuilder and/or make Writer param and write to stream directly
    public static String htmlEntityEncode( String s )
        {
                int len = s.length();
                StringBuilder buf = new StringBuilder(len);

                for ( int i = 0; i < len; i++ )
                {
                        char c = s.charAt( i );
                        if ( c>='a' && c<='z' || c>='A' && c<='Z' || c>='0' && c<='9' )
                        {
                                buf.append( c );
                        }
                        else
                        {
                                buf.append("&#").append((int)c).append(";");
                        }
                }

                return buf.toString();
    }

    public String getServletInfo() {
        return "The Hello servlet says hello.(with CWE79 Reflected fixed XSS sample code).";
    }
}

0
---------------------------------
package servlets;
/*
 * This software was developed at the National Institute of Standards and
 * Technology by employees of the Federal Government in the course of their
 * official duties. Pursuant to title 17 Section 105 of the United States
 * Code this software is not subject to copyright protection and is in the
 * public domain. NIST assumes no responsibility whatsoever for its use by
 * other parties, and makes no guarantees, expressed or implied, about its
 * quality, reliability, or any other characteristic.
 *
 * This reference program was developed in Jan 2010 as part of the Software
 * Assurance Metrics And Tool Evaluation (SAMATE) project.
 * We would appreciate acknowledgment if the software is used.
 * The SAMATE project website is: http://samate.nist.gov
 */

/*
 * This code (java servlet) has a Failure to Preserve Web Page
 * Structure 'Cross-site Scripting (XSS)' CWE-79 CWE-259 vulnerability.
 * http://cwe.mitre.org
 *
 * This code demos the Stored XSS (or Presistent) ==> "Loop Good Case".
 * The servlet retrieves the records from database and
 * reflects it back into the HTTP response after performing the
 * validate, filter, escape and encode of that retrieved data.
 */

import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.ServletException;
import javax.servlet.ServletContext;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import javax.naming.Context;
import javax.naming.InitialContext;
import javax.naming.NamingException;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import javax.sql.DataSource;

public class cwe79_storedXSS_good_loop extends HttpServlet {


    public void doGet(
        HttpServletRequest request,
        HttpServletResponse response) throws ServletException, IOException {

        PrintWriter out = response.getWriter();

        out.println("<html>" + "<head><title>CWE79 Stored XSS (Loop) Good</title></head>");
        out.println(
                "<body  bgcolor=\"#ffffff\">"
                + "<h4>Found the following messages:</h4>");

	   	Connection conn = null;

		try {

			// Set the context factory to use to create the initial context
			System.setProperty (Context.INITIAL_CONTEXT_FACTORY,"your.ContextFactory");

			// Create the initial context and use it to lookup the data source
			InitialContext ic = new InitialContext ();
			DataSource dataSrc = (DataSource) ic.lookup ("jdbc/TestDB");

			// Create a connection to the database from the data source
			conn = dataSrc.getConnection();

			PreparedStatement pstmt = conn.prepareStatement("select test_msg from test_msgs");
			for (int i = 1; i<4; i++) {	/* Loop */
				out.println ("Loop # " + i + ":<br>");

				ResultSet rs = pstmt.executeQuery();

				int count = 1;

				while ( rs.next() ) {
				   String tmpString = rs.getString("test_msg");
				   if (isValidateInput(tmpString)) {
				   		String cleanedStr = htmlEntityEncode (tmpString);

				   		if ((cleanedStr != null) && (cleanedStr.length() > 0)) {
					   		out.println ("msg # ");
							out.println (Integer.toString(count));
							out.println (htmlEntityEncode ("-->"));
				   			out.println (cleanedStr);   /* OK - retrieved data is being validated and encoded */
					   		out.println ("<br>");
						}
						count++;
					}
				}
			}
		}
		catch( NamingException e ) {
			    out.println( "Naming exception: ");
		}
		catch (SQLException se) {
			out.println ("SQL exception occured: ");

		}
		catch (Exception e) {
			out.println ("General Exception occured: ");
		}
		finally {
			try {
					if (conn != null) {
		    			conn.close();
					}
				}
				catch (SQLException se) {
					out.println ("SQL exception occured: ");
				}
		}
		out.println("</body></html>");
        out.close();
    }

	/*
	 * To prevent XSS, assume all input is malicious. This function is just
	 * an example and placeholder for demonstrating the need of performing proper
	 * output encoding, escaping and quoting. All references are used as example for
	 * demonstration only.They are neither for endorsement nor recommendation.
	 *
	 * One should decide to use existing Security API
	 * (e.g., OWASP Enterprise Security API (ESAPI) 2.0), or customized API, or
	 * customized functions for the same purpose.
	 *
	 * This test case used two functions for the purpose of protecting against XSS.
	 *   - isValudateInput - uses whitelist method to check the user input (example only)
	 *   - htmlEntityEncode - does the html encode (sourced by OWASP:
	 *              http://www.owasp.org/index.php/How_to_perform_HTML_entity_encoding_in_Java)
	 *
	 */
	private static final boolean isValidateInput (String uInput) {

		/*
		 * used as example with the whitelist to only allow alphnumeric, space and "'" as
		 * character set for name.  The length of the user input is also registrted within 100
		 *
		 */

		if (uInput == null)
			return false;

		if (uInput.matches ("[a-zA-Z0-9' ]*") && (uInput.length() <= 100))
			return true;
		else
			return false;
	}

    // From OWASP: Return StringBuilder and/or make Writer param and write to stream directly
    public static String htmlEntityEncode( String s )
        {
                int len = s.length();
                StringBuilder buf = new StringBuilder(len);

                for ( int i = 0; i < len; i++ )
                {
                        char c = s.charAt( i );
                        if ( c>='a' && c<='z' || c>='A' && c<='Z' || c>='0' && c<='9' )
                        {
                                buf.append( c );
                        }
                        else
                        {
                                buf.append("&#").append((int)c).append(";");
                        }
                }

                return buf.toString();
    }

    public String getServletInfo() {
        return "The Hello servlet says hello (with CWE79 Stored XSS (Loop) good sample code).";
    }
}

0
---------------------------------